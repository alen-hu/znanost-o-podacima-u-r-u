[
  {
    "objectID": "01_01_uvod_u_znanost_o_podacima.html",
    "href": "01_01_uvod_u_znanost_o_podacima.html",
    "title": "1  Uvod u znanost o podacima",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Uvod u znanost o podacima",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Uvod u znanost o podacima</span>"
    ]
  },
  {
    "objectID": "02_02_uredivanje_podataka.html",
    "href": "02_02_uredivanje_podataka.html",
    "title": "3  Uređivanje podataka",
    "section": "",
    "text": "1 Format podataka u R-u\nUređivanje podataka (data tidying) predstavlja proces transformacije podataka iz oblika u kojem su inicijalno organizirani u konzistentan i standardiziran format koji olakšava analizu i vizualizaciju. Uređivanje podataka zapravo obuhvaća pohranjivanje podataka u konzistentnom obliku koji odgovara semantici skupa podataka s načinom na koji su pohranjeni. Ovaj je proces temeljni korak u cjelokupnom procesu analize podataka jer omogućuje lakši i efikasniji rad s podacima pomoću različitih analitičkih alata.\nUređivanje i transformacija podataka zajedno se kolokvijalno nazivaju hrvanje s podacima (data wrangling) jer se odnose na dovođenje podataka u oblik prirodan za rad, a koji često nalikuje hrvanju s podacima. Većina stvarnih podataka nije uredna u početnoj fazi što znači da većina analiza zahtijevati barem malo uređivanja. Glavni cilj uređivanja podataka pritom nije stvaranje vizualno privlačnih prikaza podataka, nego uspostavljanje strukture koja omogućuje efikasno korištenje analitičkih alata i funkcija.\nU procesu bavljenja s podacima, uređivanje predstavlja ključnu kariku između uvoza podataka u R i njihove analize. Drugim riječima, nakon što se podaci uvezu, nužno je njihovo uređivanje jer uređeni podaci omogućuju fokusiranje napora na odgovaranje pitanja o podacima, a ne borbu s dovođenjem podataka u odgovarajući oblik za različite funkcije. Ovaj pristup značajno smanjuje mogućnost grešaka tijekom analize, ali i povećava produktivnost analitičara u bavljenju s podacima.\nUredni podaci (tidy data) predstavljaju konzistentan način organiziranja podataka. Postoje tri međusobno povezana pravila koja čine skup podataka urednim:\nSegmenti podataka u podatkovnom okviru raspoređeni su kroz varijable, opažanja i pojedine vrijednosti. Varijabla predstavlja svojstvo ili karakteristiku koja se mjeri i koja može poprimiti različite vrijednosti. U kontekstu filmskih podataka, varijable mogu biti naziv filma, godina premijere, žanr ili trajanje filma. U urednim podatkovnim okvirima one su raspoređene u stupcima podatkovnih okvira. To znači da svaki stupac predstavlja jednu vrstu informacije. Primjerice, varijable mogu biti “movie” u kojoj se nalaze nazivi filmova, “realise_year” u kojoj se nalaze godine kada je film premijerno prikazan, “runtime” u kojoj se nalazi trajanje filma itd. Opažanje predstavlja jedan slučaj ili jedinicu analize za koju prikupljamo podatke o različitim varijablama. U urednim podatkovnim okvirima opažanja su pojedini redovi u tablici koji pripadaju jednoj jedinici analize (npr. jednom ispitaniku, kućanstvu, državi itd.) i sadrži vrijednosti niza varijabli koje opisuju tu jedinicu. Dok varijable predstavljaju svojstva, opažanja su konkretne realizacije tih svojstava za svaku jedinicu. U primjeru filmova svaki red predstavlja po jedan film koji je po jedno opažanje. Vrijednost je sadržaj jedne ćelije na sjecištu određene varijable i opažanja. Ona predstavlja jednu mjeru jedne varijable za jednu jedinicu i ne bi smjela sadržavati više informacija spojenih u istu ćeliju. U tehničkom smislu pojedinačna vrijednost je vrijednost određenog tipa podataka (npr. broj, logička vrijednost, znakovni niz, datum ili nedostajuća vrijednost). Na primjer, vrijednost koja prikazuje varijablu “realise_year” za opažanje “The Shawshak Redemption” je “1994”, a vrijednost koja prikazuje varijablu “director” za opažanje “The Lord of the Rings: The Return of the King” je “Peter Jackson”.\nPrimjer jednog urednog podatkovnog okvira je imdb_top_10_tidy_dataset u kojem je svaki redak jedno je opažanje, odnosno jedan film, a svaki stupac pojedino obilježje filma, odnosno varijabla koja prikazuje naziv, godinu izdanja, glumce, redatelje i ostale informacije o filmovima.\nUredna struktura podataka je važna jer čini podatke kompatibilnima s R-ovim vektoriziranim pristupom i omogućuje direktnu upotrebu funkcija kao što su filter(), group_by(), summarise() i ggplot() bez dodatnih transformacija podataka. Kada su podatci uredni, moguće je direktno filtrirati podatke po bilo kojoj varijabli, grupirati podatke po kategorijama i kreirati vizualizacije bez složenih priprema. Ako su podaci neuredni, onda je provođenje svih ovih postupaka uvelike otežano.\nIsti podaci mogu se organizirati u dugački (long) i široki (wide) format. Primjena ova dva formata ključno je za efikasno uređivanje podataka jer različite analize i vizualizacije zahtijevaju različite formate podataka.\nDugački format karakteriziran je time što se sve vrijednosti jedne varijable nalaze u jednom stupcu. Ovaj format rezultira podatkovnim okvirom s više redaka, ali manjim brojem stupaca. Dugački format prirodniji je za analizu podataka jer slijedi temeljna načela urednih podataka. U ovom formatu lakše je provoditi grupne operacije, stvarati vizualizacije i primjenjivati statističke funkcije.\nPrimjer jednog takvog podatkovnog okvira je imdb_top_10_long. Podaci su organizirani u dugom obliku s četiri stupca: “rank”, “movie”, “attribute” i “value”. Stupci “rank” i “movie” čine identifikator svakog filma, a za svaki film postoji po više redaka, odnosno po jedan redak za svako obilježje koje je zapisano u varijabli “attribute”. Naziv obilježja pritom stoji u varijabli “attribute”, dok se sama vrijednost obilježja nalazi u varijabli “value”. Time jedan film zauzima po jedan red za svaki atribut.\nimdb_top_10_long\n\n# A tibble: 100 × 4\n    rank movie                    attribute           value                     \n   &lt;dbl&gt; &lt;chr&gt;                    &lt;chr&gt;               &lt;chr&gt;                     \n 1     1 The Shawshank Redemption release_year        1994                      \n 2     1 The Shawshank Redemption countries_of_origin United States             \n 3     1 The Shawshank Redemption director            Frank Darabont            \n 4     1 The Shawshank Redemption writers             Stephen King, Frank Darab…\n 5     1 The Shawshank Redemption stars               Tim Robbins, Morgan Freem…\n 6     1 The Shawshank Redemption genres              Drama                     \n 7     1 The Shawshank Redemption language            English                   \n 8     1 The Shawshank Redemption runtime             142                       \n 9     1 The Shawshank Redemption colour              Color                     \n10     1 The Shawshank Redemption budget              25000000                  \n# ℹ 90 more rows\nŠiroki format karakterizira raspored u kojem svaka promatrana jedinica zauzima jedan redak, dok se različite varijable te jedinice nalaze u zasebnim stupcima. Drugim riječima, informacije su raširene po stupcima, a ne grupirane u jedan stupac s pripadajućim identifikatorima. Temeljna karakteristika širokog formata je da svaka kombinacija jedinice i varijable ima vlastiti stupac što često rezultira velikim brojem stupaca, osobito kada se radi o ponovljenim mjerenjima kroz vrijeme, različitim uvjetima ili kategorijama.\nPrimjer takvog podatkovnog okvira je imdb_decades u kojem svaki redak predstavlja po jedan film, svaki stupac pojedino desetljeće, a u ćelijama nalazi godina premijere filma u stupcu desetljeća u kojem je film nastao, odnosno NA ako film nije nastao u tom desetljeću.\n# A tibble: 10 × 7\n   movie                         `1950s` `1960s` `1970s` `1980s` `1990s` `2000s`\n   &lt;chr&gt;                           &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;lgl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n 1 The Shawshank Redemption           NA      NA      NA NA         1994      NA\n 2 The Godfather                      NA      NA    1972 NA           NA      NA\n 3 The Dark Knight                    NA      NA      NA NA           NA    2008\n 4 The Godfather Part II              NA      NA    1974 NA           NA      NA\n 5 12 Angry Men                     1957      NA      NA NA           NA      NA\n 6 Lord of the Rings: Return of…      NA      NA      NA NA           NA    2003\n 7 Schindler's List                   NA      NA      NA NA         1993      NA\n 8 Pulp Fiction                       NA      NA      NA NA         1994      NA\n 9 Lord of the Rings: Fellowship      NA      NA      NA NA           NA    2001\n10 The Good, the Bad and the Ug…      NA    1966      NA NA           NA      NA\nPritom je važno naglasiti da nijedan od ova dva formata nije inherentno uredan ili neuredan, nego to ovisi o tome što stupci, redovi i ćelije predstavljaju u kontekstu podataka. Dugački format je općenito bolji za analizu podataka jer funkcije poput dplyr paketa prirodno rade s jednim stupcem vrijednosti, a ggplot2 paket je dizajniran za dugački format jer mapira estetike na stupce. Također, u dugačkom je formatu lakše dodavati nova vremenska razdoblja ili kategorije jer se jednostavno dodaju novi redovi umjesto novih stupaca. Široki format je bolji za prezentaciju i izvještaje jer je ljudima prirodnije čitati podatke kada su povezane vrijednosti prikazane horizontalno kao stupci, kao i za matrične operacije poput korelacijske analize ili unos podataka jer odražava način kako ljudi razmišljaju o podacima.",
    "crumbs": [
      "Uvoz i uređivanje podataka",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Uređivanje podataka</span>"
    ]
  },
  {
    "objectID": "02_02_uredivanje_podataka.html#format-podataka-u-r-u",
    "href": "02_02_uredivanje_podataka.html#format-podataka-u-r-u",
    "title": "3  Uređivanje podataka",
    "section": "",
    "text": "Tablica 1: Široki format\n\n\n\n\n\nID\nA\nB\nC\n\n\n\n\n1\n10\n20\n30\n\n\n2\n40\n50\n60\n\n\n\n\n\n\n\n\n\n\n\nTablica 2: Dugački format\n\n\n\n\n\nID\nname\nvalue\n\n\n\n\n1\nA\n10\n\n\n1\nB\n20\n\n\n1\nC\n30\n\n\n2\nA\n40\n\n\n2\nB\n50\n\n\n2\nC\n60",
    "crumbs": [
      "Uvoz i uređivanje podataka",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Uređivanje podataka</span>"
    ]
  },
  {
    "objectID": "02_02_uredivanje_podataka.html#uređivanje-neurednih-podataka",
    "href": "02_02_uredivanje_podataka.html#uređivanje-neurednih-podataka",
    "title": "3  Uređivanje podataka",
    "section": "2 Uređivanje neurednih podataka",
    "text": "2 Uređivanje neurednih podataka\nKada podaci u podatkovnom okviru ne ispunjavaju uvjete o urednim podacima, onda podatke takvih podatkovnih okvira nazivamo neurednim podacima te je bilo kakav rad na podacima otežan. Postoje različiti mogući oblici neurednih podataka, odnosno različiti načini na koji podaci u podatkovnom okviru mogu biti posloženi, a koji otežavaju daljnji rad na podacima. Pritom uređivanje uključuje produljenje i proširenje podataka. Produljenje podataka uključuje pretvaranje širokih podatkovnih okvira u oblik koji ima više redaka, a manje stupaca. Suprotno, proširenje podataka uključuje pretvaranje dugih tablica u oblik koji ima manje redaka i više stupaca.\nZa uređivanje podataka u R-u najčešće se koriste dvije funkcije iz tidyr paketa, pivot_longer() za produljivanje i pivot_wider() za proširivanje. pivot_longer() pretvara široku tablicu u dugu, a rezultat je više redaka i manje stupaca. pivot_wider() radi suprotno, iz duge tablice stvara široku, a rezultat je manje redaka i više stupaca. Osim ove dvije funkcije, tidyr paket sadrži još neke funkcije koje pomažu uređivanje podataka. Može se pojaviti više oblika neurednih podatkovnih okvira koje je potrebno urediti.\n\n\n\n\n\n\nTipFunkcija: pivot_longer()\n\n\n\n\n\nFunkcija pivot_longer() dio je tidyr paketa koja produžuje podatke povećavajući broj njihovih redaka i smanjujući broj stupaca. Funkcija može imati slijedeće argumente:\n\n\n\n\n\n\n\nArgument\nObjašnjenje\n\n\n\n\ndata\nPodatkovni okvir u širokom format.\n\n\ncols\nOdređuje koji se stupci pretvaraju u dugi oblik.\n\n\ncols_vary\nOdređuje redoslijed “slaganja” vrijednosti kada ih R raspoređuje u duži oblik. Može biti fastest (zadano) čime se najbrže mijenja stupac (vrijednosti se slažu “po stupcima”) i slowest čime se najsporije mijenja stupac (vrijednosti se slažu “po redovima”).\n\n\nnames_to\nNaziv ili nazivi novih stupaca koji će sadržavati nazive starih stupaca.\n\n\nnames_prefix\nNiz koji će se ukloniti iz naziva stupaca prije nego što se oni stave u names_to.\n\n\nnames_sep\nKoristi se kada u names_to kako bi se njime definirlo koji se razdjelnik koristiti za razbijanje naziva.\n\n\nnames_pattern\nAlternativa names_sep, ali koristi regularne izraze za razbijanje naziva.\n\n\nnames_ptypes\nDopušta da zadamo tip podataka za stupac ili stupce kreirane u names_to.\n\n\nnames_transform\nFunkcija ili lista funkcija koje se primjenjuju na stupce iz names_to.\n\n\nnames_repair\nŠto učiniti ako se u novim imenima stupaca pojave duplikati (zadano je check_unique koji javlja grešku ako nisu jedinstveni.\n\n\nvalues_to\nIme novog stupca u koji idu vrijednosti skupljenih stupaca.\n\n\nvalues_drop_na\nAko je TRUE, brišu se redci u kojima su vrijednosti NA u stupcu values_to.\n\n\nvalues_ptypes\nKao i names_ptypes, ali za stupac values_to.\n\n\nvalues_transform\nFunkcija ili lista funkcija za transformaciju vrijednosti.\n\n\n\n\n\n\n\n\n\n\n\n\nTipFunkcija: pivot_wider()\n\n\n\n\n\nFunkcija pivot_wider() dio je tidyr paketa koja produžuje podatke smanjujući njihov broj redaka i povećavajući broj stupaca. Funkcija može imati slijedeće argumente:\n\n\n\n\n\n\n\nArgument\nObjašnjenje\n\n\n\n\ndata\nPodatkovni okvir u dugom formatu.\n\n\nid_cols\nStupci koji se koriste kao identifikatori opservacija, a koji ostaju kao redovi.\n\n\nid_expand\nAko je TRUE, onda se stvara puni “cross-join” identifikatora i vrijednosti u names_from. Koristi se kada želimo dobiti sve moguće kombinacije, a ne samo postojeće.\n\n\nnames_from\nStupac ili stupci čije se vrijednosti koriste za nazive novih stupaca.\n\n\nnames_prefix\nDodaje prefiks na nazive stupaca.\n\n\nnames_sep\nRazdjelnik koji se koristi ako imamo više varijabli u names_from (zadano je “_“).\n\n\nnames_glue\nOmogućuje korištenje glue sintakse za definiranje imena stupaca.\n\n\nnames_sort\nAko je TRUE, onda će novi stupci biti sortirani po abecedi. Inače redoslijed ostaje kao u podacima.\n\n\nnames_vary\nKontrolira redoslijed kombiniranja imena stupaca kad names_from ima više varijabli ( može biti fastest ili slowest isto kao kod pivot_longer()).\n\n\nnames_expand\nAko je TRUE, onda se kreiraju svi mogući stupci za sve vrijednosti u names_from čak i ako neke kombinacije ne postoje.\n\n\nnames_repair\nKako se ponašati ako nastanu duplikati u imenima stupaca ( zadano je check_unique koji javlja grešku.\n\n\nvalues_from\nStupac čije vrijednosti želimo staviti u ćelije novih stupaca.\n\n\nvalues_fill\nVrijednost kojom se popunjavaju ćelije ako nema podataka (NA).\n\n\nvalues_fn\nFunkcija koja se koristi ako postoji više vrijednosti za istu kombinaciju identifikatora i naziva stupca (npr. values_fn = mean računa prosjek ako ima više vrijednosti).\n\n\nunused_fn\nFunkcija koja određuje što raditi s varijablama koje nisu u id_cols, names_from ili values_from.\n\n\n\n\n\n\n1. Nazivi varijabli kao vrijednosti\nČest problem koji se susreće kod neuredno organiziranih podataka nastaje kada nazivi stupaca ne predstavljaju nazive varijabli, već vrijednosti neke varijable. Ovaj tip neuredno organiziranih podataka krši temeljna načela urednih podataka jer se vrijednosti jedne varijable nalaze u nazivima stupaca umjesto u jednom stupcu. Takav oblik podataka čini ih teškima za analizu jer funkcije u R-u očekuju da se vrijednosti varijabli nalaze u stupcima, a ne u njihovim nazivima.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nPrimjer takvih neurednih podataka je podatkovni okvir imdb_decades u kojem su nazivi stupaca “1950s”, “1960s”, “1970s”, “1980s”, “1990s” i “2000s”, a koji predstavljaju desetlječa. Varijabla “movie” sadrži nazive filmova, dok ćelije sadrže godinu premijere filma ako film pripada određenom desetljeću, odnosno NA ako ne pripada. Ovaj oblik podataka ima široki format gdje se informacije o godini premijere filma protežu kroz više stupaca, a većina ćelija sadrži nedostajuće vrijednosti.\n\n# Pregled neurednog oblika podatkovnog okvira\nimdb_decades\n\n# A tibble: 10 × 7\n   movie                         `1950s` `1960s` `1970s` `1980s` `1990s` `2000s`\n   &lt;chr&gt;                           &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;lgl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n 1 The Shawshank Redemption           NA      NA      NA NA         1994      NA\n 2 The Godfather                      NA      NA    1972 NA           NA      NA\n 3 The Dark Knight                    NA      NA      NA NA           NA    2008\n 4 The Godfather Part II              NA      NA    1974 NA           NA      NA\n 5 12 Angry Men                     1957      NA      NA NA           NA      NA\n 6 Lord of the Rings: Return of…      NA      NA      NA NA           NA    2003\n 7 Schindler's List                   NA      NA      NA NA         1993      NA\n 8 Pulp Fiction                       NA      NA      NA NA         1994      NA\n 9 Lord of the Rings: Fellowship      NA      NA      NA NA           NA    2001\n10 The Good, the Bad and the Ug…      NA    1966      NA NA           NA      NA\n\n\nProblem se rješava pomoću funkcije pivot_longer(). Funkcija omogućuje specificiranje stupaca koji se trebaju urediti pomoću argumenta cols, naziv nove varijable koja će sadržavati nazive stupaca pomoću argumenta names_to te naziv varijable koja će sadržavati vrijednosti iz ćelija pomoću argumenta values_to. Dodatno, argument values_drop_na = TRUE može se koristiti za uklanjanje redova s nedostajućim vrijednostima.\n\n# Uređivanje podatkovnog okvira\nimdb_decades_tidy &lt;- imdb_decades |&gt;\n  pivot_longer(\n    cols = starts_with(c(\"19\", \"20\")),\n    names_to = \"decade\",\n    values_to = \"year\",\n    values_drop_na = TRUE\n  )\n\nNakon primjene funkcije, dobivamo uređeni podatkovni okvir koji sadrži tri stupca: “movie”, “decade” i “year”. Svaki red predstavlja jedno opažanje - kombinaciju filma i desetljeća s odgovarajućom godinom premijere. Uredni format omogućuje lakše grupiranje podataka po desetljećima, izračunavanje sažetaka te stvaranje vizualizacija što bi bilo komplicirano ili nemoguće u neuredno organiziranom širom formatu.\n\n# Pregled urednog oblika podatkovnog okvira\nimdb_decades_tidy\n\n# A tibble: 10 × 3\n   movie                                 decade  year\n   &lt;chr&gt;                                 &lt;chr&gt;  &lt;dbl&gt;\n 1 The Shawshank Redemption              1990s   1994\n 2 The Godfather                         1970s   1972\n 3 The Dark Knight                       2000s   2008\n 4 The Godfather Part II                 1970s   1974\n 5 12 Angry Men                          1950s   1957\n 6 Lord of the Rings: Return of the King 2000s   2003\n 7 Schindler's List                      1990s   1993\n 8 Pulp Fiction                          1990s   1994\n 9 Lord of the Rings: Fellowship         2000s   2001\n10 The Good, the Bad and the Ugly        1960s   1966\n\n\n\n\n\n2. Više varijabli u nazivima stupaca\nSloženiji oblik neurednih podataka nastaje kada se u nazivima stupaca nalazi više dijelova informacije odvojenih određenim separatorom pri čemu svaki dio predstavlja vrijednost različite varijable. Takva organizacija podataka otežava analizu jer se vrijednosti više varijabli nalaze pomiješane u nazivima stupaca umjesto da svaka varijabla ima svoj vlastiti stupac.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nPrimjer takvih podataka je realise_year_runtime_dataset. Kod tih podataka nazivi stupaca poput “1994_142” i “1972_175” sadrže dvije različite informacije odvojene podvlakom, godinu premijere filma i trajanje filma. Stupci “rank” i “movie” predstavljaju identifikacijske varijable, dok ćelije sadrže informaciju o tome je li film u boji ili crno-bijeli s NA vrijednostima za kombinacije koje ne odgovaraju određenom filmu. Ovaj oblik podataka ima izrazito široki format gdje se tri različite varijable (godina, trajanje i boja) nalaze raspršene kroz nazive stupaca i vrijednosti ćelija.\n\n# Pregled neurednog oblika podatkovnog okvira\nrealise_year_runtime_dataset\n\n# A tibble: 10 × 12\n    rank movie  `1994_142` `1972_175` `2008_152` `1974_202` `1957_96` `2003_201`\n   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;     \n 1     1 The S… Color      &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;      &lt;NA&gt;      \n 2     2 The G… &lt;NA&gt;       Color      &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;      &lt;NA&gt;      \n 3     3 The D… &lt;NA&gt;       &lt;NA&gt;       Color      &lt;NA&gt;       &lt;NA&gt;      &lt;NA&gt;      \n 4     4 The G… &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       Color      &lt;NA&gt;      &lt;NA&gt;      \n 5     5 12 An… &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       Black & … &lt;NA&gt;      \n 6     6 The L… &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;      Color     \n 7     7 Schin… &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;      &lt;NA&gt;      \n 8     8 Pulp … &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;      &lt;NA&gt;      \n 9     9 Lord … &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;      &lt;NA&gt;      \n10    10 The G… &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;      &lt;NA&gt;      \n# ℹ 4 more variables: `1993_195` &lt;chr&gt;, `1994_154` &lt;chr&gt;, `2001_154` &lt;chr&gt;,\n#   `1966_178` &lt;chr&gt;\n\n\nProblem se rješava pomoću funkcije pivot_longer() s dodatnim argumentima za razdvajanje složenih naziva stupaca. Ključni argument names_to prima vektor naziva novih varijabli koje će nastati razdvajanjem naziva stupaca, dok argument names_sep specificira separator koji razdvaja različite dijelove naziva stupaca. U ovom slučaju, names_to = c(\"year\", \"runtime\") stvara dvije nove varijable, a names_sep = \"_\" specificira da se nazivi stupaca dijele po podvlaci. Argument values_drop_na = TRUE uklanja redove s nedostajućim vrijednostima koji predstavljaju umjetno stvorene kombinacije.\n\n# Uređivanje podatkovnog okvira\nrealise_year_runtime_dataset_tidy &lt;- realise_year_runtime_dataset |&gt;\n  pivot_longer(\n    cols = -c(rank, movie),\n    names_to = c(\"year\", \"runtime\"),\n    names_sep = \"_\",\n    values_to = \"value\",\n    values_drop_na = TRUE\n  )\n\nNakon primjene funkcije dobivamo uredni podatkovni okvir koji sadrži pet stupaca: “rank”, “movie”, “year”, “runtime” i “value”. Svaki red predstavlja jedno opažanje - jedan film s njegovim karakteristikama.\n\n# Pregled urednog oblika podatkovnog okvira\nrealise_year_runtime_dataset_tidy\n\n# A tibble: 10 × 5\n    rank movie                                         year  runtime value      \n   &lt;dbl&gt; &lt;chr&gt;                                         &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;      \n 1     1 The Shawshank Redemption                      1994  142     Color      \n 2     2 The Godfather                                 1972  175     Color      \n 3     3 The Dark Knight                               2008  152     Color      \n 4     4 The Godfather Part II                         1974  202     Color      \n 5     5 12 Angry Men                                  1957  96      Black & Wh…\n 6     6 The Lord of the Rings: Return of the King     2003  201     Color      \n 7     7 Schindler's List                              1993  195     Black & Wh…\n 8     8 Pulp Fiction                                  1994  154     Color      \n 9     9 Lord of the Rings: The Fellowship of the Ring 2001  154     Color      \n10    10 The Good, Bas and the Ugly                    1966  178     Color      \n\n\n\n\n\n3. Varijable pohranjene u redovima\nVarijable pohranjene u redovima predstavljaju obrnuti problem od prethodnih slučajeva. U ovom obliku, ono što bi trebale biti varijable nalazi se u redovima, dok se vrijednosti tih varijabli nalaze u drugom stupcu. Ovakav oblik podataka rezultira pretjerano dugačkim formatom gdje se jedno opažanje proteže kroz više redova umjesto da bude sadržano u jednom redu. Ova organizacija čini podatke teškima za analizu jer krši temeljna načela urednih podataka prema kojima svaki red treba predstavljati jedno opažanje.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nU primjeru podatkovnog okvira imdb_top_10_long, svaki film predstavljen je kroz više redova, pri čemu stupac “attribute” sadrži nazive varijabli poput “release_year”, “director”, “genres”, “runtime” i ostale, dok stupac “value” sadrži odgovarajuće vrijednosti tih varijabli. Na primjer, film “The Shawshank Redemption” prikazan je kroz deset redova, po jedan za svaku karakteristiku filma.\n\n# Pregled neurednog oblika podatkovnog okvira\nimdb_top_10_long\n\n# A tibble: 100 × 4\n    rank movie                    attribute           value                     \n   &lt;dbl&gt; &lt;chr&gt;                    &lt;chr&gt;               &lt;chr&gt;                     \n 1     1 The Shawshank Redemption release_year        1994                      \n 2     1 The Shawshank Redemption countries_of_origin United States             \n 3     1 The Shawshank Redemption director            Frank Darabont            \n 4     1 The Shawshank Redemption writers             Stephen King, Frank Darab…\n 5     1 The Shawshank Redemption stars               Tim Robbins, Morgan Freem…\n 6     1 The Shawshank Redemption genres              Drama                     \n 7     1 The Shawshank Redemption language            English                   \n 8     1 The Shawshank Redemption runtime             142                       \n 9     1 The Shawshank Redemption colour              Color                     \n10     1 The Shawshank Redemption budget              25000000                  \n# ℹ 90 more rows\n\n\nProblem se rješava pomoću funkcije pivot_wider(). Funkcija koristi argument names_from za specificiranje stupca koji sadrži nazive budućih varijabli (u ovom slučaju stupac “attribute”) te argument values_from za specificiranje stupca koji sadrži vrijednosti tih varijabli (stupac “value”). Funkcija pivot_wider() automatski grupira podatke prema svim stupcima koji nisu specificirani u names_from i values_from argumentima što znači da će se podaci grupirati po “rank” i “movie” stupcima.\n\n# Uređivanje podatkovnog okvira\nimdb_top_10_wide &lt;- imdb_top_10_long |&gt;\n  pivot_wider(\n    names_from = attribute,\n    values_from = value\n  )\n\nNakon primjene pivot_wider() funkcije, dobivamo uređeni podatkovni okvir koji sadrži 12 stupaca: identifikacijske varijable “rank” i “movie” te deset novih stupaca koji predstavljaju filmske karakteristike. Svaki od 10 redova predstavlja jedan film s njegovim kompletnim karakteristikama.\n\n# Pregled urednog oblika podatkovnog okvira\nhead(imdb_top_10_wide, 3)\n\n# A tibble: 3 × 12\n   rank movie     release_year countries_of_origin director writers stars genres\n  &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;chr&gt;               &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; \n1     1 The Shaw… 1994         United States       Frank D… Stephe… Tim … Drama \n2     2 The Godf… 1972         United States       Francis… Mario … Marl… Crime…\n3     3 The Dark… 2008         United States, Uni… Christo… Jonath… Chri… Actio…\n# ℹ 4 more variables: language &lt;chr&gt;, runtime &lt;chr&gt;, colour &lt;chr&gt;, budget &lt;chr&gt;\n\n\n\n\n\n4. Isti tip vrijednosti raspoređen u više stupaca\nČetvrti oblik neurednih podataka nastaje kada se vrijednosti iste varijable raspoređuju u više stupaca umjesto da budu pohranjene u jednom stupcu. Ovaj problem često se javlja kada se podaci dizajniraju za lakši unos podataka, a ne za analizu što rezultira situacijom gdje jedna varijabla biva podijeljena u više stupaca. Takva organizacija krši temeljna načela urednih podataka jer se ista vrsta informacije nalazi u različitim stupcima što otežava analize koje zahtijevaju rad s tom varijablom kao cjelinom.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nwriters_dataset je jedan takav podatkovni okvir. U njemu su informacije o scenaristima filmova podijeljene su u tri odvojena stupca: “writer_1”, “writer_2” i “writer_3”. Stupci “rank” i “movie” predstavljaju identifikacijske varijable, dok se imena scenarista nalaze u odvojenim stupcima ovisno o redoslijedu njihovog navođenja. Većina filmova ima dva ili tri scenarista što znači da se u podatkovnom okviru pojavljuju NA vrijednosti kada film nema dovoljno scenarista za popunjavanje svih stupaca. Ovakav format otežava analize poput brojanja koliko filmova ima određeni scenarist ili grupiranja filmova prema scenaristu.\n\n# Pregled neurednog oblika podatkovnog okvira\nwriters_dataset\n\n# A tibble: 10 × 5\n    rank movie                                        writer_1 writer_2 writer_3\n   &lt;dbl&gt; &lt;chr&gt;                                        &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;   \n 1     1 The Shawshank Redemption                     Stephen… Frank D… &lt;NA&gt;    \n 2     2 The Godfather                                Mario P… Francis… &lt;NA&gt;    \n 3     3 The Dark Knight                              Jonatha… Christo… David S…\n 4     4 The Godfather Part II                        Francis… Mario P… &lt;NA&gt;    \n 5     5 12 Angry Men                                 Reginal… &lt;NA&gt;     &lt;NA&gt;    \n 6     6 The Lord of the Rings: Return of the King    J.R.R. … Fran Wa… Philipp…\n 7     7 Schindler's List                             Thomas … Steven … &lt;NA&gt;    \n 8     8 Pulp Fiction                                 Quentin… Roger A… &lt;NA&gt;    \n 9     9 Lord of the Rings: The Fellowship of the Ri… J.R.R. … Fran Wa… Philipp…\n10    10 The Good, the Bad and the Ugly               Luciano… Sergio … Agenore…\n\n\nProblem se rješava pomoću funkcije pivot_longer() uz dodatne argumente koji olakšavaju rad s nazivima stupaca koji imaju zajednički prefiks. Argument cols = starts_with(\"writer_\") specificira da se produže svi stupci koji počinju s “writer_”, dok argument names_prefix = \"writer_\" uklanja prefiks iz naziva stupaca prije pohranjivanja u novu varijablu. Argument names_to = \"writer_id\" stvara novu varijablu koja označava redni broj scenarista, a values_to = \"writer\" stvara varijablu koja sadrži imena scenarista. Argument values_drop_na = TRUE uklanja redove s nedostajućim vrijednostima koji nastaju zbog nejednakog broja scenarista po filmovima.\n\n# Uređivanje podatkovnog okvira\nwriters_dataset_tidy &lt;- writers_dataset |&gt;\n  pivot_longer(\n    cols = starts_with(\"writer_\"),\n    names_to = \"writer_id\",\n    names_prefix = \"writer_\",\n    values_to = \"writer\",\n    values_drop_na = TRUE\n  )\n\nNakon primjene funkcije dobivamo uređeni podatkovni okvir koji sadrži četiri stupca: “rank”, “movie”, “writer_id” (redni broj scenarista) i “writer” (ime scenarista). Svaki red predstavlja kombinaciju film-scenarist što omogućuje jednostavno brojanje filmova po scenaristu, identifikaciju najproduktivnijih scenarista ili analizu suradnji između različitih scenarista. Uređeni format također olakšava spajanje s drugim podacima o scenaristima te stvaranje vizualizacija mreža suradnji, što bi bilo komplicirano ili nemoguće u neuredno organiziranom širom formatu s odvojenim stupcima za svakog scenarista.\n\n# Pregled urednog oblika podatkovnog okvira\nwriters_dataset_tidy\n\n# A tibble: 23 × 4\n    rank movie                    writer_id writer              \n   &lt;dbl&gt; &lt;chr&gt;                    &lt;chr&gt;     &lt;chr&gt;               \n 1     1 The Shawshank Redemption 1         Stephen King        \n 2     1 The Shawshank Redemption 2         Frank Darabont      \n 3     2 The Godfather            1         Mario Puzo          \n 4     2 The Godfather            2         Francis Ford Coppola\n 5     3 The Dark Knight          1         Jonathan Nolan      \n 6     3 The Dark Knight          2         Christopher Nolan   \n 7     3 The Dark Knight          3         David S. Goyer      \n 8     4 The Godfather Part II    1         Francis Ford Coppola\n 9     4 The Godfather Part II    2         Mario Puzo          \n10     5 12 Angry Men             1         Reginald Rose       \n# ℹ 13 more rows\n\n\n\n\n\n5. Više vrijednosti u jednoj ćeliji\nOvaj oblik neurednih podataka predstavlja pojednostavljenu verziju prethodnog problema gdje se u jednoj ćeliji nalaze vrijednosti koje pripadaju različitim varijablama, odvojene određenim separatorom. Problem nastaje kada se dvije logički različite varijable kombiniraju u jednu kolonu radi uštede prostora ili zbog ograničenja u sustavima za pohranu podataka. Ovakva organizacija krši temeljna načela urednih podataka jer svaka ćelija treba sadržavati vrijednost samo jedne varijable. Kombiniranje različitih tipova informacija u istoj ćeliji otežava sve oblike analize jer je potrebno najprije izdvojiti pojedinačne komponente prije bilo kakve obrade podataka.\n\n\n\n\n\n\nTipFunkcija: separate()\n\n\n\n\n\nseparate() je ključna funkcija tidyr paketa koja se koristi kada imamo više varijabli spremljenih u jednoj ćeliji, a želimo ih razdvojiti u više stupaca. Funkcija može imati slijedeće argumente:\n\n\n\n\n\n\n\nArgument\nObjašnjenje\n\n\n\n\ndata\nPodatkovni okvir kojem mijenjamo format.\n\n\ncol\nNaziv stupca koji želimo razdvojiti.\n\n\ninto\nImena novih stupaca u koje želimo rasporediti rezultate.\n\n\nsep\nKako razdvajamo vrijednosti u stupcu (npr. “_“,”-“).\n\n\nremove\nAko je TRUE (zadano), onda se originalni stupac briše nakon razdvajanja, a ako je FALSE, onda originalni stupac ostaje u tablici zajedno s novim stupcima.\n\n\nconvert\nAko je TRUE, onda pokušava automatski pretvoriti nove stupce u odgovarajući tip podataka (npr. “1994” u integer), a ako je FALSE, koji je i zadani, onda će svi novi stupci biti character.\n\n\nextra\nŠto napraviti ako se vrijednost razdvoji na više dijelova nego što smo naveli u into. Može biti: warn (zadano) koje izdaje upozorenje i spaja višak u zadnji stupac, drop koje odbacuje višak i merge koje spaja višak u zadnji stupac bez upozorenja.\n\n\nfill\nŠto napraviti ako se vrijednost razdvoji na manje dijelova nego što smo naveli u into. Može biti: warn (zadano) koje izdaje upozorenje, a prazna mjesta popunjava s NA, right kojim se praznine dodaju na kraj i left kojim se praznine dodaju na početak.\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nU primjeru imdb_combined_variables, stupac “director_budget” sadrži kombinaciju imena redatelja i budžeta filma odvojena podvlakom. Na primjer, vrijednost “Frank Darabont_25000000” predstavlja dva različita podatka: ime redatelja “Frank Darabont” i budžet filma od 25 milijuna dolara. Stupci “rank” i “movie” već su u ispravnom formatu jer sadrže samo jednu vrstu informacije po ćeliji.\n\n# Pregled neurednog oblika podatkovnog okvira\nimdb_combined_variables\n\n# A tibble: 10 × 3\n    rank movie                                         director_budget          \n   &lt;dbl&gt; &lt;chr&gt;                                         &lt;chr&gt;                    \n 1     1 The Shawshank Redemption                      Frank Darabont_25000000  \n 2     2 The Godfather                                 Francis Ford Coppola_600…\n 3     3 The Dark Knight                               Christopher Nolan_185000…\n 4     4 The Godfather Part II                         Francis Ford Coppola_130…\n 5     5 12 Angry Men                                  Sidney Lumet_350000      \n 6     6 The Lord of the Rings: Return of the King     Peter Jackson_94000000   \n 7     7 Schindler's List                              Steven Spielberg_22000000\n 8     8 Pulp Fiction                                  Quentin Tarantino_8000000\n 9     9 Lord of the Rings: The Fellowship of the Ring Peter Jackson_93000000   \n10    10 The Good, the Bad and the Ugly                Sergio Leone_1200000     \n\n\nProblem se rješava pomoću funkcije separate() koja omogućuje dijeljenje jednog stupca u dva ili više stupaca na temelju određenog separatora. Funkcija koristi argument col = director_budget za specificiranje stupca koji se želi podijeliti, into = c(\"director\", \"budget\") za definiranje naziva novih stupaca koji će nastati dijeljenjem i sep = \"_\" za navođenje separatora koji razdvaja različite vrijednosti. Funkcija separate() automatski prepoznaje poziciju separatora u svakoj ćeliji i dijeli sadržaj na odgovarajući način, stvarajući dva nova stupca s jasno odvojenima informacijama.\n\n# Uređivanje podatkovnog okvira\nimdb_combined_variables_tidy &lt;- imdb_combined_variables |&gt;\n  separate(\n    col = director_budget,\n    into = c(\"director\", \"budget\"),\n    sep = \"_\"\n  )\n\nNakon primjene separate() funkcije dobivamo uređeni podatkovni okvir koji sadrži četiri stupca: “rank”, “movie”, “director” i “budget”. Svaki red predstavlja jedan film s jasno odvojenima karakteristikama, pri čemu svaki stupac sadrži samo jedan tip informacije.\n\n# Pregled urednog oblika podatkovnog okvira\nimdb_combined_variables_tidy\n\n# A tibble: 10 × 4\n    rank movie                                         director           budget\n   &lt;dbl&gt; &lt;chr&gt;                                         &lt;chr&gt;              &lt;chr&gt; \n 1     1 The Shawshank Redemption                      Frank Darabont     25000…\n 2     2 The Godfather                                 Francis Ford Copp… 60000…\n 3     3 The Dark Knight                               Christopher Nolan  18500…\n 4     4 The Godfather Part II                         Francis Ford Copp… 13000…\n 5     5 12 Angry Men                                  Sidney Lumet       350000\n 6     6 The Lord of the Rings: Return of the King     Peter Jackson      94000…\n 7     7 Schindler's List                              Steven Spielberg   22000…\n 8     8 Pulp Fiction                                  Quentin Tarantino  80000…\n 9     9 Lord of the Rings: The Fellowship of the Ring Peter Jackson      93000…\n10    10 The Good, the Bad and the Ugly                Sergio Leone       12000…\n\n\n\n\n\n6. Ista varijabla raspodijeljena u sva stupca\nOvaj oblik neurednih podataka nastaje kada se logički jedna varijabla nepotrebno dijeli u više stupaca. Problem se javlja kada se podaci organiziraju prema komponentama varijable umjesto prema samoj varijabli kao cjelini. Iako ovakva organizacija može biti korisna u specifičnim slučajevima kada trebamo raditi s pojedinim komponentama, češće otežava analizu jer zahtijeva kombiniranje informacija iz više stupaca za dobivanje potpune vrijednosti varijable.\n\n\n\n\n\n\nTipFunkcija: unite()\n\n\n\n\n\nFunkcija unite() dio je tidyr paketa i koristi se za spajanje više stupaca u jedan stupac u podatkovnom okviru. Ovo je suprotna operacija od separate() funkcije. Funkcija može imati slijedeće argumente:\n\n\n\n\n\n\n\nArgument\nObjašnjenje\n\n\n\n\ndata\nPodatkovni okvir na kojem se izvršava operacija spajanja stupaca.\n\n\ncol\nNaziv novog stupca koji će nastati spajanjem postojećih stupaca. Može se navesti kao string (u navodnicima) ili kao simbol (bez navodnika).\n\n\n...\nStupci koji se žele spojiti.\n\n\nsep\nSeparator koji se umeće između vrijednosti prilikom spajanja.\n\n\nremove\nLogička vrijednost koja određuje treba li ukloniti originalne stupce iz rezultata. Zadana vrijednost je TRUE što znači da se originalni stupci brišu nakon spajanja. Ako postavite FALSE, zadržat ćete i originalne i novi spojeni stupac.\n\n\nna.rm\nLogička vrijednost koja određuje treba li ukloniti nedostajuće vrijednosti (NA) prije spajanja. Ako je TRUE, NA vrijednosti se ignoriraju prilikom spajanja. Zadana vrijednost je FALSE.\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nU primjeru director_names_dataset informacija o imenu redatelja podijeljena je u dva odvojena stupca, “director_first_name” koji sadrži ime i “director_last_name” koji sadrži prezime redatelja. Na primjer, za film “The Shawshank Redemption”, ime redatelja “Frank Darabont” podijeljeno je na “Frank” u prvom stupcu i “Darabont” u drugom stupcu.\n\n# Pregled neurednog oblika podatkovnog okvira\ndirector_names_dataset\n\n# A tibble: 10 × 4\n    rank movie                            director_first_name director_last_name\n   &lt;dbl&gt; &lt;chr&gt;                            &lt;chr&gt;               &lt;chr&gt;             \n 1     1 The Shawshank Redemption         Frank               Darabont          \n 2     2 The Godfather                    Francis Ford        Coppola           \n 3     3 The Dark Knight                  Christopher         Nolan             \n 4     4 The Godfather Part II            Francis Ford        Coppola           \n 5     5 12 Angry Men                     Sidney              Lumet             \n 6     6 The Lord of the Rings: Return o… Peter               Jackson           \n 7     7 Schindler's List                 Steven              Spielberg         \n 8     8 Pulp Fiction                     Quentin             Tarantino         \n 9     9 Lord of the Rings: The Fellowsh… Peter               Jackson           \n10    10 The Good, the Bad and the Ugly   Sergio              Leone             \n\n\nProblem se rješava pomoću funkcije unite() omogućuje spajanje više stupaca u jedan stupac. Funkcija koristi argument col = \"director_name\" za specificiranje naziva novog stupca, zatim navodi nazive stupaca koji se žele spojiti (“director_first_name”, “director_last_name”), te argument sep = \" \" koji definira separator koji će se umetnuti između spojenih vrijednosti. Funkcija unite() automatski kombinira vrijednosti iz specificiranih stupaca redoslijedom kojim su navedeni, stvarajući jednu koherentnu varijablu koja predstavlja punu informaciju.\n\n# Uređivanje podatkovnog okvira\ndirector_names_dataset_tidy &lt;- director_names_dataset |&gt;\n  unite(\n    col = \"director_name\",\n    director_first_name,\n    director_last_name,\n    sep = \" \"\n  )\n\nNakon primjene funkcije dobivamo uređeni podatkovni okvir koji sadrži četiri stupca: “rank”, “movie” i novi “director_name” (puno ime redatelja). Svaki red predstavlja jedan film s kompletnim imenom redatelja u jednom stupcu što omogućuje jednostavno sortiranje filmova prema imenima redatelja, filtriranje prema specifičnim redateljima te spajanje s drugim izvorima podataka koji koriste puna imena.\n\n# Pregled urednog oblika podatkovnog okvira\ndirector_names_dataset_tidy\n\n# A tibble: 10 × 3\n    rank movie                                         director_name       \n   &lt;dbl&gt; &lt;chr&gt;                                         &lt;chr&gt;               \n 1     1 The Shawshank Redemption                      Frank Darabont      \n 2     2 The Godfather                                 Francis Ford Coppola\n 3     3 The Dark Knight                               Christopher Nolan   \n 4     4 The Godfather Part II                         Francis Ford Coppola\n 5     5 12 Angry Men                                  Sidney Lumet        \n 6     6 The Lord of the Rings: Return of the King     Peter Jackson       \n 7     7 Schindler's List                              Steven Spielberg    \n 8     8 Pulp Fiction                                  Quentin Tarantino   \n 9     9 Lord of the Rings: The Fellowship of the Ring Peter Jackson       \n10    10 The Good, the Bad and the Ugly                Sergio Leone",
    "crumbs": [
      "Uvoz i uređivanje podataka",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Uređivanje podataka</span>"
    ]
  },
  {
    "objectID": "03_00_transformacija_podataka.html",
    "href": "03_00_transformacija_podataka.html",
    "title": "Transformacija podataka",
    "section": "",
    "text": "ImportantPodaci korišteni u poglavlju\n\n\n\n\n\nU svrhu ilustracije svih postupaka transformacije podataka u ovom poglavlju koristit će se skup podataka Pokemon with stats autora Alberta Barradasa, objavljen na platformi Kaggle 2016. godine. Ovaj skup podataka sadrži informacije o 721 Pokemonu, uključujući njihove detaljne statistike i vrste. Podaci su kvalitetan primjer za demonstraciju različitih tehnika transformacije podataka dplyr paketom, a u nastavku će poglavlja svi primjeri transformacije podataka biti će temeljeni isključivo na ovom skupu podataka.\nPodaci su spremljeni u podatkovnom okvirupokemon_dataset koji sadrži 271 Pokemona i 13 varijabli:\n\n“id” - redni broj i jedinstveni identifikator svakog Pokemona (numerička varijabla),\n“name” - ime Pokemona (tekstualna varijabla),\n“type_1” - primarna vrsta Pokemona (faktor),\n“type_2” - sekundarna vrsta Pokemona (faktor),\n“total” - ukupan zbroj svih osnovnih statistika Pokemona (numerička varijabla),\n“HP” - životni koji označavaju količinu štete koju Pokemon može podnijeti prije nego bude poražen (numerička varijabla),\n“attack” - napadačka statistika (numerička varijabla),\n“defense” - obrambena statistika (numerička varijabla),\n“special_attack” - snaga posebnog napada (numerička varijabla),\n“special_defense” - snaga posebne obrane (numerička varijabla),\n“speed” - brzina Pokemona (numerička varijabla),\n“generation” - generacija u kojoj je Pokemon predstavljen (faktor),\n“legendary” - je li Pokemon legendaran (logička varijabla).\n\n\n\ntibble [800 × 13] (S3: tbl_df/tbl/data.frame)\n $ id             : num [1:800] 1 2 3 3 4 5 6 6 6 7 ...\n $ name           : chr [1:800] \"bulbasaur\" \"ivysaur\" \"venusaur\" \"venusaurmega venusaur\" ...\n $ type_1         : Factor w/ 18 levels \"water\",\"normal\",..: 3 3 3 3 6 6 6 6 6 1 ...\n $ type_2         : Factor w/ 18 levels \"flying\",\"ground\",..: 3 3 3 3 NA NA 1 10 1 NA ...\n $ total          : num [1:800] 318 405 525 625 309 405 534 634 634 314 ...\n $ HP             : num [1:800] 45 60 80 80 39 58 78 78 78 44 ...\n $ attack         : num [1:800] 49 62 82 100 52 64 84 130 104 48 ...\n $ defense        : num [1:800] 49 63 83 123 43 58 78 111 78 65 ...\n $ special_attack : num [1:800] 65 80 100 122 60 80 109 130 159 50 ...\n $ special_defense: num [1:800] 65 80 100 120 50 65 85 85 115 64 ...\n $ speed          : num [1:800] 45 60 80 80 65 80 100 100 100 43 ...\n $ generation     : Factor w/ 6 levels \"1\",\"5\",\"3\",\"4\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ legendary      : logi [1:800] FALSE FALSE FALSE FALSE FALSE FALSE ...\n\n\n\n\n\nTransformacija podataka (data transformation) predstavlja fazu u radu s podacima koja se odnosi na sveobuhvatan proces sistematskog mijenjanja, prestrukturiranja i preoblikovanja sirovih podataka u oblik koji je prikladniji za analizu, modeliranje i donošenje odluka. Transformacija podataka je proces pripreme podataka za vizualizaciju i tehnike statističke interpretacije.\nTransformacija označava skup tehnika i postupaka kojima se podatci organiziraju, mijenjaju i pripremaju za analizu. Riječ je o jednoj od najvažnijih faza u analitičkom procesu jer se stvarna korisnost podataka često otkriva tek nakon što se podaci temeljito transformiraju, odnosno kada se strukturiraju i prikažu na način koji odgovara svrsi analize. Transformacija podataka, dakle, označava izmjenu strukture, sadržaja ili organizacije podatkovnog skupa bez nužnog mijenjanja samih vrijednosti varijabli.\nTehnike transformacije podatakamogu se organizirati u nekoliko glavnih kategorija:\n1. Pridruživanje i kombiniranje podataka (Data Joining): Analiza podataka rijetko se oslanja na jedan izvor podataka, nego je često potrebno raditi s više podatkovnih okvira. Zato je jedan od temeljnih koraka u transformaciji kombiniranje bliskih podataka iz različitih izvora. Ovo uključuje različite vrste spajanja podatkovnih okvira, a koje omogućuju kombiniranje informacija na temelju zajedničkih ključeva.\n2. Manipulacija podataka (Data Manipulation): Manipulacija podataka obuhvaća osnovne operacije potrebne za upravljanje strukturom i sadržajem podatkovnih okvira. Paket dplyr predstavlja gramatiku za manipulaciju podataka pružajući konzistentan skup glagola koji pomažu u rješavanju najčešćih izazova manipulacije podataka. Osnovne operacije manipulacije uključuju rad s redovima i stupcima kao što su filtriranje opažanja na temelju određenih uvjeta, odabir specifičnih stupaca, sortiranje podataka, dodavanje novih varijabli i druge.\n3. Nedostajuće vrijednosti (Missing Values): Nedostajuće vrijednosti predstavljaju čest izazov i zahtijevaju pažljiv pristup u transformaciji. Pritom rad s nedostajućim vrijednostima uključuje prepoznavanje različitih oblika nedostajućih podataka i razumijevanje uzroka njihova nastanka te pravilno postupanje s njima ovisno o prirodi podataka, uzroku njihovog javljanja i željenoj analizi.\n4. Numerički podaci: Numerički podaci predstavljaju temelj kvantitativne analize i zahtijevaju specijalizirane tehnike transformacije za optimalno iskorištavanje u analizi. Numeričke transformacije uključuju različite tehnike rada s brojevima, od kojih su najvažnije: osnovne matematičke operacije (zbrajanje, oduzimanje, množenje i dijeljenje); statistička računanja (mjere centralne tendencije - prosjek, medijan i mod); mjere varijabilnosti (standardna devijacija, varijanca i raspon te kvantili i percentili); matematičke funkcije logaritma, eksponencijalnih funkcija, trigonometrijskih funkcija i potenciranja; zaokruživanje i formatiranje numeričkih podataka; konverzija numeričkih tipova između cijelih brojeva, decimalnih brojeva i drugih numeričkih formata.\n5. Logičke vrijednosti (Logical vectors): Logički vektori predstavljaju temeljni alat za filtriranje, uvjetno procesiranje i kreiranje binarnih varijabli u transformaciji podataka. One mogu poprimiti samo dvije vrijednosti, TRUE i FALSE, a koriste se za evaluaciju uvjeta i donošenje odluka o tome koji će se podaci obraditi ili transformirati. Logičke vrijednosti nastaju kao rezultat usporedbi pomoću operatora poput ==, !=, &gt;, &lt;, &gt;= i &lt;=.\n6. Faktori (Factors): Faktori predstavljaju specijalizirani tip podataka za rukovanje kategorijalnim vrijednostima. Riječ je o tekstualnim kategorijama koje mogu imati ograničen broj mogućnosti, primjerice proizvođača neke odjeće ili fakulteta na kojem studenti studiraju. Upravljanje kategorijskim podacima uključuje definiranje razina faktora, njihov redoslijed i označavanja, a što je ključno za pravilnu interpretaciju i analizu kategorijskih podataka.\n7. Nizovi (Strings): Nizovi znakova predstavljaju tekstualne podatke koji mogu uključivati nazive, opise, kategorije, adrese, datume u tekstualnom formatu i mnoge druge vrste informacija koje nisu numeričke prirode. Rad s nizovima znakova zahtijeva specijalizirane tehnike za njihovu manipulaciju, čišćenje i transformaciju kako bi podaci postali korisni za analizu. Osnovne operacije s nizovima uključuju spajanje tekstualnih vrijednosti, izdvajanje dijelova teksta, zamjenu određenih znakova ili riječi, promjenu velikih i malih slova, te uklanjanje nepotrebnih razmaka. Ove operacije često su neophodne jer sirovi tekstualni podaci dolaze u nekonzistentnim formatima s tipografskim greškama ili dodatnim znakovima koji otežavaju analizu.\n8. Regularni izrazi (Regular expressions): Regularni izrazi su alat za prepoznavanje i manipulaciju složenih uzoraka u tekstualnim podacima. Oni koriste specijalne znakove i simbole za opisivanje uzoraka u tekstu, a mogu se koristiti za pronalaženje, primjerice, svih email adresa u tekstu, izdvajanje brojeva telefona ili identifikaciju svih riječi koje počinju velikim slovom. Osnovna sintaksa regularnih izraza uključuje simbole poput točke (.) koja predstavlja bilo koji znak, zvjezdice (*) koja označava ponavljanje, plus znaka (+) za jedno ili više ponavljanja te uglate zagrade ([]) za definiranje skupa dozvoljenih znakova.\n9. Datum i vrijeme: Temporalni podaci zahtijevaju specijalizirane tehnike transformacije zbog složenosti vremenskih formata i računanja. Rad s takvim podacima uključuje pretvaranje tekstualnih reprezentacija datuma iz različitih formata u standardne tipove podataka koji omogućuju temporalne kalkulacije. Temporalna računanja omogućuju izračunavanje razlika između datuma, dodavanje ili oduzimanje vremenskih perioda, te ekstraktiranje komponenti datuma poput godine, mjeseca ili dana u tjednu.",
    "crumbs": [
      "Transformacija podataka"
    ]
  },
  {
    "objectID": "03_01_manipulacija_podacima.html",
    "href": "03_01_manipulacija_podacima.html",
    "title": "4  Manipulacija podacima",
    "section": "",
    "text": "1 Manipulacija podacima u užem smislu\nManipulacija podataka (data manipulation) predstavlja skup operacija koje pomažu u rješavanju najčešćih izazova pri radu s podacima. Obuhvaća različite aktivnosti poput kreiranja novih varijabli ili sažetaka kako bi se odgovorilo na pitanja postavljena nad podacima, preimenovalo varijable ili promijenio redoslijed opažanja kako bi se podaci učinili lakšima za rad.\nU kontekstu dplyr paketa, manipulacija podataka provodi se kroz dosljedno organiziran skup glagola koji omogućavaju izvođenje specifičnih operacija nad podacima. Ove operacije uključuju rad s retcima i stupcima podatkovnog okvira kao i mogućnost rada s grupama podataka.\nManipulacija zapravo predstavlja proces preoblikovanja sirovih podataka u oblik koji je prikladan za analizu što može uključivati filtriranje nepotrebnih podataka, sortiranje, izračunavanje novih varijabli, agregiranje vrijednosti po grupama, spajanje podataka iz različitih izvora i slične operacije.\nGlagoli dplyr paketa mogu se podijeliti u nekoliko skupina s obzirom na ulogu glagola u transformaciji:\nFiltriranje specifičnih varijabli\nJedan od ključnih koraka u manipulaciji podataka odnosi se na odabir određenih varijabli iz podataka. U različitim situacijama pojedine varijable podatkovnog okvira mogu biti nepotrebne i ometajuće. Takvo se filtriranje koristi kada želimo raditi isključivo s podskupom varijabli iz originalnog podatkovnog okvira zbog jednostavnije analize, smanjenja memorijske potrošnje ili boljeg pregleda.\nFiltriranje specifičnih opažanja\nAnaliza podataka često zahtijeva fokusiranje na određeni podniz opažanja koji zadovoljavaju specifične uvjete. Iduća manipulacija zato ima ulogu filtriranja pojedinih opažanja podatkovnog okvira na temelju određenih uvjeta. Ovaj pristup omogućuje usredotočavanje na relevantne podatke, uklanjanje outliera ili analizu određenih kategorija podataka. Filtriranje redova ključno je za ciljanu analizu specifičnih skupina ili uvjeta unutar većeg skupa podataka.\nSortitanje opažanja\nSortiranje podatkovnog okvira s obzirom na neke karakteristike još je jedan od segmenata manipulacije podacima. U većini slučajeva koristi se u sortiranju numeričkih vrijednosti koje se redaju ili od najmanje do najveće ili od najveće do najmanje karakteristike. Osim toga, ono može uključivati i redanje podataka abecednim redom ako se radi o tekstualnim podacima.\nPromjena, kreiranje i brisanje varijabli\nPosljednji segment manipulacije podacima u užem smislu je rad na sadržaju varijabli podatkovnog okvira. Konkretnije, to uključuje mijenjanje sadržaja pojedinih varijabli i dodavanje nove varijable sa specifičnim sadržajem. Rad na pojedinim varijablama uglavnom se svodi na rad s numeričkim varijablama, a uključuje modificiranje brojčanih sadržaja jedna varijable (npr. promjene valute pojedine varijable) ili stvaranje novih varijabli na temelju drugih (npr. dodavanje specifičnih varijabli s različitim drugim varijablama).",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulacija podacima</span>"
    ]
  },
  {
    "objectID": "03_01_manipulacija_podacima.html#manipulacija-podacima-u-užem-smislu",
    "href": "03_01_manipulacija_podacima.html#manipulacija-podacima-u-užem-smislu",
    "title": "4  Manipulacija podacima",
    "section": "",
    "text": "TipGlagol select()\n\n\n\n\n\nGlagol select() odabire određene varijable u podatkovnom okviru koristeći koncizan jezik koji olakšava pozivanje varijabli na temelju njihovog imena (npr. name:type_1 čime se odabiru svi stupci od “name” do “type_1”) ili tipa (npr. where(is.numeric) koji odabire odabire sve numeričke stupce).\nNa glagol select() mogu se nadovezivati druge funkcije:\n\ncontains() - ispisuje samo varijable koje sadrže određene znakove,\nstarts_with() - ispisuje samo varijable koje počinju nekom riječju,\nends_with() - ispisuje samo varijable koje završavaju nekom riječju,\nlast_col() - ispisuje samo zadnji stupac i\nmatches() - odabire stupce koji imaju određeni uzorak.\n\nKoristan dodatak glagolu select() je znak - (minus) kojim se može izolirati određena varijabla. U slučaju da želimo filtrirati ispis samo pojedinih varijabli, a ako je njihov broj veći, jednostavnije je samo izbrisati neku varijablu nego ju neimenovati unutar glagola.\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nRecimo da nam su nam u analizi potrebne samo varijable “name”, “type_1”, “type_2”, “generation” i “legendary”. Te varijable možemo filtrirati glagolom select() na različite načine.\nPrvi je način izrazom name:type_2 koji odabire sve stupce između varijable “name” i “type_2” uključivo. Uz to, za stupce “generation” i “legendary” potrebno je eksplicitno dodati naziv varijable.\n\n# Izdvajanje pojedinih varijabli podatkovnog okvira\npokemon_dataset |&gt; select(name:type_2, generation, legendary)\n\n# A tibble: 800 × 5\n   name                      type_1 type_2 generation legendary\n   &lt;chr&gt;                     &lt;fct&gt;  &lt;fct&gt;  &lt;fct&gt;      &lt;lgl&gt;    \n 1 bulbasaur                 grass  poison 1          FALSE    \n 2 ivysaur                   grass  poison 1          FALSE    \n 3 venusaur                  grass  poison 1          FALSE    \n 4 venusaurmega venusaur     grass  poison 1          FALSE    \n 5 charmander                fire   &lt;NA&gt;   1          FALSE    \n 6 charmeleon                fire   &lt;NA&gt;   1          FALSE    \n 7 charizard                 fire   flying 1          FALSE    \n 8 charizardmega charizard x fire   dragon 1          FALSE    \n 9 charizardmega charizard y fire   flying 1          FALSE    \n10 squirtle                  water  &lt;NA&gt;   1          FALSE    \n# ℹ 790 more rows\n\n\nU drugom slučaju, recimo da možemo varijablu “name” eksplicitno imenovati, varijable “type_1” i “type_2” odabrati funkcijom starts_with(\"type\") kojom se odabire ispis svih varijabli čiji naziv počinje s riječju “type”, a funkcija last_col() odabire posljednji stupac u podatkovnom okviru bez obzira na naziv te varijable.\n\n# Izdvajanje pojedinih varijabli podatkovnog okvira\npokemon_dataset |&gt; select(name, starts_with(\"type\"), last_col())\n\n# A tibble: 800 × 4\n   name                      type_1 type_2 legendary\n   &lt;chr&gt;                     &lt;fct&gt;  &lt;fct&gt;  &lt;lgl&gt;    \n 1 bulbasaur                 grass  poison FALSE    \n 2 ivysaur                   grass  poison FALSE    \n 3 venusaur                  grass  poison FALSE    \n 4 venusaurmega venusaur     grass  poison FALSE    \n 5 charmander                fire   &lt;NA&gt;   FALSE    \n 6 charmeleon                fire   &lt;NA&gt;   FALSE    \n 7 charizard                 fire   flying FALSE    \n 8 charizardmega charizard x fire   dragon FALSE    \n 9 charizardmega charizard y fire   flying FALSE    \n10 squirtle                  water  &lt;NA&gt;   FALSE    \n# ℹ 790 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipGlagol filter()\n\n\n\n\n\nGlagol filter() koristi se za odabir opažanja podatkovnog okvira podataka zadržavajući redove koji zadovoljavaju postavljene uvjete. Prvi argument funkcije je podatkovni okvir, a sljedeći argumenti su logički uvjeti koji se evaluiraju na bilo kojim uključenim stupcima. Mogu se koristiti operatori: &gt; (veće od), &gt;= (veće ili jednako), &lt; (manje od), &lt;= (manje ili jednako), == (jednako) i != (nije jednako). Također se mogu kombinirati uvjeti s & za označavanje “i” ili s | za označavanje “ili”. Kako bi se zadržao, redak mora dati vrijednost TRUE za sve postavljene uvjete.\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nRecimo da se želimo fokusirati samo na određeni dio populacije Pokemona. Pritom nas zanimaju samo legendarni Pokemoni prve generacije. Takve je Pokemone moguće odabrati glagolom filter() u kojem su specifični kriteriji za odabir Pokemona formulirani logičkim operatorima.\n\n# Izdvajanje pojedinih opažanja\npokemon_dataset |&gt; filter(generation == 1, legendary != FALSE)\n\n# A tibble: 6 × 13\n     id name             type_1 type_2 total    HP attack defense special_attack\n  &lt;dbl&gt; &lt;chr&gt;            &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n1   144 articuno         ice    flying   580    90     85     100             95\n2   145 zapdos           elect… flying   580    90     90      85            125\n3   146 moltres          fire   flying   580    90    100      90            125\n4   150 mewtwo           psych… &lt;NA&gt;     680   106    110      90            154\n5   150 mewtwomega mewt… psych… fight…   780   106    190     100            154\n6   150 mewtwomega mewt… psych… &lt;NA&gt;     780   106    150      70            194\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;\n\n\nOsim toga, mogu nas zanimati samo vatreni Pokemoni koji imaju više od 100 životnih bodova te samo pojedine varijable tih Pokemona. Za to je potrebno kombinirati dva glagola, filter() za filtriranje opažanja i select() za filtriranje varijabli kako bismo dobili podatkovni okvir u kojem se nalaze samo potrebni segmenti polaznog podatkovnog okvira.\n\n# Kombinacija izdvajanja varijabli i opažanja\npokemon_dataset |&gt;\n  filter(HP &gt;= 100, type_1 == \"water\") |&gt;\n  select(name, starts_with(\"type\"), HP)\n\n# A tibble: 18 × 4\n   name                  type_1 type_2      HP\n   &lt;chr&gt;                 &lt;fct&gt;  &lt;fct&gt;    &lt;dbl&gt;\n 1 lapras                water  ice        130\n 2 vaporeon              water  &lt;NA&gt;       130\n 3 lanturn               water  electric   125\n 4 azumarill             water  fairy      100\n 5 suicune               water  &lt;NA&gt;       100\n 6 swampert              water  ground     100\n 7 swampertmega swampert water  ground     100\n 8 wailmer               water  &lt;NA&gt;       130\n 9 wailord               water  &lt;NA&gt;       170\n10 whiscash              water  ground     110\n11 relicanth             water  rock       100\n12 kyogre                water  &lt;NA&gt;       100\n13 kyogreprimal kyogre   water  &lt;NA&gt;       100\n14 gastrodon             water  ground     111\n15 manaphy               water  &lt;NA&gt;       100\n16 seismitoad            water  ground     105\n17 jellicent             water  ghost      100\n18 alomomola             water  &lt;NA&gt;       165\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipGlagol arrange()\n\n\n\n\n\nGlagol arrange() sortira opažanja podatkovnog okvira prema vrijednostima odabranih stupaca. dplyr automatski reda podatke od najmanjih do najvećih, a želimo li da se podaci redaju od najvećih do najmanjih, u glagol treba dodati funkciju desc(). U slučaju kada se redaju kvalitativni podaci, oni se redaju abecednim redom od A do Z ili uz korištenje funkcije desc() od Z do A.\nZa razliku od drugih dplyr glagola, arrange() uglavnom ignorira grupiranje pa je potrebno eksplicitno spomenuti varijable koje se grupiraju ili koristiti .by_group = TRUE da bi se varijable grupirale po njima.\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nRecimo da nas zanima top 10 vodenih pokemona prema ukupnom zbroj svih osnovnih statistika Pokemona. Za takvu manipulaciju koristimo nekoliko glagola. Prvi je filter() kojim odabiremo samo vodene Pokemone iz podatkovnog okvira, a zatim koristimo arrange() s funkcijom desc() kako bismo filtrirane Pokemone poredali od onih koji imaju najveći ukupan zbroj statistika do onih s najmanjim. Konačno, možemo koristiti glagol select() za odabir samo relevantnih varijabli.\n\n# Filtriranje vodenih pokemona i redanje ukupne statistike sposobnosti pokemona od najvećih do najnižih\npokemon_dataset |&gt;\n  filter(type_1 == \"water\") |&gt;\n  arrange(desc(total)) |&gt;\n  select(name, total)\n\n# A tibble: 112 × 2\n   name                    total\n   &lt;chr&gt;                   &lt;dbl&gt;\n 1 kyogreprimal kyogre       770\n 2 palkia                    680\n 3 kyogre                    670\n 4 gyaradosmega gyarados     640\n 5 swampertmega swampert     635\n 6 blastoisemega blastoise   630\n 7 manaphy                   600\n 8 slowbromega slowbro       590\n 9 suicune                   580\n10 keldeoordinary forme      580\n# ℹ 102 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipGlagol mutate()\n\n\n\n\n\nGlagol mutate() koristi se u tri slučaja:\n\nkada želimo promijeniti jednu od varijabli u skupu varijabli,\nkada želimo dodati novu varijablu ili\nkada želimo brisati stupce.\n\nMutiranje se izvodi s obzirom na slučaj za koji koristimo glagol, no pravilo zajedničko za sva tri slučaja je da se u glagolu prvo navodi naziv varijable, znak jednakosti i pravilo za promjenu ili stvaranje nove varijable. R prema nazivu automatski prepoznaje je li potrebno ažurirati postojeću varijablu ako je ime jednako već postoječoj varijabli ili stvoriti novu ako je naziv varijable drugačiji od bilo koje postojeće varijable. S obzirom da se mutate() najčešće koristi s numeričkim podacima, pravila za modificiranje ili stvaranje nove varijable uglavnom se sastoje od matematičkih operacija ili drugih funkcija koje formiraju varijablu od interesa. Ako želimo obrisati neku varijablu, onda iza znaka jednakosti koristimo NULL.\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nRecimo da želimo ažurirati postojeću varijablu “generation” u podatkovnom okviru pokemon_dataset. Konkretnije, umjesto da je generacija Pokemona izražena brojčanom vrijednošću, želimo da tekstualno piše kojoj generaciji Pokemona pripada svaki pojedini Pokemon. To možemo napraviti glagolom mutate() u koju se umeće funkcija case_when() kojom je moguće modificirati sadržaj varijable.\n\npokemon_dataset |&gt;\n  mutate(\n    generation = case_when(\n      generation == 1 ~ \"Prva generacija\",\n      generation == 2 ~ \"Druga generacija\",\n      generation == 3 ~ \"Treća generacija\",\n      generation == 4 ~ \"Četvrta generacija\",\n      generation == 5 ~ \"Peta generacija\",\n      generation == 6 ~ \"Šesta generacija\",\n      generation == 7 ~ \"Sedma generacija\",\n      generation == 8 ~ \"Osma generacija\",\n      TRUE ~ as.character(generation)\n    )\n  ) |&gt;\n  select(name, generation)\n\n# A tibble: 800 × 2\n   name                      generation     \n   &lt;chr&gt;                     &lt;chr&gt;          \n 1 bulbasaur                 Prva generacija\n 2 ivysaur                   Prva generacija\n 3 venusaur                  Prva generacija\n 4 venusaurmega venusaur     Prva generacija\n 5 charmander                Prva generacija\n 6 charmeleon                Prva generacija\n 7 charizard                 Prva generacija\n 8 charizardmega charizard x Prva generacija\n 9 charizardmega charizard y Prva generacija\n10 squirtle                  Prva generacija\n# ℹ 790 more rows\n\n\nU drugom slučaju podatkovnom okviru želimo dodati nove varijable. Prva je “total_stats” u kojoj će biti zbrojene sve statističke vrijednosti o Pokemonima u podatkovnom okviru. Takva se varijabla može kreirati jednostavnim zbrajanjem vrijednosti drugih varijabli. Druga varijabla koju želimo dodati je “attack_defense_ratio” u kojoj će biti naveden omjer između napadačke i obrambene vrijednosti. Posljednja varijabla koju možemo dodati je “hp_category” u kojem će biti navedena kategorija HP vrijednosti svakog Pokemona funkcijom case_when() u koju se unose pravila kategoriziranja Pokemona s obzirom na HP vrijednosti.\n\npokemon_dataset |&gt;\n  mutate(\n    # Izračun ukupne statistike\n    total_stats = attack + defense + HP + speed + special_attack + special_defense,\n    # Omjer napada i obrane\n    attack_defense_ratio = attack / defense,\n    # Kategorija na temelju HP-a\n    hp_category = case_when(\n      HP &lt; 50 ~ \"Low HP\",\n      HP &lt; 80 ~ \"Medium HP\",\n      TRUE ~ \"High HP\"\n    )\n  ) |&gt;\n  select(name, total_stats, attack_defense_ratio, hp_category)\n\n# A tibble: 800 × 4\n   name                      total_stats attack_defense_ratio hp_category\n   &lt;chr&gt;                           &lt;dbl&gt;                &lt;dbl&gt; &lt;chr&gt;      \n 1 bulbasaur                         318                1     Low HP     \n 2 ivysaur                           405                0.984 Medium HP  \n 3 venusaur                          525                0.988 High HP    \n 4 venusaurmega venusaur             625                0.813 High HP    \n 5 charmander                        309                1.21  Low HP     \n 6 charmeleon                        405                1.10  Medium HP  \n 7 charizard                         534                1.08  Medium HP  \n 8 charizardmega charizard x         634                1.17  Medium HP  \n 9 charizardmega charizard y         634                1.33  Medium HP  \n10 squirtle                          314                0.738 Low HP     \n# ℹ 790 more rows\n\n\nKonačno, u posljednjem slučaju želimo trajno izbrisati sve varijable osim “id”, “name”, “type_1” i “total”. To se može postići funkcijom across() i logičkim operatorima kojima se definiralo koje varijable želimo izbrisati.\n\npokemon_dataset |&gt; mutate(across(type_2 | HP:legendary, ~NULL))\n\n# A tibble: 800 × 4\n      id name                      type_1 total\n   &lt;dbl&gt; &lt;chr&gt;                     &lt;fct&gt;  &lt;dbl&gt;\n 1     1 bulbasaur                 grass    318\n 2     2 ivysaur                   grass    405\n 3     3 venusaur                  grass    525\n 4     3 venusaurmega venusaur     grass    625\n 5     4 charmander                fire     309\n 6     5 charmeleon                fire     405\n 7     6 charizard                 fire     534\n 8     6 charizardmega charizard x fire     634\n 9     6 charizardmega charizard y fire     634\n10     7 squirtle                  water    314\n# ℹ 790 more rows",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulacija podacima</span>"
    ]
  },
  {
    "objectID": "03_01_manipulacija_podacima.html#glagoli-za-objedinjavanje-podataka",
    "href": "03_01_manipulacija_podacima.html#glagoli-za-objedinjavanje-podataka",
    "title": "4  Manipulacija podacima",
    "section": "2 Glagoli za objedinjavanje podataka",
    "text": "2 Glagoli za objedinjavanje podataka\nBrojanje pojavljivanja\nKvantifikacija učestalosti različitih kategorija ili kombinacija varijabli temeljna je za razumijevanje distribucije podataka. Zato brojanje omogućuje brzu identifikaciju najčešćih vrijednosti, analizu kategorijskih podataka i osnovnu deskriptivnu statistiku.\n\n\n\n\n\n\nTipGlagol count()\n\n\n\n\n\nGlagol count() broji ukupan broj opservacija koje zadovoljavaju određene uvjete ili su grupirani prema određenim vrijednostima. On pojednostavljuje izračunavanje učestalosti pojavljivanja različitih vrijednosti unutar jednog ili više stupaca. S argumentom sort = TRUE mogu se poredati u silaznom redoslijed broja pojavljivanja.\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nPrimjer korištenja glagola count() bio bi kada bismo htjeli prebrojiti broj legendarnih i nelegendarnih Pokemona iz svakog tipa pokemona prema varijabli “type_1”. Konačni ispis prikazat će svaki tip Pokemona u prvom stupcu i TRUE ili FALSE vrijednosti u drugom stupcu koji potvrđuje je li Pokemon ili nije legendarni. Posljednji stupac definira koliko je legendarnih ili nelegendarnih Pokemona toga tipa podataka.\n\n# Brojanje pokemona prema tipu 1 i legendarnosti\npokemon_dataset |&gt; count(type_1, legendary)\n\n# A tibble: 33 × 3\n   type_1  legendary     n\n   &lt;fct&gt;   &lt;lgl&gt;     &lt;int&gt;\n 1 water   FALSE       108\n 2 water   TRUE          4\n 3 normal  FALSE        96\n 4 normal  TRUE          2\n 5 grass   FALSE        67\n 6 grass   TRUE          3\n 7 bug     FALSE        69\n 8 psychic FALSE        43\n 9 psychic TRUE         14\n10 fire    FALSE        47\n# ℹ 23 more rows\n\n\n\n\n\nSažimanje podataka\nBitan segment manipulacije podacima je i iskazivanje agregiranih informacija o podacima. Time manipulacija podacima ulazi i u područje statističke analize podataka. Agregacija podataka u sažete statistike omogućuje izvlačenje ključnih uvida iz velikih količina podataka. Najvažnija grupirana operacija je sažetak koji, ako se koristi za izračun jedne sažete statistike, reducira podatkovni okvir na jedan red za svaku grupu. Takvo sažimanje transformira detaljne podatke u korisne mjere centralne tendencije, varijabilnosti i drugih statističkih karakteristika.\n\n\n\n\n\n\nTipGlagol summarise()\n\n\n\n\n\nGlagol summarise() koristi se za sažimanje vrijednosti u jednu željenu kategoriju. Kada se koristi sam, glagol sažima podatkovni okvir u jedan red koji prikazuje jedan oblik sumiranja. Pritom su za taj glagol važne neke funkcije elementarnog R-a za sažimanje vrijednosti kao što su:\n\nmean() - računa aritmetičku sredinu,\nmedian() - računa medijalnu vrijednosti,\nsum() - zbraja vrijednosti,\nmax() - izražava najveću vrijednost u nizu,\nmin() - izražava najmanju vrijednost u nizu i\nn() - izražava veličinu grupe.\n\nGlagol se koristi slično kao i mutate pri čemu se ispred znaka jednakosti definira naziv sumirajuće varijable, a nakon znaka jednakosti funkcija sumiranja. Razlika je samo u ispisu - mutate() primjenjuje modificirane vrijednosti na sva opažanja stvarajući u podatkovnom okviru izmjenjenu ili novu varijablu čime se svakom opažanju dodaje izmjenjena ili nova vrijednost, a summarise() ispisuje samo jedno opažanje i to je ono sumirajuće.\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nRecimo da nas zanimaju vrijednosti deskriptivne statistike varijable “HP” za opažanja svih Pokemona pokemon_dataset podatkovnog okvira.\n\n# Izračun aritmetičke sredine i medinana HP-a pokemona, ispis najvećeg i najmanjeg HP-a te zbroj svih HP-ova pokemona\npokemon_dataset |&gt;\n  summarise(\n    mean_HP = mean(HP),\n    median_HP = median(HP),\n    max_HP = max(HP),\n    min_HP = min(HP),\n    sum_HP = sum(HP)\n  )\n\n# A tibble: 1 × 5\n  mean_HP median_HP max_HP min_HP sum_HP\n    &lt;dbl&gt;     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1    69.3        65    255      1  55407\n\n\n\n\n\nGrupiranje podataka\nAnaliza podataka često zahtijeva usporedbu različitih skupina ili kategorija unutar skupa podataka. Zato je u brojnim slučajevima potrebno grupirati podatke u pojedine skupine s obzirom na određeno konkretno obilježje podataka i tek onda provoditi zasebne manipulacije, statističke obrade ili vizualizacije unutar odabranih grupa.\n\n\n\n\n\n\nTipGlagol group_by()\n\n\n\n\n\nGlagol group_by() pomiče opseg svake funkcije s operiranja na cijelom podatkovnom skupu na operiranje grupu po grupu. To znači da se sve naknadne operacije primjenjuju zasebno na svaku definiranu grupu umjesto na cijeli skup podataka odjednom. Kada se primijeni group_by() na podatkovni okvir, ta funkcija dodaje metapodatke koji označavaju kako su redovi podijeljeni u određene grupe. Vizualno, podaci izgledaju isto, ali interno su organizirani tako da R zna da svaka sljedeća operacija treba biti izvršena odvojeno za svaku grupu.\nOvaj pristup omogućuje provođenje istih analitičkih operacija na različitim podskupovima podataka simultano bez potrebe za ručnim iteriranjem kroz svaku grupu. Grupiranje omogućava primjenu drugih glagola ili funkcija na svaku grupu zasebno čime se olakšava složenije analize podataka, odnosno provođenje istih analiza na različitim podskupovima podataka simultano što je ključno za komparativnu analizu.\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nKako bismo otkrili koliko Pokemona pripada pojedinom tipu podataka, odnosno prebrojali sve Pokemone koji pripadaju tipu 1, koristi se glagol n() nakon što se Pokemoni grupiraju prema varijabli type_1 unutar glagola group_by().\n\n# Izračun prosječnog HP-a prema tipu 1\npokemon_dataset |&gt;\n  group_by(type_1) |&gt;\n  summarise(number_per_type_1 = n())\n\n# A tibble: 18 × 2\n   type_1   number_per_type_1\n   &lt;fct&gt;                &lt;int&gt;\n 1 water                  112\n 2 normal                  98\n 3 grass                   70\n 4 bug                     69\n 5 psychic                 57\n 6 fire                    52\n 7 electric                44\n 8 rock                    44\n 9 dragon                  32\n10 ghost                   32\n11 ground                  32\n12 dark                    31\n13 poison                  28\n14 fighting                27\n15 steel                   27\n16 ice                     24\n17 fairy                   17\n18 flying                   4\n\n\nOsim toga, mogu nas zanimati prosječne napadačke i obrambene sposobnosti Pokemona s obzirom na tip pokemona i legendarnost. U tu svrhu, možemo grupirati podatkovni okvir prema dvije varijable, type_1 i legendary, čime ćemo dobiti podatkovni skup s informacijama o prosječnim napadačkim i obrambenim vrijednostima svake skupine.\n\n# Prikaz minimalnih i maksimalnih obrambenih bodova s obzirom na tip 1 i legendarnost pokemona\npokemon_dataset |&gt;\n  group_by(type_1, legendary) |&gt;\n  summarise(\n    mean_attack = mean(attack),\n    mean_defense = mean(defense)\n  )\n\n`summarise()` has grouped output by 'type_1'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 33 × 4\n# Groups:   type_1 [18]\n   type_1  legendary mean_attack mean_defense\n   &lt;fct&gt;   &lt;lgl&gt;           &lt;dbl&gt;        &lt;dbl&gt;\n 1 water   FALSE            72.8         72.0\n 2 water   TRUE            111.          98.8\n 3 normal  FALSE            72.1         58.7\n 4 normal  TRUE            140          115  \n 5 grass   FALSE            72.1         70.3\n 6 grass   TRUE             97.7         82.3\n 7 bug     FALSE            71.0         70.7\n 8 psychic FALSE            55.0         61  \n 9 psychic TRUE            122.          88.2\n10 fire    FALSE            82.2         64.5\n# ℹ 23 more rows\n\n\n\n\n\nNakon što se završi s operacijama na grupiranim podacima, može biti korisno ukloniti grupiranje kako bi se izbjegli neželjeni efekti u daljnjim operacijama. Drugim riječima, nakon što su podaci grupirani pomoću group_by() glagola, sve sljedeće operacije automatski se primjenjuju na svaku grupu zasebno umjesto na cijeli skup podataka. Kada se sažme podatkovni okvir grupiran po više od jedne varijable, svaki sažetak “oguljuje” zadnju grupu. U nekim situacijama potrebno je eksplicitno ukloniti grupiranje kako bi se vratilo na rad s cijelim skupom podataka kao jednom cjelinom.\n\n\n\n\n\n\nTipGlagol ungroup()\n\n\n\n\n\nRazgrupiranje podatkovnih okvira može se postići glagolom ungroup(). Ovaj glagol omogućuje uklanjanje svih grupiranja iz podatkovnog okvira i vraća ga u negrupiran oblik gdje se sve operacije ponovno primjenjuju na cijeli skup podataka. Glagolom se zapravo postiže to da se prema sumiranim podacima glagolom summarise() možemo ponašati kao prema pojedinim opažanjima (redovima) u podatkovnom okviru, a ne sumiranjima.\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nRecimo da nas nakon grupiranja podataka prema varijablama type_1 i legendary i sumiranja grupa na temelju prosječne HP vrijednosti Pokemona zanimaju detaljnije karakteristike tih grupa. Kako bismo primijenili dodatne funkcije na sumirani grupni podatkovni okvir potrebno je razgrupirati ga glagolom ungroup(). Time možemo vršiti dodatne manipulacije podatkovnog okvira, primjerice izdvojiti samo grupe koje imaju prosječnu HP vrijednost veću od 90 i poradati grupe po veličini ili pak grupirati već postojeće grupe prema novoj varijabli i ponovno izvršiti sumiranja.\n\n# Grupiraj po primarnom tipu, izračunaj prosjeke, pa ukloni grupiranje\npokemon_dataset |&gt;\n  group_by(type_1, legendary) |&gt;\n  summarise(mean_HP = mean(HP)) |&gt;\n  ungroup() |&gt;\n  filter(mean_HP &gt;= 90) |&gt;\n  arrange(desc(mean_HP))\n\n`summarise()` has grouped output by 'type_1'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 10 × 3\n   type_1 legendary mean_HP\n   &lt;fct&gt;  &lt;lgl&gt;       &lt;dbl&gt;\n 1 ghost  TRUE        150  \n 2 fairy  TRUE        126  \n 3 normal TRUE        115  \n 4 dragon TRUE        101. \n 5 dark   TRUE         98  \n 6 water  TRUE         97.5\n 7 grass  TRUE         97  \n 8 fire   TRUE         96.4\n 9 ground TRUE         94.5\n10 steel  TRUE         92.8\n\n# Grupiraj po primarnom tipu, izračunaj prosjeke, pa ukloni grupiranje\npokemon_dataset |&gt;\n  group_by(type_1, legendary) |&gt;\n  summarise(mean_HP = mean(HP)) |&gt;\n  ungroup() |&gt;\n  group_by(legendary) |&gt;\n  summarise(mean_of_mean_HP = mean(mean_HP)) |&gt;\n  arrange(desc(mean_of_mean_HP))\n\n`summarise()` has grouped output by 'type_1'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 2 × 2\n  legendary mean_of_mean_HP\n  &lt;lgl&gt;               &lt;dbl&gt;\n1 TRUE                 97.6\n2 FALSE                66.5",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulacija podacima</span>"
    ]
  },
  {
    "objectID": "03_01_manipulacija_podacima.html#glagoli-za-mijenjanje-varijabli",
    "href": "03_01_manipulacija_podacima.html#glagoli-za-mijenjanje-varijabli",
    "title": "4  Manipulacija podacima",
    "section": "3 Glagoli za mijenjanje varijabli",
    "text": "3 Glagoli za mijenjanje varijabli\nPreimenovanje varijabli\nJasni i deskriptivni nazivi varijabli ključni su za razumljivost i održivost koda. Sirovi podaci često dolaze s nepraktičnim nazivima stupaca, kraticama ili nazivima koji nisu intuitivni za analizu. Zato preimenovanje omogućuje standardizaciju naziva, uklanjanje nejasnoća i poboljšanje čitljivosti podataka bez mijenjanja sadržaja ili strukture podatkovnog okvira.\n\n\n\n\n\n\nTipGlagol ungroup()\n\n\n\n\n\nZa promjenu imena varijable koristi se glagol rename() u kojem se imenuje novi naziv varijable i stari naziv odjeljen znakom =. Prije znaka jednakosti pritom se piše novi naziv, a nakon znaka jednakosti stari naziv varijabli podatkovnog okvira. Ime varijable može se promijeniti i koristeći samo glagol select(), no u tom se slučaju moraju navoditi sve varijable koje želimo imati u podatkovnom okviru, a ne samo preimenovane varijable.\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nRecimo da želimo kreirati podatkovni okvir u kojem će biti samo tri varijable kojima će nazivi biti zapisani velikim slovima. Najjednostavniji način za postizanje toga je koristiti glagol rename() u koji se unose novi i stari nazivi varijabli koje želimo preimenovati.\n\npokemon_dataset |&gt;\n  select(name, type_1, type_2, legendary) |&gt;\n  rename(\n    NAME = name,\n    TYPE1 = type_1,\n    TYPE2 = type_2\n  )\n\n# A tibble: 800 × 4\n   NAME                      TYPE1 TYPE2  legendary\n   &lt;chr&gt;                     &lt;fct&gt; &lt;fct&gt;  &lt;lgl&gt;    \n 1 bulbasaur                 grass poison FALSE    \n 2 ivysaur                   grass poison FALSE    \n 3 venusaur                  grass poison FALSE    \n 4 venusaurmega venusaur     grass poison FALSE    \n 5 charmander                fire  &lt;NA&gt;   FALSE    \n 6 charmeleon                fire  &lt;NA&gt;   FALSE    \n 7 charizard                 fire  flying FALSE    \n 8 charizardmega charizard x fire  dragon FALSE    \n 9 charizardmega charizard y fire  flying FALSE    \n10 squirtle                  water &lt;NA&gt;   FALSE    \n# ℹ 790 more rows\n\n\n\n\n\nPremještanje varijabli\nKonačno, logičko organiziranje redoslijeda stupaca u podatkovnom okviru poboljšava preglednost i olakšava analizu podataka. Redoslijed varijabli može značajno utjecati na efikasnost rada s podacima, osobito kada se radi s velikim brojem stupaca. Premještanje omogućuje stvaranje logičke strukture podataka koja prati tok analize i grupira povezane informacije.\n\n\n\n\n\n\nTipGlagol relocate()\n\n\n\n\n\nGlagol relocate() koristi se za promjenu redoslijeda varijabli u nizu varijabli. relocate() se koristi uz argumente .before koji označava da se određena varijabla treba ispisati ispred neke druge i .after koja označava da se određena varijabla treba ispisati iza neke druge.\nRedoslijed varijabli može se promijeniti i koristeći glagol select(), no u tom se slučaju moraju navoditi sve varijable.\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nRecimo da se u daljnjoj analizi želimo usmjeriti samo na varijable “id”, “name”, “type_1” i “type_2”, no želimo da im redoslijed bude slijedeći: 1. “type_2”, 2. “name”, 3. “type_1” i 4. “id”.\n\npokemon_dataset |&gt;\n  select(id, name, type_1, type_2) |&gt;\n  relocate(id, .after = type_1) |&gt;\n  relocate(type_2, .before = name)\n\n# A tibble: 800 × 4\n   type_2 name                      type_1    id\n   &lt;fct&gt;  &lt;chr&gt;                     &lt;fct&gt;  &lt;dbl&gt;\n 1 poison bulbasaur                 grass      1\n 2 poison ivysaur                   grass      2\n 3 poison venusaur                  grass      3\n 4 poison venusaurmega venusaur     grass      3\n 5 &lt;NA&gt;   charmander                fire       4\n 6 &lt;NA&gt;   charmeleon                fire       5\n 7 flying charizard                 fire       6\n 8 dragon charizardmega charizard x fire       6\n 9 flying charizardmega charizard y fire       6\n10 &lt;NA&gt;   squirtle                  water      7\n# ℹ 790 more rows",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipulacija podacima</span>"
    ]
  },
  {
    "objectID": "03_02_nedostajajuce_vrijednosti.html",
    "href": "03_02_nedostajajuce_vrijednosti.html",
    "title": "5  Nedostajajuće vrijednosti",
    "section": "",
    "text": "1 Prepoznavanje nedostajajućih vrijednosti\nNedostajuće vrijednosti (missing values) predstavljaju jedan od najčešćih izazova u radu sa stvarnim podacima. Prilikom rada s velikim i složenim skupovima podataka, nedostajuće vrijednosti se gotovo neizbježno pojavljuju tijekom procesa prikupljanja, čišćenja i obrade podataka.\nU R-u se nedostajuće vrijednosti mogu se pojaviti u eksplicitnom obliku kada je u podatkovnom okviru polje s nedostajajućim vrijednostima popunjeno s NA oznakama ili u implicitnom obliku kada cijeli redak podataka jednostavno ne postoji u skupu podataka. Eksplicitne nedostajuće vrijednosti predstavljaju situacije gdje znamo da određena vrijednost postoji, ali nam nije poznata ili dostupna. Implicitne nedostajuće vrijednosti nastaju kada nam nisu poznate ili uključene vrijednosti cijelog jednog opažanja.\nNedostajuće vrijednosti mogu nastati iz različitih razloga. Najčešće se pojavljuju zbog praktičnih razloga tijekom unosa podataka kada osoba koja unosi podatke preskoči određena polja ili koristiti konvencije za označavanje nepoznatih vrijednosti. Također mogu nastati zbog tehničkih problema s instrumentima za mjerenje, nedostupnosti ispitanika u određenim trenucima istraživanja ili zbog prethodne obrade podataka gdje su problematični zapisi uklonjeni. Jedan od najčešćih razloga je praktičnost unosa podataka kada se nedostajuće vrijednosti koriste kao oznaka da se vrijednost iz prethodnog reda prenosi dalje. To je posebno uobičajeno kod ručnog unosa podataka gdje se želi izbjeći ponavljanje istih vrijednosti. Ponekad nedostajuće vrijednosti predstavljaju fiksnu i poznatu vrijednost, najčešće nulu. U drugim slučajevima, neki konkretni broj poput 99 ili -999 može predstavljati nedostajuću vrijednost što je naslijeđe iz starijih sustava koji nisu imali prikladan način za reprezentaciju nedostajućih vrijednosti.\nPostoji i poseban tip nedostajuće vrijednosti poznat kao NaN (Not a Number) koji nastaje kada se izvodi matematička operacija s neodređenim rezultatom, poput dijeljenja nule s nulom ili računanja korijena negativnog broja. Iako se NaN općenito ponaša slično kao NA, važno je razumjeti da predstavlja specifičan matematički koncept.\nNedostajuće vrijednosti mogu značajno utjecati na analize podataka jer mogu interferirati s izračunavanjem statistika i stvarati neočekivane rezultate u grafičkim prikazima. One mijenjaju distribucije varijabli i mogu uvesti pristranost u rezultate. Njihova prisutnost može smanjiti statističku snagu analiza i otežati interpretaciju rezultata. Stoga je ključno razviti strategije za prepoznavanje, evaluaciju i rukovanje nedostajućim vrijednostima koje će omogućiti točne i pouzdane analize, ali i razumjeti kako ih prepoznati, raditi s njima i prilagoditi analitičke pristupe njihovoj prisutnosti u podacima. Ipak, važno je razumjeti da nedostajuće vrijednosti nisu uvijek greška ili problem koji treba riješiti. Ponekad one nose informacije o prirodi podataka ili procesu njihova prikupljanja. Na primjer, ako u anketi o prihodima velik broj ispitanika ne odgovara na pitanje o visini svoje plaće, onda to može ukazivati na osjetljivost teme ili socioekonomske karakteristike uzorka.\nU R-u postoji nekoliko osnovnih funkcija koje se koriste za prepoznavanje i rad s nedostajućim vrijednostima. Funkcija is.na() je najosnovnija funkcija za prepoznavanje nedostajajućih vrijednosti koja vraća logički vektor koji označava koje su vrijednosti u podatkovnom okviru nedostajuće. Pritom se može primijeniti na pojedinačne stupce ili na cijeli podatkovni okvir.\nZa poseban slučaj NaN vrijednosti, koje nastaju kod neodređenih matematičkih operacija kao što su 0/0 ili sqrt(-1), koristi se funkcija is.nan() koja se ponaša slično kao NA.\nZa brojanje nedostajajućih vrijednosti može se efikasno koristiti nekoliko kombiniranih funkcija. Pritom se ističu funkcije sum() i colSums() za brojanje nedostajajućih vrijednosti u pojedinom stupcu te rowSums() za brojanje nedostajajućih vrijednosti po redcima. Te se funkcije kombiniraju s funkcijom is.na() kako bi dale informaciju o tome koliko je nedostajajućih vrijednosti u podatkovnim okvirima.\nUnutar tidyverse-a je posebno korisna funkcija summarise() za stvaranje sažetaka podataka, uključujući brojanje nedostajajućih vrijednosti. Ova funkcija stvara podatkovni okvir s jednim redom za svaku kombinaciju grupiranih varijabli, a ako nema grupiranih varijabli, rezultat će imati jedan red koji sažima sve opažanja.\nFunkcija complete.cases() je posebno korisna za identifikaciju redaka koji nemaju nedostajajuće vrijednosti. Ova funkcija vraća logički vektor koji označava koji redovi u podatkovnom okviru ne sadrže nikakve nedostajajuće vrijednosti. To je korisno kada želimo filtrirati podatke ili analizirati samo potpune zapise.\nOsim toga funkcija drop_na() iz tidyr paketa uklanja redove koji sadrže nedostajuće vrijednosti u bilo kojem od specificiranih stupaca. Ova funkcija je vrlo jednostavna za korištenje i omogućava preciznu kontrolu nad time koji stupci se razmatraju pri uklanjanju redova.",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Nedostajajuće vrijednosti</span>"
    ]
  },
  {
    "objectID": "03_02_nedostajajuce_vrijednosti.html#prepoznavanje-nedostajajućih-vrijednosti",
    "href": "03_02_nedostajajuce_vrijednosti.html#prepoznavanje-nedostajajućih-vrijednosti",
    "title": "5  Nedostajajuće vrijednosti",
    "section": "",
    "text": "TipFunkcija is.na()\n\n\n\n\n\nFunkcija is.na() koristi se za identifikaciju nedostajućih vrijednosti u R-u. Funkcija vraća logički vektor iste duljine kao ulazni objekt, pri čemu je svaki element TRUE ako je odgovarajuća vrijednost u ulaznom objektu nedostajuća, a FALSE ako nije.\n\n\n\n\n\n\n\nArgument\nObjašnjenje\n\n\n\n\nx\nR objekt koji se testira na prisutnost nedostajućih vrijednosti\n\n\nrecursive\ntreba li funkcija anyNA() biti primijenjena rekurzivno na liste i pairliste\n\n\nvalue\nkoristi se u kontekstu zamjene vrijednosti kroz funkciju is.na&lt;-() čime se specificiraju vrijednosti koje će zamijeniti nedostajuće pozicije u originalnom objektu\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nU pokemon_dataset pojavljuje se više nedostajućih vrijednosti, a koje se jednostavno mogu testirati funkcijom is.na(). Pritom je najjednostavniji način prvo provjeriti nedostajuće vrijednosti cijelog podatkovnog okvira, a tek kasnije pojedinih varijabli.\n\nhead(is.na(pokemon_dataset), 20)\n\n         id  name type_1 type_2 total    HP attack defense special_attack\n [1,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n [2,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n [3,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n [4,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n [5,] FALSE FALSE  FALSE   TRUE FALSE FALSE  FALSE   FALSE          FALSE\n [6,] FALSE FALSE  FALSE   TRUE FALSE FALSE  FALSE   FALSE          FALSE\n [7,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n [8,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n [9,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n[10,] FALSE FALSE  FALSE   TRUE FALSE FALSE  FALSE   FALSE          FALSE\n[11,] FALSE FALSE  FALSE   TRUE FALSE FALSE  FALSE   FALSE          FALSE\n[12,] FALSE FALSE  FALSE   TRUE FALSE FALSE  FALSE   FALSE          FALSE\n[13,] FALSE FALSE  FALSE   TRUE FALSE FALSE  FALSE   FALSE          FALSE\n[14,] FALSE FALSE  FALSE   TRUE FALSE FALSE  FALSE   FALSE          FALSE\n[15,] FALSE FALSE  FALSE   TRUE FALSE FALSE  FALSE   FALSE          FALSE\n[16,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n[17,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n[18,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n[19,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n[20,] FALSE FALSE  FALSE  FALSE FALSE FALSE  FALSE   FALSE          FALSE\n      special_defense speed generation legendary\n [1,]           FALSE FALSE      FALSE     FALSE\n [2,]           FALSE FALSE      FALSE     FALSE\n [3,]           FALSE FALSE      FALSE     FALSE\n [4,]           FALSE FALSE      FALSE     FALSE\n [5,]           FALSE FALSE      FALSE     FALSE\n [6,]           FALSE FALSE      FALSE     FALSE\n [7,]           FALSE FALSE      FALSE     FALSE\n [8,]           FALSE FALSE      FALSE     FALSE\n [9,]           FALSE FALSE      FALSE     FALSE\n[10,]           FALSE FALSE      FALSE     FALSE\n[11,]           FALSE FALSE      FALSE     FALSE\n[12,]           FALSE FALSE      FALSE     FALSE\n[13,]           FALSE FALSE      FALSE     FALSE\n[14,]           FALSE FALSE      FALSE     FALSE\n[15,]           FALSE FALSE      FALSE     FALSE\n[16,]           FALSE FALSE      FALSE     FALSE\n[17,]           FALSE FALSE      FALSE     FALSE\n[18,]           FALSE FALSE      FALSE     FALSE\n[19,]           FALSE FALSE      FALSE     FALSE\n[20,]           FALSE FALSE      FALSE     FALSE\n\nhead(is.na(pokemon_dataset$type_2), 20)\n\n [1] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[13]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\n\n\n\n\n\n\n\n\n\n\nTipFunkcija is.na()\n\n\n\n\n\nFunkcija is.nan() koristi se za identifikaciju NaN vrijednosti koje označavaju matematički nedefinirane rezultate. Ključna razlika u ponašanju između funkcije is.na() i is.nan() je to da is.na() vraća TRUE i za NA i za NaN vrijednosti, dok is.nan() vraća TRUE samo za NaN vrijednosti.\n\n\n\n\n\n\n\nArgument\nObjašnjenje\n\n\n\n\nx\nR objekt koji se testira na prisutnost nedostajućih vrijednosti\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nsum(is.na(pokemon_dataset$type_2))\n\n[1] 386\n\ncolSums(is.na(pokemon_dataset))\n\n             id            name          type_1          type_2           total \n              0               0               0             386               0 \n             HP          attack         defense  special_attack special_defense \n              0               0               0               0               0 \n          speed      generation       legendary \n              0               0               0 \n\nrowSums(is.na(pokemon_dataset))\n\n  [1] 0 0 0 0 1 1 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 1 1 0 0 1 1 1 1 1 1 1 1 0\n [38] 1 1 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1\n [75] 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 0 0 1 1 1 1 1 1 0\n[112] 0 1 1 1 1 1 1 1 0 0 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 1 0 1 1 0 0 0 1 1 1 1 1\n[149] 1 0 0 0 0 0 0 1 0 0 0 1 1 0 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0\n[186] 0 1 1 0 1 0 0 0 1 1 1 0 1 0 0 1 1 0 0 0 1 1 1 0 0 0 1 1 0 0 1 1 1 0 1 0 1\n[223] 0 0 0 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 1 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 1\n[260] 1 1 1 1 1 1 0 0 0 0 0 0 0 1 1 1 0 1 0 0 0 1 0 0 0 1 1 1 1 1 1 0 1 0 0 0 0\n[297] 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 1 1 1 1 1 0 1 1 1 0 0 0 0 0 0 0\n[334] 1 0 0 0 1 1 1 1 1 1 1 0 1 1 0 0 0 1 1 0 0 0 1 1 1 1 1 0 0 1 0 0 0 0 1 1 0\n[371] 0 0 0 1 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 0 0 0 1 1 1 0 1 1\n[408] 1 0 0 0 0 0 0 1 1 1 0 0 0 0 1 1 1 0 0 0 0 1 1 1 1 1 1 0 1 0 0 1 1 0 0 0 0\n[445] 1 0 1 1 1 1 1 0 0 1 1 0 0 1 0 0 0 0 0 0 1 1 1 1 1 1 0 1 0 0 1 1 0 1 0 1 1\n[482] 1 0 0 0 0 1 0 1 0 0 0 0 0 0 1 1 0 0 1 1 0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 1 1\n[519] 1 0 0 1 1 0 0 1 0 0 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 1 0 0 1 1 1 1 1 0 1 0 1\n[556] 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 0 0 1 0 1 0\n[593] 1 1 1 1 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 0 0 0 1 1 0 1 0 0 0 0 0 1 1 0 0 0 0\n[630] 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 1 1 1 1 1\n[667] 1 1 0 0 0 1 1 1 1 1 1 1 1 0 1 1 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1\n[704] 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 0 1 1 0 1 0 0 0 0 1 1 0 0 0 1 1 1\n[741] 1 1 1 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 1 1 1\n[778] 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\n# Brojanje NA vrijednosti za specifične stupce\npokemon_dataset |&gt; summarise(na_count_type_2 = sum(is.na(type_2)))\n\n# A tibble: 1 × 1\n  na_count_type_2\n            &lt;int&gt;\n1             386\n\n# Brojanje ukupnog broja NA vrijednosti u cijelom podatkovnom okviru\npokemon_dataset |&gt; \n  summarise(total_NA = sum(is.na(across(everything()))))\n\n# A tibble: 1 × 1\n  total_NA\n     &lt;int&gt;\n1      386\n\n# Brojanje ne-NA vrijednosti po grupama\npokemon_dataset |&gt;\n  group_by(generation) |&gt;\n  summarise(not_NA_count = sum(!is.na(generation)))\n\n# A tibble: 6 × 2\n  generation not_NA_count\n  &lt;fct&gt;             &lt;int&gt;\n1 1                   166\n2 5                   165\n3 3                   160\n4 4                   121\n5 2                   106\n6 6                    82\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\ncomplete.cases(pokemon_dataset)\n\n  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37]  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n [85] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE\n [97] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[121]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[133]  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[157]  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[181]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE\n[193]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[205]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n[217] FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n[229]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[241]  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE\n[277] FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[301]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE\n[313] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[325] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[337]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE\n[349]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n[361]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE\n[373]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[409]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[421]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[433] FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[445] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n[457]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE\n[481] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE\n[493]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE\n[505]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[517] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE\n[529]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[541]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n[553] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[589] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[601]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE\n[613]  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[625] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE\n[649]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE\n[685]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[697]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[709]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[721]  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[733] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[745] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[757]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[769]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[781]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[793] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n# Zadržavanje samo kompletnih redaka\npokemon_dataset[complete.cases(pokemon_dataset), ]\n\n# A tibble: 414 × 13\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1     1 bulbasaur       grass  poison   318    45     49      49             65\n 2     2 ivysaur         grass  poison   405    60     62      63             80\n 3     3 venusaur        grass  poison   525    80     82      83            100\n 4     3 venusaurmega v… grass  poison   625    80    100     123            122\n 5     6 charizard       fire   flying   534    78     84      78            109\n 6     6 charizardmega … fire   dragon   634    78    130     111            130\n 7     6 charizardmega … fire   flying   634    78    104      78            159\n 8    12 butterfree      bug    flying   395    60     45      50             90\n 9    13 weedle          bug    poison   195    40     35      30             20\n10    14 kakuna          bug    poison   205    45     25      50             25\n# ℹ 404 more rows\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\n# Uklanjanje redova s NA vrijednostima u bilo kojem stupcu\npokemon_dataset |&gt;\n  drop_na()\n\n# A tibble: 414 × 13\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1     1 bulbasaur       grass  poison   318    45     49      49             65\n 2     2 ivysaur         grass  poison   405    60     62      63             80\n 3     3 venusaur        grass  poison   525    80     82      83            100\n 4     3 venusaurmega v… grass  poison   625    80    100     123            122\n 5     6 charizard       fire   flying   534    78     84      78            109\n 6     6 charizardmega … fire   dragon   634    78    130     111            130\n 7     6 charizardmega … fire   flying   634    78    104      78            159\n 8    12 butterfree      bug    flying   395    60     45      50             90\n 9    13 weedle          bug    poison   195    40     35      30             20\n10    14 kakuna          bug    poison   205    45     25      50             25\n# ℹ 404 more rows\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;\n\n# Uklanjanje redova s NA vrijednostima samo u specifičnim stupcima\npokemon_dataset |&gt;\n  drop_na(type_2)\n\n# A tibble: 414 × 13\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1     1 bulbasaur       grass  poison   318    45     49      49             65\n 2     2 ivysaur         grass  poison   405    60     62      63             80\n 3     3 venusaur        grass  poison   525    80     82      83            100\n 4     3 venusaurmega v… grass  poison   625    80    100     123            122\n 5     6 charizard       fire   flying   534    78     84      78            109\n 6     6 charizardmega … fire   dragon   634    78    130     111            130\n 7     6 charizardmega … fire   flying   634    78    104      78            159\n 8    12 butterfree      bug    flying   395    60     45      50             90\n 9    13 weedle          bug    poison   195    40     35      30             20\n10    14 kakuna          bug    poison   205    45     25      50             25\n# ℹ 404 more rows\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Nedostajajuće vrijednosti</span>"
    ]
  },
  {
    "objectID": "03_02_nedostajajuce_vrijednosti.html#rad-s-nedostajajućim-vrijednostima",
    "href": "03_02_nedostajajuce_vrijednosti.html#rad-s-nedostajajućim-vrijednostima",
    "title": "5  Nedostajajuće vrijednosti",
    "section": "2 Rad s nedostajajućim vrijednostima",
    "text": "2 Rad s nedostajajućim vrijednostima\nPostoji više načina rješavanja problema nedostajajućih vrijednosti, od jednostavnijih kao što je njihovo ignoriranje do raznoraznih imputiranja regresijom. U nastavku će biti prikazano nekoliko jednostavnijih načina rada s nedostajajućim vrijednostima.\nPopunjavanje nedostajajućih vrijednosti fiksnim vrijednostima\nPonekad nedostajuće vrijednosti predstavljaju fiksnu i poznatu vrijednost, najčešće nulu ili neku drugu kategorijalnu varijablu. U takvim slučajevima možete koristiti funkcija coalesce() dplyr paketa kako bi se u ćelije podatkovnog okvira stavila neka fiksna vrijednost. Jedna je često korištena mogućnost kod numeričkih imputiranje aritmetičke sredine vrijednosti koje imamo na mjesto nedostajajućih vrijednosti.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\n# Zamjena NA vrijednosti s nulom\npokemon_dataset |&gt;\n  mutate(type_2 = coalesce(type_2, \"unknown\"))\n\n# A tibble: 800 × 13\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1     1 bulbasaur       grass  poison   318    45     49      49             65\n 2     2 ivysaur         grass  poison   405    60     62      63             80\n 3     3 venusaur        grass  poison   525    80     82      83            100\n 4     3 venusaurmega v… grass  poison   625    80    100     123            122\n 5     4 charmander      fire   unkno…   309    39     52      43             60\n 6     5 charmeleon      fire   unkno…   405    58     64      58             80\n 7     6 charizard       fire   flying   534    78     84      78            109\n 8     6 charizardmega … fire   dragon   634    78    130     111            130\n 9     6 charizardmega … fire   flying   634    78    104      78            159\n10     7 squirtle        water  unkno…   314    44     48      65             50\n# ℹ 790 more rows\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;\n\n\n\n\n\nLast Observation Carried Forward\nČesta se nedostajajuće vrijednosti javljaju iz praktičnih razloga pri unosu podataka. U tim slučajevima nedostajuće vrijednosti označavaju da se vrijednost iz prethodnog reda prenosi dalje, odnosno da bi vrijednost u pojedinoj ćeliji trebala biti ona iz prve gornje popunjene ćelije. U R-u se na taj način mogu popuniti nedostajuće vrijednosti pomoću funkcije fill() iz tidyr paketa.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nhead(pokemon_dataset, 10)\n\n# A tibble: 10 × 13\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1     1 bulbasaur       grass  poison   318    45     49      49             65\n 2     2 ivysaur         grass  poison   405    60     62      63             80\n 3     3 venusaur        grass  poison   525    80     82      83            100\n 4     3 venusaurmega v… grass  poison   625    80    100     123            122\n 5     4 charmander      fire   &lt;NA&gt;     309    39     52      43             60\n 6     5 charmeleon      fire   &lt;NA&gt;     405    58     64      58             80\n 7     6 charizard       fire   flying   534    78     84      78            109\n 8     6 charizardmega … fire   dragon   634    78    130     111            130\n 9     6 charizardmega … fire   flying   634    78    104      78            159\n10     7 squirtle        water  &lt;NA&gt;     314    44     48      65             50\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;\n\npokemon_dataset |&gt;\n  select(id, name, type_2) |&gt;\n  fill(type_2, .direction = \"down\")\n\n# A tibble: 800 × 3\n      id name                      type_2\n   &lt;dbl&gt; &lt;chr&gt;                     &lt;fct&gt; \n 1     1 bulbasaur                 poison\n 2     2 ivysaur                   poison\n 3     3 venusaur                  poison\n 4     3 venusaurmega venusaur     poison\n 5     4 charmander                poison\n 6     5 charmeleon                poison\n 7     6 charizard                 flying\n 8     6 charizardmega charizard x dragon\n 9     6 charizardmega charizard y flying\n10     7 squirtle                  flying\n# ℹ 790 more rows\n\n\n\n\n\nPretvaranje konkretnih vrijednosti u nedostajuće\nPonekad je moguće naići na suprotan problem gdje neka konkretna vrijednost zapravo predstavlja nedostajuću vrijednost. To se obično događa s podacima generiranim od strane programa koji nemaju prikladan način za predstavljanje nedostajajućih vrijednosti, pa umjesto toga koriste neku specijalnu vrijednost poput “99” ili “-999” kao oznaku za nedostajajuće vrijednosti.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  select(id, name, type_2) |&gt;\n  mutate(type_2 = na_if(type_2, \"flying\"))\n\n# A tibble: 800 × 3\n      id name                      type_2\n   &lt;dbl&gt; &lt;chr&gt;                     &lt;fct&gt; \n 1     1 bulbasaur                 poison\n 2     2 ivysaur                   poison\n 3     3 venusaur                  poison\n 4     3 venusaurmega venusaur     poison\n 5     4 charmander                &lt;NA&gt;  \n 6     5 charmeleon                &lt;NA&gt;  \n 7     6 charizard                 &lt;NA&gt;  \n 8     6 charizardmega charizard x dragon\n 9     6 charizardmega charizard y &lt;NA&gt;  \n10     7 squirtle                  &lt;NA&gt;  \n# ℹ 790 more rows\n\n\n\n\n\nParametar na.rm\nParametar na.rm označava “NA remove” i ignorira nedostajajuće vrijednosti tijekom izračuna. Postavljanjem argumenta na.rm = TRUE funkcije poput sum(), mean(), median(), min(), max() i druge, računaju rezultate bez utjecaja nedostajajućih vrijednosti. Bez ovog parametra, funkcije bi vratile NA ako su nedostajajuće vrijednosti prisutne u podacima.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\n# Vektor s nedostajajućim vrijednostima\nx &lt;- c(1, 2, 3, NA, 5, NA, 7)\n\nmean(x)\n\n[1] NA\n\nmean(x, na.rm = TRUE)\n\n[1] 3.6\n\n\n\n\n\nNa sličan se način argument može koristiti i ako se spomenute funkcije koriste unutar glagol summarise() iz dplyr paketa.",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Nedostajajuće vrijednosti</span>"
    ]
  },
  {
    "objectID": "03_03_pridruzivanje_podataka.html",
    "href": "03_03_pridruzivanje_podataka.html",
    "title": "6  Pridruživanje podataka",
    "section": "",
    "text": "ImportantPodaci korišteni u dijelu poglavlja\n\n\n\n\n\nZa potrebe demonstracije različitih tehnika pridruživanja podatkovnih okvira, izvorni podaci o Pokemonima iz pokemon_dataset podatkovnog okvira podjeljeni su na dva manja podatkovna okvira. Podatkovni okvir pokemon_names predstavlja osnovni identifikacijski podatkovni okvir koja sadrži temeljne informacije o Pokemonima. Ovaj okvir uključuje tri varijable: “id”, “name” i “type_1”. Podatkovni okvir pokemon_strength predstavlja tablicu borbenih statistika koja sadrži mjerenja specijalnih sposobnosti Pokemona. Ovaj okvir uključuje četiri varijable: “id”, “name”, “special_attack” i “special_defense”.\n\n\n# A tibble: 5 × 3\n     id name      type_1  \n  &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;   \n1     1 bulbasaur grass   \n2     2 ivysaur   grass   \n3    16 pidgey    normal  \n4    19 rattata   normal  \n5    25 pikachu   electric\n\n\n# A tibble: 5 × 4\n     id name      special_attack special_defense\n  &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;           &lt;dbl&gt;\n1     1 bulbasaur             65              65\n2    19 rattata               25              35\n3    25 pikachu               50              50\n4    48 venonat               40              55\n5   111 rhyhorn               30              30\n\n\nOvako dizajnirani podatkovni okviri rezultiraju raspodjelom Pokemona u kojoj postoje Pokemoni prisutni u oba podatkovna okvira, Pokemoni koji se nalaze samo u pokemon_names i prisutni samo u pokemon_strength podatkovnom okviru. Ovakva struktura podataka omogućuje da na praktičan način bude demonstrirano kako različite vrste spajanja tretiraju situacije s potpunim i djelomičnim preklapanjem.\n\n\n\nAnaliza podataka rijetko se oslanja samo na jedan podatkovni okvir. U praksi, podaci o istim istrazivanim podacima često dolaze iz različitih izvora ili su organizirani u više podatkovnih okvira kako bi se olakšalo njihovo upravljanje i ažuriranje. Proces objedinjavanja podataka iz više podatkovnih okvira naziva se pridruživanje podataka (engl. data joining). Spajanje omogućuje da iz fragmenata informacija raspoređenih u više tablica sastavimo cjelovitu sliku potrebnu za donošenje zaključaka.\nNajjednostavniji način pridruživanja podataka je dplyr paketom koji nudi šest različitih funkcija za spajanje podatkovnih okvira: left_join(), right_join(), inner_join(), full_join(), semi_join() i anti_join(). Sve ove funkcije dijele zajednički način rada - primaju dva podatkovna okvira (koji se u dokumentaciji označavaju kao x ili lijevi i y ili desni podatkovni okvir) te vraćaju novi podatkovni okvir kao rezultat spajanja. Razlike među ovim funkcijama očituju se u tome koji se redovi zadržavaju u konačnom rezultatu i kako se tretiraju zapisi koji nemaju odgovarajući par u drugom podatkovnom okviru.\nPostoji dvije vrste pridruživanja koje se mogu koristiti dplyr paketom:\n\nMutacijsko pridruživanje (mutating join): Omogućuje kombiniranje varijabli iz dva podatkovna okvira na način da najprije pronalazi odgovarajuće parove zapisa pomoću ključeva, a zatim kopira varijable iz jednog podatkovnog okvira u drugi. Mutacijsko pridruživanje uključuje:\n\nfull_join(): Zadržava sve opservacije iz obja podatkovna okvira te, ako nema podudaranja u nekom od njih, onda se to mjesto popunjava s NA, a koristiti se kada želimo zadržati sve podatke iz oba podatkovna okvira bez obzira postoji li podudaranje ili ne.\ninner_join(): Zadržava samo opservacije koje imaju odgovarajuće vrijednosti u obja podatkovna okvira, odnosno samo zajedničke za oba podatkovna okvira, a koristi se kada želimo zadržati samo podatke koji su zajednički.\nleft_join(): Zadržava sva opažanja iz lijevog (prvog) podatkovnog okvira i dodaje odgovarajuće vrijednosti iz desnog (drugog) podatkovnog okvira, a koristiti se kada želimo zadržati sve podatke iz lijevog podatkovnog okvira bez obzira postoji li podudaranje u desnom.\nright_join(): Zadržava sva opažanja iz desnog (drugog) podatkovnog okvira i dodaje odgovarajuće vrijednosti iz lijevog (prvog) podatkovnog okvira, a koristiti se kada želimo zadržati sve podatke iz desnog podatkovnog okvira bez obzira postoji li podudaranje u lijevom.\n\nFiltrirano pridruživanje (filtering join) je pridruživanje podataka temeljeno na principu filtriranja. Postoje dvije vrste filtrirnih pridruživanja:\n\nsemi_join(): Vraća retke iz prvog podatkovnog okvira koji imaju odgovarajuće vrijednosti u drugom podatkovnom okviru, ali ne dodaje stupce iz drugog podatkovnog okvira, a koristi se kada želimo filtrirati prvi podatkovni okvir prema podacima koji postoje u drugom podatkovnom okviru, ali nas pritom ne zanimaju dodatni stupci iz druge tablice.\nanti_join(): Vraća retke iz prvog podatkovnog okvira koji nemaju podudaranje u drugom podatkovnom okviru, a koristi se kada želimo pronaći retke u prvom podatkovnom okviru koji nemaju podudaranje u drugom podatkovnom okviru.\n\n\n\n\n\n\n\n\nTipGlagoli pridruživanja\n\n\n\n\n\nGlagoli iz dplyr paketa za pridruživanje podatkovnih okvira koriste slične argumente. Zajednički argumenti za *_join() glagole su:\n\n\n\n\n\n\n\nArgument\nObjašnjenje\n\n\n\n\nx i y\npodatkovni okviri za kombiniranje - x predstavlja lijevi podatkovni okvir, a y desni\n\n\nby\nkontrolira koje se varijable koriste za podudaranje opažanja u dvije tablice: 1. NULL (zadana vrijednost) koji koristi zajedničke stupce s istim imenima u obje tablice, 2. vektor koji koristi samo neke od zajedničkih varijabli i 3. imenovani vektor, npr. by = c(\"a\" = \"b\"), ako su imena stupaca različita\n\n\nsuffx\nsufiksi koji se dodaju imenima stupaca koji se pojavljuju u obje tablice (moguće je proslijediti vektor sufiksa, jedan za prvi i jedan za drugi podatkovni okvir)\n\n\ncopy\nšto se događa kada podatkovni okviri nisu na istoj lokaciji (npr. jedna je u memoriji, druga u bazi podataka): ako je TRUE, onda će se drugi podatkovni okvir kopirati na istu lokaciju kao prvi, a ako nije, onda će ostati na različitim lokacijama (zadana vrijednost je FALSE)\n\n\nkeep\nkontrolira koje varijable se zadržavaju u rezultatu - kada je NULL (zadano), zadržavaju se ključevi samo iz x tabele\n\n\nna_matches\nkontrolira kako se tretiraju NA vrijednosti prilikom spajanja: 1. \"na\" (zadano) - NA vrijednosti se podudaraju s drugim NA vrijednostima međusobno, 2. \"never\" - NA vrijednosti se ne podudaraju\n\n\nmultiple\nkontrolira što se događa kada jedan red iz prvog podatkovnog okvira odgovara više redova iz drugog podatkovnog okvira: 1. \"all\" (zadano) - zadržavaju se sva podudaranja (može rezultirati više redova nego u originalnoj tabeli), 2. \"any\" - zadržava se bilo koje od podudaranja (obično prvo), 3. \"first\" - zadržava se samo prvo podudaranje, 4. \"last\" - zadržava se samo zadnje podudaranje\n\n\nunmatched\nodređuje što se događa s redovima koji nemaju podudaranja: 1. \"drop\" (zadano) - redovi bez podudaranja se uklanjaju (standardno ponašanje inner_join-a), 2. \"error\" - funkcija će baciti grešku ako postoje redovi bez podudaranja\n\n\nrelationship\nomogućuje eksplicitno definiranje očekivane prirode veze između tabela: 1. NULL (zadano) - ne provjerava se tip veze, 2. \"one-to-one\" - svaki red iz prvog podatkovnog okvira odgovara točno jednom redu iz drugog, 3. \"one-to-many\" - svaki red iz prvog podatkovnog okvira može odgovarati više podatkovnih okvira iz drugog, 4. \"many-to-one\" - više redova iz prvog podatkovnog okvira može odgovarati jednom redu iz drugog, 5. \"many-to-many\" - više redova iz oba podatkovna okvira može se međusobno podudarati\n\n\n\nPrilikom strukturiranja kodova, pravila su slična uobičajenima. U prvi se red navodi prvi, odnosno lijevi podatkovni okvir kojem se pridružuje drugi. U novi se red piše glagol povezivanja, a podatkovni okvir i glagol povezivanja, kao i eventualni budući glagoli, povezuju se poveznicima.\n\n\n\n\n0.1 Pridruživanje podataka dplyr paketom\n\n0.1.1 Mutacijsko pridruživanje\nMutacijsko pridruživanje prvi je oblik pridruživanje koje omogućuje kombiniranje varijabli iz dva podatkovna okvira tako da prvo pronalazi parove zapisa pomoću funkcijom određenih ključeva, a zatim kopira varijable iz jednog podatkovnog okvira u drugi. Slično kao glagol mutate(), koristi se za spajanje dodaju nove varijable s desne strane podatkovnog okvira.\n\n0.1.1.1 Unutarnje pridruživanje\nPrvi oblik pridruživanja podatkovnih okvira je je Unutarnje pridruživanje kojim se spajaju dvija podatkovna okvira, ali samo unutar zajedničkih opažanja u oba podatkovna okvira. Drugim riječima, u novi se podatkovni okvir uvrštavaju samo ona opažanja zajednička za oba podatkovna okvira. Ono se izvodi glagolom inner_join().\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nKorištenje glagola inner_join() na primjeru podatkovnih okvira pokemon_names i pokemon_strength vraća samo one Pokemone koji se nalaze u oba podatkovna okvira. U ovom slučaju to je ukupno 7 Pokemona: Bulbasaur, Rattata, Pikachu, Venonat, Rhyhorn, Mewtwo i Blaziken. Svi Pokemoni koji se nalaze samo u pokemon_names ili samo u pokemon_strength biti će isključeni iz ispisa.\n\n# Unutarnje spajanje - zadržavaju se samo Pokemoni koji postoje u oba podatkovna okvira\ninner_join(\n  x = pokemon_names,\n  y = pokemon_strength,\n  by = join_by(id, name)\n)\n\n# A tibble: 7 × 5\n     id name      type_1   special_attack special_defense\n  &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;             &lt;dbl&gt;           &lt;dbl&gt;\n1     1 bulbasaur grass                65              65\n2    19 rattata   normal               25              35\n3    25 pikachu   electric             50              50\n4    48 venonat   bug                  40              55\n5   111 rhyhorn   ground               30              30\n6   150 mewtwo    psychic             154              90\n7   257 blaziken  fire                110              70\n\n\n\n\n\n\n\n0.1.1.2 Vanjska pridruživanja\nIste principe možemo primijeniti za vanjska pridruživanja koja zadržavaju opažanja koja se pojavljuju u barem jednom od podatkovnih okvira. Ova pridruživanja funkcioniraju dodavanjem dodatnog retka svakom podatkovnom okviru koji ima ključ koji odgovara svim slučajevima kada nijedan drugi ključ ne odgovara, a vrijednosti su popunjene s NA. Postoje tri vrste vanjskih spajanja, a razlikuju se po tome koji podatkovni okvir dobiva dodatni redak s NA vrijednostima: potpuno, lijevo i desno.\nLijevo pridruživanje zadržava sve zapise iz lijevog ili prvog podatkovnog okvira, odnosno onog koji je među kodovima označen argumentom x. Pritom će svaki redak iz lijevog podatkovnog okvira biti prisutan u rezultatu jer može, u najgorem slučaju, biti sparen s retkom NA vrijednosti iz desnog podatkovnog okvira.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nGlagol left_join() vraća točno 15 redaka - koliko ih i ima u početnim podatkovnim okvirima. U prvom slučaju u kojem se u lijevi podatkovni okvir pokemon_names dodaju vrijednosti iz pokemon_strenght, za Pokemone koji postoje i u pokemon_strength, vrijednosti “special_attack” i “special_defense” bit će popunjene stvarnim vrijednostima iz toga podatkovnog okvira. Za Pokemone koji postoje samo u pokemon_names te vrijednosti biti će NA. Suprotno vrijedi za drugi slučaj.\n\n# Lijevo spajanje - svi Pokemoni iz pokemon_names su zadržani\nleft_join(\n  x = pokemon_names,\n  y = pokemon_strength,\n  by = join_by(id, name)\n)\n\n# A tibble: 15 × 5\n      id name      type_1   special_attack special_defense\n   &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;             &lt;dbl&gt;           &lt;dbl&gt;\n 1     1 bulbasaur grass                65              65\n 2     2 ivysaur   grass                NA              NA\n 3    16 pidgey    normal               NA              NA\n 4    19 rattata   normal               25              35\n 5    25 pikachu   electric             50              50\n 6    41 zubat     poison               NA              NA\n 7    48 venonat   bug                  40              55\n 8    76 golem     rock                 NA              NA\n 9   111 rhyhorn   ground               30              30\n10   126 magmar    fire                 NA              NA\n11   150 mewtwo    psychic             154              90\n12   216 teddiursa normal               NA              NA\n13   257 blaziken  fire                110              70\n14   282 gardevoir psychic              NA              NA\n15   300 skitty    normal               NA              NA\n\n# Lijevo spajanje - svi Pokemoni iz pokemon_strength su zadržani\nleft_join(\n  x = pokemon_strength,\n  y = pokemon_names,\n  by = join_by(id, name)\n)\n\n# A tibble: 15 × 5\n      id name      special_attack special_defense type_1  \n   &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;           &lt;dbl&gt; &lt;fct&gt;   \n 1     1 bulbasaur             65              65 grass   \n 2    19 rattata               25              35 normal  \n 3    25 pikachu               50              50 electric\n 4    48 venonat               40              55 bug     \n 5   111 rhyhorn               30              30 ground  \n 6   150 mewtwo               154              90 psychic \n 7   257 blaziken             110              70 fire    \n 8   310 manectric            105              60 &lt;NA&gt;    \n 9   331 cacnea                85              40 &lt;NA&gt;    \n10   351 castform              70              70 &lt;NA&gt;    \n11   354 banette               83              63 &lt;NA&gt;    \n12   371 bagon                 40              30 &lt;NA&gt;    \n13   375 metang                55              80 &lt;NA&gt;    \n14   382 kyogre               150             140 &lt;NA&gt;    \n15   387 turtwig               45              55 &lt;NA&gt;    \n\n\n\n\n\nDesno pridruživanje zadržava sve zapise iz desnog podatkovnog okvira koji je u kodovima označen argumentima y. Svaki redak iz desnog podatkovnog okvira bit će prisutan u rezultatu jer može biti sparen s retkom NA vrijednosti iz lijevog podatkovnog okvira. Rezultat i dalje odgovara strukturi podatkovnog okvira lijevog podatkovnog okvira koliko je to moguće.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nGlagol right_join() vraća 15 redaka kao i glagol left_join() - koliko i ima u početnim podatkovnim okvirima. U prvom primjeru, za Pokemone koji postoje samo u pokemon_strength, vrijednosti varijabli “id”, “name” i “type_1” bit će NA jer ti Pokemoni nisu prisutni u pokemon_names, a isto, ali obrnuto, vrijedi u drugom primjeru.\n\n# Desno spajanje - svi Pokemoni iz pokemon_strength su zadržani\nright_join(\n  x = pokemon_names,\n  y = pokemon_strength,\n  by = join_by(id, name)\n)\n\n# A tibble: 15 × 5\n      id name      type_1   special_attack special_defense\n   &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;             &lt;dbl&gt;           &lt;dbl&gt;\n 1     1 bulbasaur grass                65              65\n 2    19 rattata   normal               25              35\n 3    25 pikachu   electric             50              50\n 4    48 venonat   bug                  40              55\n 5   111 rhyhorn   ground               30              30\n 6   150 mewtwo    psychic             154              90\n 7   257 blaziken  fire                110              70\n 8   310 manectric &lt;NA&gt;                105              60\n 9   331 cacnea    &lt;NA&gt;                 85              40\n10   351 castform  &lt;NA&gt;                 70              70\n11   354 banette   &lt;NA&gt;                 83              63\n12   371 bagon     &lt;NA&gt;                 40              30\n13   375 metang    &lt;NA&gt;                 55              80\n14   382 kyogre    &lt;NA&gt;                150             140\n15   387 turtwig   &lt;NA&gt;                 45              55\n\n# Desno spajanje - svi Pokemoni iz pokemon_names su zadržani\nright_join(\n  x = pokemon_strength,\n  y = pokemon_names,\n  by = join_by(id, name)\n)\n\n# A tibble: 15 × 5\n      id name      special_attack special_defense type_1  \n   &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;           &lt;dbl&gt; &lt;fct&gt;   \n 1     1 bulbasaur             65              65 grass   \n 2    19 rattata               25              35 normal  \n 3    25 pikachu               50              50 electric\n 4    48 venonat               40              55 bug     \n 5   111 rhyhorn               30              30 ground  \n 6   150 mewtwo               154              90 psychic \n 7   257 blaziken             110              70 fire    \n 8     2 ivysaur               NA              NA grass   \n 9    16 pidgey                NA              NA normal  \n10    41 zubat                 NA              NA poison  \n11    76 golem                 NA              NA rock    \n12   126 magmar                NA              NA fire    \n13   216 teddiursa             NA              NA normal  \n14   282 gardevoir             NA              NA psychic \n15   300 skitty                NA              NA normal  \n\n\n\n\n\nKonačno, potpuno pridruživanje (full join) zadržava sve zapise koji se pojavljuju u oba podatkovna okvira. Svaki redak i iz podatkovnog okvira označenog argumentom x i iz onog označenog y bit će uključen u rezultat jer obje tablice imaju rezervni redak s NA vrijednostima.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nGlagol full_join() vraća 23 redaka, odnosno zbroj svih jedinstvenih Pokemona iz oba izvora. Pritom 16 Pokemona ima NA ili za “special_attack” i “special_defense” ili pak za “name”, “type_1” i “type_2”. Samo sedam Pokemona imat će potpune podatke iz oba izvora jer su to oni pokemoni čije se vrijednosti nalaze u oba podatkovna okvira.\n\n# Potpuno spajanje - svi Pokemoni iz oba podatkovna okvira su zadržani\nfull_join(\n  x = pokemon_names,\n  y = pokemon_strength,\n  by = join_by(id, name)\n)\n\n# A tibble: 23 × 5\n      id name      type_1   special_attack special_defense\n   &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;             &lt;dbl&gt;           &lt;dbl&gt;\n 1     1 bulbasaur grass                65              65\n 2     2 ivysaur   grass                NA              NA\n 3    16 pidgey    normal               NA              NA\n 4    19 rattata   normal               25              35\n 5    25 pikachu   electric             50              50\n 6    41 zubat     poison               NA              NA\n 7    48 venonat   bug                  40              55\n 8    76 golem     rock                 NA              NA\n 9   111 rhyhorn   ground               30              30\n10   126 magmar    fire                 NA              NA\n# ℹ 13 more rows\n\n\n\n\n\n\n\n\n0.1.2 Filtrirano pridruživanje\nBroj podudarnosti također određuje ponašanje filtrirnih pridruživanja. Pritom se razlikuju dvije funkcije koje imaju namjenu filtriranja, polu i anti pridruživanje. U oba slučaja važno je samo postojanje podudarnosti, a ne koliko ih puta ima. To znači da filtrirna spajanja nikada ne dupliciraju retke kao što to čine mutacijska spajanja.\n\n0.1.2.1 Polu-pridruživanje\nGlagol semi_join() zadržava sve retke iz podatkovnog okvira koji su označeni argumentom x, a koji imaju barem jednu podudarnost u podatkovnom okviru y.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nRezultat glagola semi_join() je ispis od 7 Pokemona koji se nalaze i u pokemon_names i u pokemon_strength. Važno je primijetiti da rezultat sadrži samo stupce iz pokemon_names jer semi_join() ne dodaje nove stupce, nego samo filtrira retke na temelju postojanja podudarnosti.\n\n# Zadržavanje samo Pokemona koji imaju podatke o snazi\nsemi_join(\n  x = pokemon_names,\n  y = pokemon_strength,\n  by = join_by(id, name)\n)\n\n# A tibble: 7 × 3\n     id name      type_1  \n  &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;   \n1     1 bulbasaur grass   \n2    19 rattata   normal  \n3    25 pikachu   electric\n4    48 venonat   bug     \n5   111 rhyhorn   ground  \n6   150 mewtwo    psychic \n7   257 blaziken  fire    \n\n\n\n\n\n\n\n0.1.2.2 Anti-pridruživanje\nGlagol anti_join() predstavlja suprotnost glagolu semi_join() jer vraća sve retke iz podatkovnog okvira x koji nemaju podudarnost u podatkovnom okviru y. Glagol je korista za pronalaženje nedostajućih vrijednosti koje su implicitno prisutne u podacima. Takve implicitno nedostajuće vrijednosti ne pojavljuju se kao NA, nego postoje samo kao odsutnost određenih kombinacija vrijednosti.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nNa primjer, možemo koristiti funkciju anti_join() kako bismo pronašli Pokemone za koje nemamo podatke o specijalnim sposobnostima. Rezultat će sadržavati osam Pokemona koji se nalaze u pokemon_names, ali ne i u pokemon_strength. Ovi Pokemoni predstavljaju praznine u podacima o specijalnim sposobnostima. Funkcija anti_join() olakšava identifikaciju takvih praznina što je prvi korak prema njihovom popunjavanju prikupljanjem dodatnih podataka ili razumijevanju zašto ti podaci nedostaju.\n\n# Pronalaženje Pokemona bez podataka o snazi\nanti_join(\n  x = pokemon_names,\n  y = pokemon_strength,\n  by = join_by(id, name)\n)\n\n# A tibble: 8 × 3\n     id name      type_1 \n  &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;  \n1     2 ivysaur   grass  \n2    16 pidgey    normal \n3    41 zubat     poison \n4    76 golem     rock   \n5   126 magmar    fire   \n6   216 teddiursa normal \n7   282 gardevoir psychic\n8   300 skitty    normal \n\n\n\n\n\nPrimijetimo da zbroj redaka iz semi_join() (7 Pokemona) i anti_join() (8 Pokemona) daje točno ukupan broj redaka u pokemon_names (15 Pokemona). To je zato što filtrirana pridruživanja zajedno predstavljaju komplementarne operacije koje zajedno pokrivaju sve retke iz početnog podatkovnog okvira.\n\n\n\n\n0.2 Dodatne funkcionalnosti *_join() glagola\n\n0.2.1 Organizacija kodova\nPrilikom spajanja podatkovnih okvira u R-u, postoje dva osnovna pristupa organizaciji koda koji vode istom rezultatu, ali se razlikuju u sintaksi i čitljivosti.\nPrvi je pristup organizacije funkcijski te temelji se na tradicionalnoj sintaksi pozivanja funkcija u R-u. U ovom pristupu, *_join() glagol poziva se eksplicitno, a svi argumenti navode se prema njihovim imenima. Prvi argument x predstavlja prvi ili lijevi podatkovni okvir, a drugi argument y predstavlja drugi ili desni podatkovni okvir, dok argument by specificira ključeve prema kojima se spajanje izvršava. Ovakav zapis omogućuje potpunu jasnoću o tome koji se podaci nalaze na kojoj poziciji i koja je uloga svakog argumenta.\nMeđutim, ova organizacija kodova ima i određena ograničenja. Kada je potrebno izvršiti više uzastopnih transformacija podataka, ugniježđavanje funkcijskih poziva postaje nepraktično i teško čitljivo, primjerice ako nakon spajanja želimo filtrirati podatke i odabrati samo određene stupce:\nDrugi, pristupom koristi operator cjevovoda |&gt;. Njime se podatkovni okvir pokemon_names “prosljeđuje” glagolu inner_join() kao njezin prvi argument, a operator |&gt; uzima rezultat s lijeve strane i automatski ga postavlja kao prvi argument funkcije s desne strane. Budući da inner_join() očekuje podatkovni okvir x, ili prvi podatkovni okvir, kao prvi argument, pokemon_names zauzima tu poziciju, dok pokemon_strength postaje argument y ili drugi podatkovni okvir.\nPrimjerice, isti niz operacija koji smo prethodno prikazali u funkcijskom stilu, u onom kod kojeg se koristi operator |&gt; izgleda bi ovako:\nOvaj kod jasno pokazuje slijed operacija: započinjemo s pokemon_names, kombiniramo ga s pokemon_strength, filtriramo retke gdje je specijalni napad veći od 50 i konačno odabiremo samo željene stupce. Svaki korak logički slijedi iz prethodnog što čini kod intuitivnim za čitanje i razumijevanje.\nIako su oba pristupa organizaciji kodova validna, u nastavku ćemo koristiti pristup s operatorom |&gt; jer on bolje odgovara načinu na koji ljudi razmišljaju o obradi podataka kao o nizu logički povezanih koraka transformacije. Ovaj pristup također se usklađuje s filozofijom paketa dplyr i preporukama većeg dijela stručne literature.\n\n\n0.2.2 Korištenje dodatnih argumenata\n\n0.2.2.1 Specificiranje argumenta za ključeve\nArgument by u funkcijama za spajanje podatkovnih okvira služi za eksplicitno specificiranje ključeva - varijabli koje se koriste za povezivanje zapisa iz dva podatkovna okvira. Ovaj argument govori R-u koje stupce treba usporediti prilikom traženja odgovarajućih parova redaka između dva podatkovna okvira. by može specificirati jedan ili više ključeva, a može se koristiti i za spajanje stupaca koji imaju različita imena u dva podatkovna okvira.\nU modernoj sintaksi, preporučuje se korištenje funkcije join_by() kao nastavak na by argument umjesto starijeg pristupa s tekstualnim vektorima. Funkcija join_by() jasnija je, fleksibilnija i omogućuje specifikaciju složenijih uvjeta spajanja. U funkciju se zapravo umeću nazivi varijabli na temelju kojih se nastoji spojiti podatkovne okvire.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nČesto želimo spajanje izvršiti samo prema jednom ključu, čak i kada postoje drugi zajednički stupci. Na primjer, može biti korisno zadržati oba stupca name kako bismo provjerili jesu li potpuno identični.\n\npokemon_names |&gt;\n  inner_join(pokemon_strength, join_by(id, name))\n\n# A tibble: 7 × 5\n     id name      type_1   special_attack special_defense\n  &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;             &lt;dbl&gt;           &lt;dbl&gt;\n1     1 bulbasaur grass                65              65\n2    19 rattata   normal               25              35\n3    25 pikachu   electric             50              50\n4    48 venonat   bug                  40              55\n5   111 rhyhorn   ground               30              30\n6   150 mewtwo    psychic             154              90\n7   257 blaziken  fire                110              70\n\n\nU ovom slučaju, R će spojiti redove samo na temelju “id” i “name” vrijednosti.\n\n\n\nPritom argument by nije obavezan. Ako se ne navedete, onda će R automatski primijeniti prirodno spajanje (natural join) koje znači da će R automatski prepoznati sve stupce koji imaju identična imena u oba podatkovna okvira i koristiti ih kao ključeve za spajanje. Ova automatska detekcija temelji se na heuristici koja u mnogim situacijama daje željene rezultate, ali nije uvijek pouzdana. Upravo zato je dobra praksa eksplicitno navoditi argument by, čak i kada očekujemo da će automatska detekcija raditi ispravno.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_names |&gt;\n  inner_join(pokemon_strength)\n\nJoining with `by = join_by(id, name)`\n\n\n# A tibble: 7 × 5\n     id name      type_1   special_attack special_defense\n  &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;             &lt;dbl&gt;           &lt;dbl&gt;\n1     1 bulbasaur grass                65              65\n2    19 rattata   normal               25              35\n3    25 pikachu   electric             50              50\n4    48 venonat   bug                  40              55\n5   111 rhyhorn   ground               30              30\n6   150 mewtwo    psychic             154              90\n7   257 blaziken  fire                110              70\n\n\nKada izvršimo ovu naredbu, R automatski prepoznaje da obje tablice imaju zajedničku varijablu “id” i “name” te ju koristi kao ključ za spajanje. U konzoli ćemo vidjeti poruku koja potvrđuje ovaj automatski odabir: Joining with 'by = join_by(id)'. Rezultat će biti podatkovni okvir koji sadrži sve Pokemone iz pokemon_names (svi redci su zadržani) obogaćen dodatnim stupcima “special_attack” i “special_defense” iz podatkovnog okvira pokemon_strength.\n\n\n\nKonačno, ponekad je potrebno pridružiti podatke gdje ključevi imaju različita imena u dva podatkovna okvira. Na primjer, možda imamo podatkovni okvir u kojem se Pokemon ID nalazi pod nazivom “pokemon_id”, a u drugom samo “id”. U ovom primjeru koristimo sintaksu join_by(pokemon_id == id) koja jasno specificira da stupac “pokemon_id” iz prvog okvira odgovara stupcu “id” iz drugog okvira.\n\n\n0.2.2.2 Sufiksi\nArgument suffix u glagolima za pridruživanje podatkovnih okvira služi za razlikovanje stupaca koji imaju identična imena u oba podatkovna okvira, ali nisu korišteni kao ključevi za spajanje. Kada R spaja dva podatkovna okvira, svi stupci iz oba izvora zadržavaju se u konačnom rezultatu. Međutim, ako oba podatkovna okvira sadrže stupac s istim nazivom, R mora dodati oznake tim stupcima kako bi ih razlikovao. Argument suffix prima vektor od dva tekstualna elementa gdje prvi element označava sufiks koji će se dodati stupcima iz prvog podatkovnog okvira (x), a drugi element označava sufiks za stupce iz drugog podatkovnog okvira (y). Na ovaj način, korisnik može kontrolirati kako će se duplicirani nazivi stupaca razlikovati u konačnom rezultatu čineći kod čitljivijim i smislenijim.\nAko se argument ne navede, R će automatski primijeniti zadane sufikse koji su .x za stupce iz prvog podatkovnog okvira i .y za stupce iz drugog podatkovnog okvira. Ovi zadani sufiksi relativno su neutralni i univerzalni, ali nisu uvijek najdeskriptivniji za specifičan kontekst analize.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nAko kreiramo podatkovni okvir gdje oba podatkovna okvira sadrže stupac “name”, ali se kombiniraju samo prema varijabli “id”, bez argumenta suffix, rezultat će imati stupce “name.x” (iz pokemon_names) i “name.y” (iz pokemon_strength). U drugom slučaju, ako je argument suffix s vrijednostima _elemental_df i _stat naveden, sufiks jasno označava da stupac dolazi iz pokemon_names podatkovnog okvira ako naziv stupca sadrži sufiks “_elemental_df” u nazivu ili pokemon_strength ako sadrži “_stat” sufiks u nazivu. Ovakvi nazivi čine kod daleko čitljivijim.\n\npokemon_names |&gt;\n  inner_join(pokemon_strength, join_by(id))\n\n# A tibble: 7 × 6\n     id name.x    type_1   name.y    special_attack special_defense\n  &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;    &lt;chr&gt;              &lt;dbl&gt;           &lt;dbl&gt;\n1     1 bulbasaur grass    bulbasaur             65              65\n2    19 rattata   normal   rattata               25              35\n3    25 pikachu   electric pikachu               50              50\n4    48 venonat   bug      venonat               40              55\n5   111 rhyhorn   ground   rhyhorn               30              30\n6   150 mewtwo    psychic  mewtwo               154              90\n7   257 blaziken  fire     blaziken             110              70\n\npokemon_names |&gt;\n  inner_join(pokemon_strength, join_by(id), suffix = c(\"_elemental_df\", \"_stat\"))\n\n# A tibble: 7 × 6\n     id name_elemental_df type_1   name_stat special_attack special_defense\n  &lt;dbl&gt; &lt;chr&gt;             &lt;fct&gt;    &lt;chr&gt;              &lt;dbl&gt;           &lt;dbl&gt;\n1     1 bulbasaur         grass    bulbasaur             65              65\n2    19 rattata           normal   rattata               25              35\n3    25 pikachu           electric pikachu               50              50\n4    48 venonat           bug      venonat               40              55\n5   111 rhyhorn           ground   rhyhorn               30              30\n6   150 mewtwo            psychic  mewtwo               154              90\n7   257 blaziken          fire     blaziken             110              70\n\n\nKonačno, ako u argumentu by definiramo dva ključa za pridruživanje, u ovom slučaju i “id” i “name”, neće biti potrebno definiranje sufiksa jer se neće stvarati dupli stupci za podatke o imenima Pokemona.\n\n\n\n\n\n0.2.2.3 Nejednako pridruživanje\nDo su bila navedena samo jednaka pridruživanja, odnosno ona pridruživanja gdje se redci podudaraju ako je ključ iz x jednak ključu iz y argumenta. Ipak, postoje i drugi načini određivanja podudarnosti između parova redaka.\nU jednakim pridruživanjima ključevi iz x i y uvijek su jednaki pa je dovoljno prikazati samo jedan ključ u rezultatu. Međutim, kod nejednakih pridruživanja ključevi mogu imati različite vrijednosti što znači da je potrebno prikazati oba ključa što se kod *_join() glagola omogućuje postavljanjem argumenta keep = TRUE.\ndplyr identificira četiri posebno korisne vrste nejednakih pridruživanja:\n\nkrižna pridruživanja koja podudaruju svaki par redaka;\nnejednakosna pridruživanja s operatorima &lt;, &lt;=, &gt; i &gt;= umjesto ==;\nklizna pridruživanja koja pronalaze samo najbližu podudarnost te\npreklopna pridruživanja koja se koriste za rad s rasponima vrijednosti.\n\n\n0.2.2.3.1 Nejednakosno pridruživanja\nNejednakosna spajanja (engl. inequality joins) koriste operatore &lt;, &lt;=, &gt;= ili &gt; za ograničavanje skupa mogućih podudarnosti.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nJedan koristan primjer s Pokemon podacima bio bi rangiranje Pokemona prema njihovoj ukupnoj snazi. Pretpostavimo da želimo za svakog Pokemona pronaći sve one koji su jači od njega.\n\n# Priprema podataka - izračun ukupne snage\npokemon_power &lt;- pokemon_dataset |&gt;\n  mutate(total_power = attack + defense + special_attack + special_defense) |&gt;\n  select(name, total_power) |&gt;\n  arrange(desc(total_power))\n\n# Nejednakosno spajanje - pronalaženje svih jačih protivnika\nstronger_pokemon &lt;- pokemon_power |&gt;\n  inner_join(pokemon_power, by = join_by(total_power &lt; total_power), suffix = c(\"_base\", \"_opponent\"))\n\n# Brojanje jačih Pokemona i izračun ranga\npokemon_ranking &lt;- stronger_pokemon |&gt;\n  group_by(name_base, total_power_base) |&gt;\n  summarise(\n    stronger_count = n(),\n    .groups = \"drop\"\n  ) |&gt;\n  mutate(rank = stronger_count + 1) |&gt;\n  arrange(rank)\n\n# Pregled podataka\npokemon_ranking\n\n# A tibble: 798 × 4\n   name_base               total_power_base stronger_count  rank\n   &lt;chr&gt;                              &lt;dbl&gt;          &lt;int&gt; &lt;dbl&gt;\n 1 rayquazamega rayquaza                560              2     3\n 2 mewtwomega mewtwo x                  544              3     4\n 3 dianciemega diancie                  540              4     5\n 4 mewtwomega mewtwo y                  534              5     6\n 5 tyranitarmega tyranitar              529              6     7\n 6 hoopahoopa unbound                   520              7     8\n 7 aggronmega aggron                    510              8     9\n 8 latiasmega latias                    510              8     9\n 9 latiosmega latios                    510              8     9\n10 metagrossmega metagross              510              8     9\n# ℹ 788 more rows\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nDrugi praktični primjer je kategorizacija Pokemona po razinama snage. Pretpostavimo da želimo razvrstati Pokemone u kategorije “Slabiji”, “Srednji” i “Jači” na temelju njihovog napada, a zatim pronaći sve Pokemone u tim kategorijama.\n\n# Definiranje granica kategorija\npower_tiers &lt;- data.frame(\n  tier_name = c(\"Weak\", \"Middle\", \"Strong\"),\n  min_attack = c(0, 50, 100),\n  max_attack = c(49, 99, 200)\n)\n\n# Kategorizacija Pokemona prema snazi napada\npokemon_dataset |&gt;\n  inner_join(power_tiers, join_by(attack &gt;= min_attack, attack &lt;= max_attack)) |&gt;\n  select(name, attack, tier_name) |&gt;\n  arrange(attack)\n\n# A tibble: 800 × 3\n   name     attack tier_name\n   &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;    \n 1 chansey       5 Weak     \n 2 happiny       5 Weak     \n 3 magikarp     10 Weak     \n 4 shuckle      10 Weak     \n 5 blissey      10 Weak     \n 6 feebas       15 Weak     \n 7 metapod      20 Weak     \n 8 abra         20 Weak     \n 9 ledyba       20 Weak     \n10 togepi       20 Weak     \n# ℹ 790 more rows\n\n\n\n\n\n\n\n0.2.2.3.2 Klizna spajanja\nKlizna spajanja (engl. rolling joins) predstavljaju poseban tip nejednakosnih spajanja gdje umjesto dobivanja svakog retka koji zadovoljava nejednakost, dobivamo samo najbliži redak. Bilo koje nejednakosno spajanje možemo pretvoriti u klizno spajanje dodavanjem funkcije closest().\nKlizna spajanja posebno su korisna kada imamo dva podatkovna okvira s datumima koji se ne poklapaju savršeno i želimo pronaći najbliži datum u jednom podatkovnom okviru koji dolazi prije ili nakon nekog datuma u drugom podatkovnom okviru.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nZa demonstraciju kliznog spajanja s Pokemon podacima, zamislimo scenarij gdje imamo podatke o Pokemon generacijama i želimo svakom Pokemonu dodijeliti generaciju u kojoj je predstavljen. Stvorit ćemo tablicu generacija i koristit ćemo klizno spajanje za pronalaženje odgovarajuće generacije:\n\n# Tablica s godinama predstavljanja generacija\npokemon_generations &lt;- data.frame(\n  generation = c(1, 2, 3, 4, 5, 6),\n  year_introduced = c(1996, 1999, 2002, 2006, 2010, 2013),\n  generation_name = c(\"Kanto\", \"Johto\", \"Hoenn\", \"Sinnoh\", \"Unova\", \"Kalos\")\n)\n\n# Simulirajmo podatke o godinama predstavljanja Pokemona\npokemon_with_years &lt;- pokemon_dataset |&gt;\n  filter(id &lt;= 20) |&gt;\n  mutate(\n    introduced_year = case_when(\n      generation == 1 ~ 1996,\n      generation == 2 ~ 1999,\n      generation == 3 ~ 2002,\n      generation == 4 ~ 2006,\n      generation == 5 ~ 2010,\n      generation == 6 ~ 2013,\n      TRUE ~ NA_real_\n    )\n  ) |&gt;\n  select(id, name, generation, introduced_year)\n\n# Klizno spajanje za pronalaženje odgovarajuće generacije\npokemon_with_generation &lt;- pokemon_with_years |&gt;\n  left_join(pokemon_generations, join_by(closest(introduced_year &gt;= year_introduced)))\n\n# Prikaz rezultata\npokemon_with_generation\n\n# A tibble: 26 × 7\n      id name          generation.x introduced_year generation.y year_introduced\n   &lt;dbl&gt; &lt;chr&gt;         &lt;fct&gt;                  &lt;dbl&gt;        &lt;dbl&gt;           &lt;dbl&gt;\n 1     1 bulbasaur     1                       1996            1            1996\n 2     2 ivysaur       1                       1996            1            1996\n 3     3 venusaur      1                       1996            1            1996\n 4     3 venusaurmega… 1                       1996            1            1996\n 5     4 charmander    1                       1996            1            1996\n 6     5 charmeleon    1                       1996            1            1996\n 7     6 charizard     1                       1996            1            1996\n 8     6 charizardmeg… 1                       1996            1            1996\n 9     6 charizardmeg… 1                       1996            1            1996\n10     7 squirtle      1                       1996            1            1996\n# ℹ 16 more rows\n# ℹ 1 more variable: generation_name &lt;chr&gt;\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nDrugi primjer kliznog spajanja mogao bi uključivati usporedbu statistika Pokemona. Pretpostavimo da želimo za svakog Pokemona pronaći onog s najbližom vrijednošću napada.\n\n# Pronalaženje Pokemona s najbližom vrijednošću napada\nclosest_attack &lt;- pokemon_dataset |&gt;\n  left_join(\n    pokemon_dataset,\n    join_by(closest(attack &gt;= attack)),\n    suffix = c(\"_original\", \"_closest\")\n  )\n\n# Prikaz rezultata\nclosest_attack |&gt;\n  select(name_original, attack_original, name_closest, attack_closest)\n\n# A tibble: 16,916 × 4\n   name_original attack_original name_closest attack_closest\n   &lt;chr&gt;                   &lt;dbl&gt; &lt;chr&gt;                 &lt;dbl&gt;\n 1 bulbasaur                  49 bulbasaur                49\n 2 bulbasaur                  49 chikorita                49\n 3 bulbasaur                  49 finneon                  49\n 4 ivysaur                    62 ivysaur                  62\n 5 ivysaur                    62 nidorina                 62\n 6 ivysaur                    62 bayleef                  62\n 7 ivysaur                    62 snover                   62\n 8 venusaur                   82 venusaur                 82\n 9 venusaur                   82 golduck                  82\n10 venusaur                   82 meganium                 82\n# ℹ 16,906 more rows\n\n\n\n\n\n\n\n0.2.2.3.3 Križna pridruživanja\nKrižno pridruživanja (engl. cross join) podudara sve kombinacije redaka generirajući Kartezijev produkt redaka. To znači da će rezultat imati nrow(x) * nrow(y) redaka. Križna pridruživanja korisna su prilikom generiranja svih mogućih kombinacija podudaranja.\nOna koriste drugačiju funkciju jer ne postoji razlika između unutarnjeg, lijevog, desnog i potpunog pridruživanja kada se podudara svaki redak, nego se koristi funkcija cross_join() koja direktno kreira Kartezijev produkt bez obzira na vrijednosti u stupcima.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nZamislimo scenarij u kojem organiziramo Pokemon turnir gdje se svaki Pokemon mora boriti protiv svakog drugog Pokemona iz podatkovnog okvira pokemon_names. Ograničit ćemo turnir na samo četiri Pokemona: Bulbasaur, Charmander, Squirtle i Pikachu. Ovo je klasičan primjer situacije gdje je križno spajanje idealno rješenje koje se ostvaruje funkcijom cross_join().\n\n# Definiranje podatkovnog okvira s Pokemonima\ntournament_pokemon &lt;- pokemon_dataset |&gt;\n  filter(name %in% c(\"bulbasaur\", \"charmander\", \"squirtle\", \"pikachu\")) |&gt;\n  select(id, name)\n\n# Križno pridruživanje\nall_tournament_matches &lt;- tournament_pokemon |&gt;\n  cross_join(tournament_pokemon, suffix = c(\"_1\", \"_2\"))\n\n# Pregled podataka\nall_tournament_matches\n\n# A tibble: 16 × 4\n    id_1 name_1      id_2 name_2    \n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;     \n 1     1 bulbasaur      1 bulbasaur \n 2     1 bulbasaur      4 charmander\n 3     1 bulbasaur      7 squirtle  \n 4     1 bulbasaur     25 pikachu   \n 5     4 charmander     1 bulbasaur \n 6     4 charmander     4 charmander\n 7     4 charmander     7 squirtle  \n 8     4 charmander    25 pikachu   \n 9     7 squirtle       1 bulbasaur \n10     7 squirtle       4 charmander\n11     7 squirtle       7 squirtle  \n12     7 squirtle      25 pikachu   \n13    25 pikachu        1 bulbasaur \n14    25 pikachu        4 charmander\n15    25 pikachu        7 squirtle  \n16    25 pikachu       25 pikachu   \n\n\nFunkcije cross_join() stvara 225 redaka koji predstavljaju sve moguće kombinacije borbi. Argument suffix = c(\"_1\", \"_2\") dodaje sufikse stupcima kako bi razlikovali prvog borca (“_1”) od drugog borca (“_2”).\nIpak, rezultati uključuju i borbe protiv samog sebe, primjerice Bulbasaur protiv Bulbasaura (redak 1), i duplikate prema različitom redoslijedu, primjerice Bulbasaur protiv Charmander (redak 2) i Charmander protiv Bulbasaura (redak 5).\nBorbe samih protiv sebe eliminiraju se glagolom filter() iz dplyr paketa i logičkim operatorom != čime je moguće eliminirati retke u kojima su dvije vrijednosti u dvije varijable iste. Ovdje je zapravo riječ o obliku nejednakosnog pridruživanja.\n\n# Eliminiranje borbi samih protiv sebe\nvalid_tournament_matches &lt;- all_tournament_matches |&gt;\n  filter(id_1 != id_2)\n\n# Pregled podataka\nvalid_tournament_matches\n\n# A tibble: 12 × 4\n    id_1 name_1      id_2 name_2    \n   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;     \n 1     1 bulbasaur      4 charmander\n 2     1 bulbasaur      7 squirtle  \n 3     1 bulbasaur     25 pikachu   \n 4     4 charmander     1 bulbasaur \n 5     4 charmander     7 squirtle  \n 6     4 charmander    25 pikachu   \n 7     7 squirtle       1 bulbasaur \n 8     7 squirtle       4 charmander\n 9     7 squirtle      25 pikachu   \n10    25 pikachu        1 bulbasaur \n11    25 pikachu        4 charmander\n12    25 pikachu        7 squirtle  \n\n\nŠto se tiče duplikata, možemo koristiti nejednako pridruživanje s operatorom &lt; kako bismo generirali samo jedinstvene kombinacije unutar funkcije join_by() u by argumentu.\n\n# Eliminiranje duplikata\nunique_matches &lt;- tournament_pokemon |&gt;\n  inner_join(tournament_pokemon, join_by(id &lt; id), suffix = c(\"_1\", \"_2\"))\n\n# Pregled podataka\nunique_matches\n\n# A tibble: 6 × 4\n   id_1 name_1      id_2 name_2    \n  &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;     \n1     1 bulbasaur      4 charmander\n2     1 bulbasaur      7 squirtle  \n3     1 bulbasaur     25 pikachu   \n4     4 charmander     7 squirtle  \n5     4 charmander    25 pikachu   \n6     7 squirtle      25 pikachu   \n\n\n\n\n\n———————————–NASTAVAK—————————–\n\n\n0.2.2.3.4 Preklopna spajanja\nPreklopna spajanja (engl. overlap joins) pružaju tri pomoćne funkcije koje koriste nejednakosna spajanja kako bi olakšale rad s intervalima vrijednosti:\n\nbetween(x, y_lower, y_upper) je skraćenica za x &gt;= y_lower, x &lt;= y_upper,\nwithin(x_lower, x_upper, y_lower, y_upper) je skraćenica za x_lower &gt;= y_lower, x_upper &lt;= y_upper i\noverlaps(x_lower, x_upper, y_lower, y_upper) je skraćenica za x_lower &lt;= y_upper, x_upper &gt;= y_lower.\n\nPreklopna spajanja omogućuju elegantan način rada s intervalima i rasponima vrijednosti čineći kod čitljivijim i izražajnijim u usporedbi s eksplicitnim navođenjem svih nejednakosnih uvjeta. Ova tehnika posebno je korisna u situacijama gdje trebamo kategorizirati kontinuirane varijable ili pronalaziti preklapanja između vremenskih perioda, geografskih regija ili bilo kojih drugih raspon vrijednosti.\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\nDemonstrirajmo preklopna spajanja s Pokemon podacima kategorizirajući Pokemone prema njihovim statistikama.\nStvorit ćemo raspone za različite razine snage i koristiti between() za razvrstavanje.\n\n# Definiranje raspon razina za HP (hit points)\nhp_tiers &lt;- data.frame(\n  tier_name = c(\"Low HP\", \"Middle HP\", \"High HP\", \"Highest HP\"),\n  hp_min = c(0, 50, 80, 120),\n  hp_max = c(49, 79, 119, 255)\n)\n\n# Preklopno spajanje koristeći between()\npokemon_dataset |&gt;\n  inner_join(hp_tiers, join_by(between(HP, hp_min, hp_max))) |&gt;\n  select(name, HP, tier_name) |&gt;\n  arrange(desc(HP))\n\n# A tibble: 800 × 3\n   name                     HP tier_name \n   &lt;chr&gt;                 &lt;dbl&gt; &lt;chr&gt;     \n 1 blissey                 255 Highest HP\n 2 chansey                 250 Highest HP\n 3 wobbuffet               190 Highest HP\n 4 wailord                 170 Highest HP\n 5 alomomola               165 Highest HP\n 6 snorlax                 160 Highest HP\n 7 slaking                 150 Highest HP\n 8 drifblim                150 Highest HP\n 9 giratinaaltered forme   150 Highest HP\n10 giratinaorigin forme    150 Highest HP\n# ℹ 790 more rows\n\n\nFunkcija overlaps() posebno je korisna za pronalaženje preklapanja između raspona. Pretpostavimo da želimo identificirati Pokemone čiji se rasponi snage (definiran kao minimum i maksimum njihovih napada i obrane) preklapaju.\n\n# Stvaranje raspon snage za nekoliko Pokemona\npokemon_power_ranges &lt;- pokemon_dataset |&gt;\n  mutate(\n    power_min = pmin(attack, defense),\n    power_max = pmax(attack, defense)\n  ) |&gt;\n  select(id, name, power_min, power_max)\n\n# Pronalaženje Pokemona s preklapajućim rasponima snage\npokemon_power_ranges |&gt;\n  inner_join(\n    pokemon_power_ranges,\n    join_by(overlaps(power_min, power_max, power_min, power_max), id &lt; id),\n    suffix = c(\"_1\", \"_2\")\n  ) |&gt;\n  select(name_1, power_min_1, power_max_1, name_2, power_min_2, power_max_2)\n\n# A tibble: 149,844 × 6\n   name_1    power_min_1 power_max_1 name_2              power_min_2 power_max_2\n   &lt;chr&gt;           &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;       &lt;dbl&gt;\n 1 bulbasaur          49          49 charmander                   43          52\n 2 bulbasaur          49          49 squirtle                     48          65\n 3 bulbasaur          49          49 metapod                      20          55\n 4 bulbasaur          49          49 butterfree                   45          50\n 5 bulbasaur          49          49 kakuna                       25          50\n 6 bulbasaur          49          49 beedrill                     40          90\n 7 bulbasaur          49          49 beedrillmega beedr…          40         150\n 8 bulbasaur          49          49 rattata                      35          56\n 9 bulbasaur          49          49 spearow                      30          60\n10 bulbasaur          49          49 ekans                        44          60\n# ℹ 149,834 more rows",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Pridruživanje podataka</span>"
    ]
  },
  {
    "objectID": "03_04_brojevi.html",
    "href": "03_04_brojevi.html",
    "title": "7  Brojevi",
    "section": "",
    "text": "1 Brojčane transformacije\nBrojčani podaci predstavljaju temelj znanosti o podacima i statistike općenito. Numerički vektori čine okosnicu gotovo svih analiza podataka te su ključni za izgradnju prediktivnih modela i donošenje odluka temeljenih na podacima. Brojevi omogućuju kvantifikaciju stvarnosti, mjerenje promjena, usporedbu između različitih entiteta te otkrivanje skrivenih obrazaca u podacima.\nU kontekstu analize podataka, brojčani podaci koriste se za mjerenje različitih varijabli od interesa, bilo da se radi o financijskim prihodima tvrtke, demografskim karakteristikama populacije ili performansnim metrikama modela strojnog učenja. U svim ovim slučajevima numerički vektori su fundamentalni građevni blokovi analize podataka te se koriste u svim fazama projekta, od početnog istraživanja podataka do finalnog modeliranja.\nVažnost brojeva očituje se kroz nekoliko ključnih dimenzija. Prvo, brojevi omogućuju precizno mjerenje i kvantifikaciju fenomena. Umjesto kvalitativnih opisa poput “visoka cijena” ili “niska prodaja”, numerički podaci omogućuju precizne vrijednosti koje se mogu uspoređivati, kombinirati i analizirati matematičkim metodama. Drugo, brojevi služe kao osnova za primjenu statističkih testova i procedura koje omogućuju donošenje zaključaka temeljenih na dokazima umjesto na intuiciji ili pretpostavkama. Treće, numerički podaci omogućuju primjenu algoritama strojnog učenja koji otkrivaju složene obrasce i relacije u podacima koje bi ljudska analiza teško mogla detektirati.\nKada govorimo o Pokemon datasetu, varijable poput “HP”, “attack”, “defense” i “speed” predstavljaju numeričke vrijednosti koje opisuju različite karakteristike Pokemona. Ove brojčane vrijednosti omogućuju nam provedbu raznovrsnih analiza, od jednostavnih deskriptivnih statistika (prosječna snaga napada po generaciji) do složenijih prediktivnih modela (predviđanje je li Pokemon legendarni na temelju njegovih statističkih atributa).\nU većini slučajeva brojevi u R-u dolaze već spremni za analizu iz podatkovnih okvira koje učitavamo pomoću funkcija poput read_csv() iz paketa readr. Međutim, postoje situacije u kojima je potrebno stvoriti brojeve iz drugih vrsta podataka ili ih pretvoriti iz različitih formata.\nKada učitavamo podatke iz CSV datoteka, readr paket koristi heuristiku koja pokušava automatski prepoznati tip podataka u svakom stupcu. Ako stupac sadrži samo brojeve i možda posebne vrijednosti kao što su NA, readr će ga automatski parsirati kao numerički vektor. Na primjer, u pokemon_dataset podatkovnom okviru varijable poput “HP”, “attack”, “defense”, “special_attack”, “special_defense” i “speed” automatski se prepoznaju kao numeričke vrijednosti jer sadrže isključivo brojčane podatke koje predstavljaju različite statističke karakteristike Pokemona.\nPonekad se dogodi da podaci koji bi trebali biti brojevi budu učitani kao znakovni nizovi ili karakteri. To se najčešće događa kada su brojevi u izvornoj datoteci formatirani na poseban način, primjerice kada sadrže zareze kao separatore tisućica, valutne simbole, postotke ili druge ne-numeričke znakove. U takvim situacijama R ne može automatski prepoznati brojčanu prirodu podataka i tretira ih kao tekst. Za pretvaranje takvih znakovnih nizova u brojeve koristi se funkcija parse_number() iz paketa readr koja je dizajnirana da izvuče brojčane vrijednosti ignorirajući sve ne-numeričke znakove koji okružuju broj.\nVažno je napomenuti da parse_number() radi tako što ignorira sve ne-numeričke znakove prije i poslije broja, ali zadržava decimalnu točku i negativni predznak ako postoje. Ova funkcija je posebno korisna pri čišćenju podataka koji dolaze iz različitih izvora gdje numerički podaci nisu standardizirano formatirani, što omogućava brzu i jednostavnu pretvorbu u format pogodan za daljnju analizu i vizualizaciju.\nIznenađujuće je koliko se analize podataka može provesti samo pomoću brojanja i osnovnih aritmetičkih operacija, stoga paket dplyr nastoji učiniti brojanje što jednostavnijim putem funkcije count(). Ova funkcija predstavlja moćan alat za brzu eksploraciju podataka i provjeru tijekom analize, omogućujući istraživačima da brzo dobiju uvid u distribuciju vrijednosti unutar podatkovnog okvira.\nVažno je napomenuti da ako želimo vidjeti sve vrijednosti u rezultatu funkcije count(), možemo koristiti |&gt; View() za otvaranje interaktivnog pregleda u RStudio-u ili |&gt; print(n = Inf) za ispisivanje svih redaka u konzoli. Ovo je korisno kada radimo s varijablama koje imaju umjeren broj jedinstvenih vrijednosti i želimo dobiti potpun pregled distribucije. Istu računsku operaciju možemo postići “ručno” koristeći kombinaciju funkcija group_by(), summarize() i specijalne funkcije n():\nOvaj pristup je koristan jer omogućuje istovremeno računanje drugih sažetaka uz brojanje. Funkcija n() je posebna funkcija sažimanja koja ne prima nikakve argumente, već pristupa informacijama o trenutnoj grupi podataka. To znači da funkcionira samo unutar dplyr funkcija poput mutate(), filter() i group_by(). Ako pokušamo koristiti n() izvan konteksta ovih funkcija, dobit ćemo grešku. Primjerice, možemo brojati Pokémone po vrsti i istovremeno izračunati prosječnu snagu napada:\nOvaj kod grupira Pokémone prema njihovoj primarnoj vrsti, broji koliko ih ima u svakoj grupi pomoću n(), i izračunava prosječnu vrijednost napada za svaku grupu.\nPostoji nekoliko varijanti funkcija n() i count() koje mogu biti korisne u različitim situacijama. Funkcija n_distinct() broji broj različitih, odnosno jedinstvenih vrijednosti jedne ili više varijabli. Na primjer, možemo saznati koliko različitih generacija Pokémona postoji za svaku vrstu:\nOvaj pristup omogućuje identificiranje vrsta Pokémona koje su prisutne kroz više generacija igara.\nPonderirano brojanje predstavlja još jednu korisnu varijantu standardnog brojanja. Zapravo, ponderirano brojanje je suma određene varijable. Primjerice, mogli bismo “prebrojati” ukupnu snagu svih Pokémona određene vrste zbrajajući njihove vrijednosti napada:\nBudući da je ponderirano brojanje čest problem u analizi podataka, funkcija count() ima argument wt koji omogućuje istu operaciju na jednostavniji način:\nOvaj pristup je elegantniji i čitljiviji od eksplicitnog korištenja group_by() i summarize().\nMožemo brojati i nedostajuće vrijednosti kombiniranjem funkcija sum() i is.na(). Primjerice, ako želimo saznati koliko Pokémona u svakoj generaciji ima nedostajuće podatke o tipu 2, možemo koristiti:\nOvaj pristup koristi činjenicu da is.na() vraća logičku vrijednost (TRUE ili FALSE), a sum() tretira TRUE kao 1 i FALSE kao 0, što rezultira brojem nedostajućih vrijednosti. U kontekstu pokemon_dataset podatkovnog okvira, analiza nedostajućih vrijednosti može otkriti probleme s kvalitetom podataka ili sistematske razlike između generacija u dostupnosti određenih informacija o Pokémonima.\nFunkcije transformacije dobro funkcioniraju s mutate() jer njihov rezultat ima istu duljinu kao ulazni podaci. Velika većina funkcija transformacije već je ugrađena u osnovni R. Nepraktično je navesti sve takve funkcije, stoga će ovo poglavlje prikazati najkorisnije od njih. Kao primjer, iako R pruža sve trigonometrijske funkcije koje biste mogli zamisliti, one ovdje nisu navedene jer se rijetko koriste u analizi podataka.\nAritmetika i pravila recikliranja\nOsnove aritmetike (+, -, *, /, ^) često se koriste pri radu s podacima. Ove funkcije ne zahtijevaju opsežno objašnjenje jer izvršavaju operacije koje su poznate iz osnovne matematike. Međutim, potrebno je kratko razmotriti pravila recikliranja koja određuju što se događa kada lijeva i desna strana operacije imaju različite duljine. Ovo je važno za operacije poput pokemon_dataset |&gt; mutate(attack_per_gen = attack / generation) jer postoji 800 brojeva na lijevoj strani operatora /, ali samo šest različitih vrijednosti generacija na desnoj strani.\nR rješava neusklađene duljine vektora pomoću recikliranja, odnosno ponavljanja kraćeg vektora. Ovu operaciju možemo lakše vidjeti ako stvorimo vektore izvan podatkovnog okvira:\nOpćenito, poželjno je reciklirati samo pojedinačne brojeve (odnosno vektore duljine 1), ali R će reciklirati bilo koji kraći vektor. Obično (ali ne uvijek) R daje upozorenje ako duži vektor nije višekratnik kraćeg vektora:\nOva pravila recikliranja primjenjuju se i na logičke usporedbe (==, &lt;, &lt;=, &gt;, &gt;=, !=) i mogu dovesti do iznenađujućih rezultata ako slučajno koristite == umjesto %in% i podatkovni okvir ima nepovoljan broj redaka. Na primjer, uzmimo ovaj kod koji pokušava pronaći sve Pokémone iz prve i druge generacije:\nKod se izvršava bez greške, ali ne vraća ono što želimo. Zbog pravila recikliranja, ovaj kod pronalazi Pokémone u redovima s neparnim brojevima koji su iz generacije 1 i Pokémone u redovima s parnim brojevima koji su iz generacije 2. Nažalost, nema upozorenja jer pokemon_dataset ima paran broj redaka.\nDa bi se zaštitili od ovakvog tihog neuspjeha, većina tidyverse funkcija koristi strožu formu recikliranja koja reciklira samo pojedinačne vrijednosti. Nažalost, to ne pomaže u ovom slučaju, niti u mnogim drugim, jer se ključni izračun provodi osnovnom R funkcijom ==, a ne filter(). Ispravno rješenje za ovaj problem je korištenje operatora %in%:\nMinimum i maksimum\nAritmetičke funkcije rade s parovima varijabli. Dvije usko povezane funkcije su pmin() i pmax() koje, kada im se daju dvije ili više varijabli, vraćaju najmanju ili najveću vrijednost u svakom retku:\nOvaj primjer pokazuje kako možemo usporediti napad i obranu svakog Pokémona i identificirati koja je statistika niža, a koja viša.\nVažno je razlikovati ove funkcije od funkcija sažimanja min() i max() koje uzimaju više opservacija i vraćaju jednu vrijednost. Možete prepoznati da ste koristili pogrešnu formu kada su svi minimumi i svi maksimumi iste vrijednosti:\nU ovom slučaju, min() i max() vraćaju globalni minimum i maksimum svih vrijednosti napada i obrane u cijelom podatkovnom skupu, što nije željeni rezultat.\nModularna aritmetika\nModularna aritmetika je tehnički naziv za vrstu matematike koju ste radili prije nego što ste naučili o decimalnim brojevima, odnosno dijeljenje koje daje cijeli broj i ostatak. U R-u, %/% izvodi cjelobrojno dijeljenje, a %% izračunava ostatak:\nModularna aritmetika je korisna u pokemon_dataset podatkovnom okviru jer je možemo koristiti za kategorizaciju Pokémona. Na primjer, možemo grupirati Pokémone prema tome da li je njihov broj djeljiv s 10, što bi moglo otkriti obrazac u dizajnu:\nMožemo kombinirati modularnu aritmetiku s mean(is.na(x)) trikom za analizu proporcija. Na primjer, možemo vidjeti kako se proporcija legendarnih Pokémona mijenja kroz generacije:\nRezultati pokazuju da proporcija legendarnih Pokémona varira između generacija, s nešto većim udjelom u kasnijim generacijama.\nLogaritmi\nLogaritmi su izuzetno korisna transformacija za rad s podacima koji se protežu kroz više redova veličine i za pretvaranje eksponencijalnog rasta u linearni rast. U R-u možete odabrati između tri logaritma: log() (prirodni logaritam, baza e), log2() (baza 2) i log10() (baza 10). Preporučuje se korištenje log2() ili log10(). Funkcija log2() je laka za interpretaciju jer razlika od 1 na logaritamskoj skali odgovara udvostručenju na originalnoj skali, a razlika od -1 odgovara prepolovljenju. Funkcija log10() je laka za povratnu transformaciju jer je, na primjer, 3 jednako 10^3 = 1000. Inverzna funkcija za log() je exp(), a za izračun inverzne funkcije za log2() ili log10() potrebno je koristiti 2^ ili 10^.\nU kontekstu pokemon_dataset podatkovnog okvira, logaritamska transformacija može biti korisna za analizu statistika koje imaju širok raspon vrijednosti:\nOva transformacija može pomoći u vizualizaciji podataka kada postoje ekstremne vrijednosti ili kada želimo usporediti relativne, a ne apsolutne razlike između Pokémona.\nZaokruživanje\nFunkcija round() zaokružuje broj na najbliži cijeli broj:\nPreciznost zaokruživanja možete kontrolirati pomoću drugog argumenta digits. Funkcija round(x, digits) zaokružuje na najbliži 10^-n, tako da digits = 2 zaokružuje na najbliže 0.01. Ova definicija je korisna jer implicira da će round(x, -3) zaokružiti na najbližu tisuću:\nPostoji jedna neobičnost kod round() koja na prvi pogled izgleda iznenađujuće: ova funkcija koristi ono što je poznato kao “zaokruživanje polovice na parno” ili bankovno zaokruživanje. Ako je broj točno na sredini između dva cijela broja, zaokružit će se na parni broj. Ovo je dobra strategija jer održava zaokruživanje nepristranim: polovica svih 0.5 vrijednosti zaokružuje se prema gore, a polovica prema dolje:\nFunkcija round() uparena je s floor() koja uvijek zaokružuje prema dolje i ceiling() koja uvijek zaokružuje prema gore:\nOve funkcije nemaju argument digits, stoga možete umjesto toga skalirati prema dolje, zaokružiti, a zatim skalirati natrag:\nIstu tehniku možete koristiti ako želite zaokružiti na višekratnik nekog drugog broja:\nU kontekstu pokemon_dataset podatkovnog okvira, zaokruživanje može biti korisno za kategorizaciju statistika:\nRezanje brojeva u raspone\nFunkcija cut() koristi se za razbijanje (odnosno biniranje) numeričkog vektora u diskretne kategorije:\nGranice ne moraju biti jednako raspoređene:\nMožete opcionalno definirati vlastite oznake (labels). Imajte na umu da bi trebalo biti za jednu oznaku manje nego što ima granica:\nBilo koje vrijednosti izvan raspona granica postat će NA:\nU pokemon_dataset podatkovnom okviru, cut() možemo koristiti za kategorizaciju Pokémona prema njihovim statistikama:\nOva analiza pokazuje da većina Pokémona ima prosječnu snagu napada (između 50 i 100), dok je samo manji broj izuzetno snažan.\nKumulativni i pomični agregati\nOsnovni R pruža cumsum(), cumprod(), cummin() i cummax() za tekuće ili kumulativne sume, produkte, minimume i maksimume. Paket dplyr pruža cummean() za kumulativne prosjeke. Kumulativne sume najčešće se koriste u praksi:\nAko trebate složenije pomične ili klizne agregate, pokušajte koristiti paket slider.\nU pokemon_dataset podatkovnom okviru možemo koristiti kumulativne funkcije za praćenje kako se ukupna snaga Pokémona akumulira kroz generacije:\nOvaj primjer pokazuje kako se ukupna snaga akumulira kroz prve Pokémone, a kumulativni prosjek pruža uvid u prosječnu snagu do određenog Pokémona u redoslijedu.",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Brojevi</span>"
    ]
  },
  {
    "objectID": "03_04_brojevi.html#brojčane-transformacije",
    "href": "03_04_brojevi.html#brojčane-transformacije",
    "title": "7  Brojevi",
    "section": "",
    "text": "NotePrimjer\n\n\n\n\n\n\nx &lt;- c(1, 2, 3, 4, 5, 6)\ny &lt;- c(10, 20)\nx * y\n\n[1]  10  40  30  80  50 120\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nx &lt;- c(1, 2, 3, 4, 5)\ny &lt;- c(10, 20)\nx * y\n\nWarning in x * y: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 10 40 30 80 50\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt; filter(generation == c(1, 2))\n\n# A tibble: 136 × 13\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1     1 bulbasaur       grass  poison   318    45     49      49             65\n 2     3 venusaur        grass  poison   525    80     82      83            100\n 3     4 charmander      fire   &lt;NA&gt;     309    39     52      43             60\n 4     6 charizard       fire   flying   534    78     84      78            109\n 5     6 charizardmega … fire   flying   634    78    104      78            159\n 6     8 wartortle       water  &lt;NA&gt;     405    59     63      80             65\n 7     9 blastoisemega … water  &lt;NA&gt;     630    79    103     120            135\n 8    11 metapod         bug    &lt;NA&gt;     205    50     20      55             25\n 9    13 weedle          bug    poison   195    40     35      30             20\n10    15 beedrill        bug    poison   395    65     90      40             45\n# ℹ 126 more rows\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt; filter(generation %in% c(1, 2))\n\n# A tibble: 272 × 13\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1     1 bulbasaur       grass  poison   318    45     49      49             65\n 2     2 ivysaur         grass  poison   405    60     62      63             80\n 3     3 venusaur        grass  poison   525    80     82      83            100\n 4     3 venusaurmega v… grass  poison   625    80    100     123            122\n 5     4 charmander      fire   &lt;NA&gt;     309    39     52      43             60\n 6     5 charmeleon      fire   &lt;NA&gt;     405    58     64      58             80\n 7     6 charizard       fire   flying   534    78     84      78            109\n 8     6 charizardmega … fire   dragon   634    78    130     111            130\n 9     6 charizardmega … fire   flying   634    78    104      78            159\n10     7 squirtle        water  &lt;NA&gt;     314    44     48      65             50\n# ℹ 262 more rows\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  mutate(\n    lower_stat = pmin(attack, defense),\n    higher_stat = pmax(attack, defense)\n  ) |&gt;\n  select(name, attack, defense, lower_stat, higher_stat)\n\n# A tibble: 800 × 5\n   name                      attack defense lower_stat higher_stat\n   &lt;chr&gt;                      &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n 1 bulbasaur                     49      49         49          49\n 2 ivysaur                       62      63         62          63\n 3 venusaur                      82      83         82          83\n 4 venusaurmega venusaur        100     123        100         123\n 5 charmander                    52      43         43          52\n 6 charmeleon                    64      58         58          64\n 7 charizard                     84      78         78          84\n 8 charizardmega charizard x    130     111        111         130\n 9 charizardmega charizard y    104      78         78         104\n10 squirtle                      48      65         48          65\n# ℹ 790 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  mutate(\n    lower_stat = min(attack, defense),\n    higher_stat = max(attack, defense)\n  ) |&gt;\n  select(name, attack, defense, lower_stat, higher_stat)\n\n# A tibble: 800 × 5\n   name                      attack defense lower_stat higher_stat\n   &lt;chr&gt;                      &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;\n 1 bulbasaur                     49      49          5         230\n 2 ivysaur                       62      63          5         230\n 3 venusaur                      82      83          5         230\n 4 venusaurmega venusaur        100     123          5         230\n 5 charmander                    52      43          5         230\n 6 charmeleon                    64      58          5         230\n 7 charizard                     84      78          5         230\n 8 charizardmega charizard x    130     111          5         230\n 9 charizardmega charizard y    104      78          5         230\n10 squirtle                      48      65          5         230\n# ℹ 790 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\n13 %/% 5\n\n[1] 2\n\n13 %% 5\n\n[1] 3\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  mutate(\n    divisible_by_10 = id %% 10 == 0\n  ) |&gt;\n  count(divisible_by_10)\n\n# A tibble: 2 × 2\n  divisible_by_10     n\n  &lt;lgl&gt;           &lt;int&gt;\n1 FALSE             716\n2 TRUE               84\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(generation) |&gt;\n  summarize(\n    prop_legendary = mean(legendary, na.rm = TRUE),\n    n = n()\n  )\n\n# A tibble: 6 × 3\n  generation prop_legendary     n\n  &lt;fct&gt;               &lt;dbl&gt; &lt;int&gt;\n1 1                  0.0361   166\n2 5                  0.0909   165\n3 3                  0.112    160\n4 4                  0.107    121\n5 2                  0.0472   106\n6 6                  0.0976    82\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  mutate(\n    log_hp = log10(HP),\n    log_attack = log10(attack)\n  ) |&gt;\n  select(name, HP, log_hp, attack, log_attack)\n\n# A tibble: 800 × 5\n   name                         HP log_hp attack log_attack\n   &lt;chr&gt;                     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n 1 bulbasaur                    45   1.65     49       1.69\n 2 ivysaur                      60   1.78     62       1.79\n 3 venusaur                     80   1.90     82       1.91\n 4 venusaurmega venusaur        80   1.90    100       2   \n 5 charmander                   39   1.59     52       1.72\n 6 charmeleon                   58   1.76     64       1.81\n 7 charizard                    78   1.89     84       1.92\n 8 charizardmega charizard x    78   1.89    130       2.11\n 9 charizardmega charizard y    78   1.89    104       2.02\n10 squirtle                     44   1.64     48       1.68\n# ℹ 790 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nround(123.456)\n\n[1] 123\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nround(123.456, 2)\n\n[1] 123.46\n\nround(123.456, -1)\n\n[1] 120\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nround(c(1.5, 2.5, 3.5, 4.5))\n\n[1] 2 2 4 4\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nfloor(123.456)\n\n[1] 123\n\nceiling(123.456)\n\n[1] 124\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nround(x / 10) * 10\n\n[1] 0 0 0 0 0\n\nfloor(x / 10) * 10\n\n[1] 0 0 0 0 0\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nround(x / 5) * 5\n\n[1] 0 0 5 5 5\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  mutate(\n    hp_rounded = round(HP, -1),\n    speed_category = round(speed / 25) * 25\n  ) |&gt;\n  select(name, HP, hp_rounded, speed, speed_category)\n\n# A tibble: 800 × 5\n   name                         HP hp_rounded speed speed_category\n   &lt;chr&gt;                     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;          &lt;dbl&gt;\n 1 bulbasaur                    45         40    45             50\n 2 ivysaur                      60         60    60             50\n 3 venusaur                     80         80    80             75\n 4 venusaurmega venusaur        80         80    80             75\n 5 charmander                   39         40    65             75\n 6 charmeleon                   58         60    80             75\n 7 charizard                    78         80   100            100\n 8 charizardmega charizard x    78         80   100            100\n 9 charizardmega charizard y    78         80   100            100\n10 squirtle                     44         40    43             50\n# ℹ 790 more rows\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nx &lt;- c(1, 5, 10, 15, 20)\ncut(x, breaks = c(0, 5, 10, 15, 20))\n\n[1] (0,5]   (0,5]   (5,10]  (10,15] (15,20]\nLevels: (0,5] (5,10] (10,15] (15,20]\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\ncut(x, breaks = c(0, 5, 15, 20))\n\n[1] (0,5]   (0,5]   (5,15]  (5,15]  (15,20]\nLevels: (0,5] (5,15] (15,20]\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\ncut(x, breaks = c(0, 5, 10, 15, 20), labels = c(\"very low\", \"low\", \"medium\", \"high\"))\n\n[1] very low very low low      medium   high    \nLevels: very low low medium high\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\ncut(x, breaks = c(5, 10, 15))\n\n[1] &lt;NA&gt;    &lt;NA&gt;    (5,10]  (10,15] &lt;NA&gt;   \nLevels: (5,10] (10,15]\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  mutate(attack_category = cut(attack, breaks = c(0, 50, 100, 150, 200), labels = c(\"weak\", \"average\", \"strong\", \"very strong\"))\n  ) |&gt;\n  select(name, attack, attack_category) |&gt;\n  count(attack_category)\n\n# A tibble: 4 × 2\n  attack_category     n\n  &lt;fct&gt;           &lt;int&gt;\n1 weak              170\n2 average           460\n3 strong            152\n4 very strong        18\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nx &lt;- 1:10\ncumsum(x)\n\n [1]  1  3  6 10 15 21 28 36 45 55\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  arrange(id) |&gt;\n  mutate(\n    cumulative_total = cumsum(total),\n    cumulative_mean = cummean(total)\n  ) |&gt;\n  select(id, name, total, cumulative_total, cumulative_mean) |&gt;\n  filter(id &lt;= 10)\n\n# A tibble: 14 × 5\n      id name                      total cumulative_total cumulative_mean\n   &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;            &lt;dbl&gt;           &lt;dbl&gt;\n 1     1 bulbasaur                   318              318            318 \n 2     2 ivysaur                     405              723            362.\n 3     3 venusaur                    525             1248            416 \n 4     3 venusaurmega venusaur       625             1873            468.\n 5     4 charmander                  309             2182            436.\n 6     5 charmeleon                  405             2587            431.\n 7     6 charizard                   534             3121            446.\n 8     6 charizardmega charizard x   634             3755            469.\n 9     6 charizardmega charizard y   634             4389            488.\n10     7 squirtle                    314             4703            470.\n11     8 wartortle                   405             5108            464.\n12     9 blastoise                   530             5638            470.\n13     9 blastoisemega blastoise     630             6268            482.\n14    10 caterpie                    195             6463            462.",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Brojevi</span>"
    ]
  },
  {
    "objectID": "03_04_brojevi.html#opće-transformacije",
    "href": "03_04_brojevi.html#opće-transformacije",
    "title": "7  Brojevi",
    "section": "2 Opće transformacije",
    "text": "2 Opće transformacije\nSljedeći odjeljci opisuju neke opće transformacije koje se često koriste s numeričkim vektorima, ali se mogu primijeniti i na sve druge vrste stupaca podatkovnog okvira.\nRangovi\nPaket dplyr pruža niz funkcija rangiranja inspiriranih SQL-om, ali uvijek biste trebali započeti s min_rank(). Ova funkcija koristi tipičnu metodu za rješavanje izjednačenih vrijednosti, na primjer 1., 2., 2., 4. mjesto:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nx &lt;- c(1, 2, 2, 3, 4, NA)\nmin_rank(x)\n\n[1]  1  2  2  4  5 NA\n\n\n\n\n\nVažno je primijetiti da najmanje vrijednosti dobivaju najniže rangove. Koristite desc(x) da biste najvećim vrijednostima dali najniže rangove:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nmin_rank(desc(x))\n\n[1]  5  3  3  2  1 NA\n\n\n\n\n\nU kontekstu pokemon_dataset podatkovnog okvira, možemo rangirati Pokémone prema njihovim različitim statistikama:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  mutate(\n    attack_rank = min_rank(desc(attack)),\n    defense_rank = min_rank(desc(defense)),\n    speed_rank = min_rank(desc(speed))\n  ) |&gt;\n  select(name, attack, attack_rank, defense, defense_rank, speed, speed_rank) |&gt;\n  arrange(attack_rank) |&gt;\n  head(10)\n\n# A tibble: 10 × 7\n   name                 attack attack_rank defense defense_rank speed speed_rank\n   &lt;chr&gt;                 &lt;dbl&gt;       &lt;int&gt;   &lt;dbl&gt;        &lt;int&gt; &lt;dbl&gt;      &lt;int&gt;\n 1 mewtwomega mewtwo x     190           1     100          124   130         14\n 2 heracrossmega herac…    185           2     115           75    75        307\n 3 groudonprimal groud…    180           3     160           11    90        187\n 4 rayquazamega rayqua…    180           3     100          124   115         38\n 5 deoxysattack forme      180           3      20          790   150          3\n 6 garchompmega garcho…    170           6     115           75    92        179\n 7 kyuremblack kyurem      170           6     100          124    95        150\n 8 banettemega banette     165           8      75          327    75        307\n 9 rampardos               165           8      60          487    58        483\n10 gallademega gallade     165           8      95          159   110         56\n\n\n\n\n\nOvaj primjer pokazuje Pokémone s najvišim rangovima napada, zajedno s njihovim rangovima obrane i brzine, što omogućuje usporedbu različitih dimenzija snage.\nAko min_rank() ne radi ono što vam treba, pogledajte varijante row_number(), dense_rank(), percent_rank() i cume_dist(). Pogledajte dokumentaciju za detalje:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\ndf &lt;- tibble(x = x)\ndf |&gt;\n  mutate(\n    row_number = row_number(x),\n    dense_rank = dense_rank(x),\n    percent_rank = percent_rank(x),\n    cume_dist = cume_dist(x)\n  )\n\n# A tibble: 6 × 5\n      x row_number dense_rank percent_rank cume_dist\n  &lt;dbl&gt;      &lt;int&gt;      &lt;int&gt;        &lt;dbl&gt;     &lt;dbl&gt;\n1     1          1          1         0          0.2\n2     2          2          2         0.25       0.6\n3     2          3          2         0.25       0.6\n4     3          4          3         0.75       0.8\n5     4          5          4         1          1  \n6    NA         NA         NA        NA         NA  \n\n\n\n\n\nU pokemon_dataset podatkovnom okviru možemo usporediti različite metode rangiranja:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  select(name, total) |&gt;\n  arrange(desc(total)) |&gt;\n  mutate(\n    min_rank = min_rank(desc(total)),\n    dense_rank = dense_rank(desc(total)),\n    row_number = row_number(desc(total)),\n    percent_rank = percent_rank(desc(total))\n  ) |&gt;\n  head(10)\n\n# A tibble: 10 × 6\n   name                    total min_rank dense_rank row_number percent_rank\n   &lt;chr&gt;                   &lt;dbl&gt;    &lt;int&gt;      &lt;int&gt;      &lt;int&gt;        &lt;dbl&gt;\n 1 mewtwomega mewtwo x       780        1          1          1      0      \n 2 mewtwomega mewtwo y       780        1          1          2      0      \n 3 rayquazamega rayquaza     780        1          1          3      0      \n 4 kyogreprimal kyogre       770        4          2          4      0.00375\n 5 groudonprimal groudon     770        4          2          5      0.00375\n 6 arceus                    720        6          3          6      0.00626\n 7 tyranitarmega tyranitar   700        7          4          7      0.00751\n 8 salamencemega salamence   700        7          4          8      0.00751\n 9 metagrossmega metagross   700        7          4          9      0.00751\n10 latiasmega latias         700        7          4         10      0.00751\n\n\n\n\n\nOvaj primjer pokazuje razlike između min_rank() (koji daje isti rang izjednačenim vrijednostima i preskače sljedeći rang), dense_rank() (koji daje isti rang izjednačenim vrijednostima ali ne preskače rangove), row_number() (koji daje jedinstvene rangove čak i za izjednačene vrijednosti), i percent_rank() (koji daje proporciju vrijednosti koje su manje).\nFunkciju row_number() također možete koristiti bez ikakvih argumenata kada je unutar dplyr funkcije. U tom slučaju, dat će broj “trenutnog” retka. Kada se kombinira s %% ili %/%, ovo može biti koristan alat za dijeljenje podataka u grupe slične veličine:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\ndf &lt;- tibble(id = 1:10)\ndf |&gt;\n  mutate(\n    row0 = row_number() - 1,\n    three_groups = row0 %% 3,\n    three_in_each_group = row0 %/% 3\n  )\n\n# A tibble: 10 × 4\n      id  row0 three_groups three_in_each_group\n   &lt;int&gt; &lt;dbl&gt;        &lt;dbl&gt;               &lt;dbl&gt;\n 1     1     0            0                   0\n 2     2     1            1                   0\n 3     3     2            2                   0\n 4     4     3            0                   1\n 5     5     4            1                   1\n 6     6     5            2                   1\n 7     7     6            0                   2\n 8     8     7            1                   2\n 9     9     8            2                   2\n10    10     9            0                   3\n\n\n\n\n\nU pokemon_dataset podatkovnom okviru možemo koristiti ovu tehniku za dijeljenje Pokémona u grupe:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  arrange(id) |&gt;\n  mutate(\n    row0 = row_number() - 1,\n    group_of_5 = row0 %% 5,\n    batch = row0 %/% 100\n  ) |&gt;\n  select(id, name, row0, group_of_5, batch) |&gt;\n  head(15)\n\n# A tibble: 15 × 5\n      id name                       row0 group_of_5 batch\n   &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n 1     1 bulbasaur                     0          0     0\n 2     2 ivysaur                       1          1     0\n 3     3 venusaur                      2          2     0\n 4     3 venusaurmega venusaur         3          3     0\n 5     4 charmander                    4          4     0\n 6     5 charmeleon                    5          0     0\n 7     6 charizard                     6          1     0\n 8     6 charizardmega charizard x     7          2     0\n 9     6 charizardmega charizard y     8          3     0\n10     7 squirtle                      9          4     0\n11     8 wartortle                    10          0     0\n12     9 blastoise                    11          1     0\n13     9 blastoisemega blastoise      12          2     0\n14    10 caterpie                     13          3     0\n15    11 metapod                      14          4     0\n\n\n\n\n\nOva tehnika omogućuje stvaranje rotacijskih grupa ili grupa za procesiranje u serijama.\nPomaci\nFunkcije lag() i lead() omogućuju vam da se referencirate na vrijednosti neposredno prije ili neposredno poslije “trenutne” vrijednosti. Vraćaju vektor iste duljine kao ulazni vektor, dopunjen s NA vrijednostima na početku ili kraju:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nx &lt;- c(2, 5, 11, 11, 19, 35)\nlag(x)\n\n[1] NA  2  5 11 11 19\n\nlead(x)\n\n[1]  5 11 11 19 35 NA\n\n\n\n\n\nIzrazi x - lag(x) daju vam razliku između trenutne i prethodne vrijednosti:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nx - lag(x)\n\n[1] NA  3  6  0  8 16\n\n\n\n\n\nIzraz x == lag(x) govori vam kada se trenutna vrijednost mijenja:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nx == lag(x)\n\n[1]    NA FALSE FALSE  TRUE FALSE FALSE\n\n\n\n\n\nU pokemon_dataset podatkovnom okviru možemo koristiti ove funkcije za usporedbu uzastopnih Pokémona:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  arrange(id) |&gt;\n  mutate(\n    total_diff = total - lag(total),\n    total_change = total != lag(total),\n    next_total = lead(total)\n  ) |&gt;\n  select(id, name, total, total_diff, total_change, next_total) |&gt;\n  head(10)\n\n# A tibble: 10 × 6\n      id name                      total total_diff total_change next_total\n   &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;      &lt;dbl&gt; &lt;lgl&gt;             &lt;dbl&gt;\n 1     1 bulbasaur                   318         NA NA                  405\n 2     2 ivysaur                     405         87 TRUE                525\n 3     3 venusaur                    525        120 TRUE                625\n 4     3 venusaurmega venusaur       625        100 TRUE                309\n 5     4 charmander                  309       -316 TRUE                405\n 6     5 charmeleon                  405         96 TRUE                534\n 7     6 charizard                   534        129 TRUE                634\n 8     6 charizardmega charizard x   634        100 TRUE                634\n 9     6 charizardmega charizard y   634          0 FALSE               314\n10     7 squirtle                    314       -320 TRUE                405\n\n\n\n\n\nOvaj primjer pokazuje kako se ukupna snaga Pokémona mijenja od jednog do drugog, što može otkriti evolucijske skokove u snazi.\nMožete pomicati ili voditi za više od jedne pozicije koristeći drugi argument n:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nx - lag(x, n = 2)\n\n[1] NA NA  9  6  8 24\n\n\n\n\n\nU pokemon_dataset podatkovnom okviru možemo usporediti Pokémone s onima dva mjesta ranije:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  arrange(id) |&gt;\n  mutate(total_diff_2 = total - lag(total, n = 2)) |&gt;\n  select(id, name, total, total_diff_2) |&gt;\n  head(10)\n\n# A tibble: 10 × 4\n      id name                      total total_diff_2\n   &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;        &lt;dbl&gt;\n 1     1 bulbasaur                   318           NA\n 2     2 ivysaur                     405           NA\n 3     3 venusaur                    525          207\n 4     3 venusaurmega venusaur       625          220\n 5     4 charmander                  309         -216\n 6     5 charmeleon                  405         -220\n 7     6 charizard                   534          225\n 8     6 charizardmega charizard x   634          229\n 9     6 charizardmega charizard y   634          100\n10     7 squirtle                    314         -320\n\n\n\n\n\nUzastopni identifikatori\nPonekad želite započeti novu grupu svaki put kada se dogodi neki događaj. Na primjer, kada gledate podatke s web stranice, uobičajeno je da želite razbiti događaje u sesije, gdje započinjete novu sesiju nakon praznine od više od x minuta od posljednje aktivnosti. Na primjer, zamislite da imate vremena kada je netko posjetio web stranicu:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nevents &lt;- tibble(time = c(0, 1, 2, 3, 5, 10, 12, 15, 17, 19, 20, 27, 28, 30))\n\n\n\n\nI izračunali ste vrijeme između svakog događaja i otkrili postoji li praznina dovoljno velika da kvalificira:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nevents &lt;- events |&gt;\n  mutate(\n    diff = time - lag(time, default = first(time)),\n    has_gap = diff &gt;= 5\n  )\nevents\n\n# A tibble: 14 × 3\n    time  diff has_gap\n   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;  \n 1     0     0 FALSE  \n 2     1     1 FALSE  \n 3     2     1 FALSE  \n 4     3     1 FALSE  \n 5     5     2 FALSE  \n 6    10     5 TRUE   \n 7    12     2 FALSE  \n 8    15     3 FALSE  \n 9    17     2 FALSE  \n10    19     2 FALSE  \n11    20     1 FALSE  \n12    27     7 TRUE   \n13    28     1 FALSE  \n14    30     2 FALSE  \n\n\n\n\n\nAli kako prijeći s tog logičkog vektora na nešto što možemo koristiti s group_by()? Funkcija cumsum() dolazi u pomoć jer svaki put kada praznina (odnosno has_gap) postaje TRUE, grupa će se povećati za jedan:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\nevents |&gt; mutate(\n  group = cumsum(has_gap)\n)\n\n# A tibble: 14 × 4\n    time  diff has_gap group\n   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;   &lt;int&gt;\n 1     0     0 FALSE       0\n 2     1     1 FALSE       0\n 3     2     1 FALSE       0\n 4     3     1 FALSE       0\n 5     5     2 FALSE       0\n 6    10     5 TRUE        1\n 7    12     2 FALSE       1\n 8    15     3 FALSE       1\n 9    17     2 FALSE       1\n10    19     2 FALSE       1\n11    20     1 FALSE       1\n12    27     7 TRUE        2\n13    28     1 FALSE       2\n14    30     2 FALSE       2\n\n\n\n\n\nDrugi pristup za stvaranje grupnih varijabli je consecutive_id() koja započinje novu grupu svaki put kada se promijeni jedan od njezinih argumenata. Na primjer, inspiriran ovim Stack Overflow pitanjem, zamislite da imate podatkovni okvir s mnogo ponovljenih vrijednosti:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\ndf &lt;- tibble(\n  x = c(\"a\", \"a\", \"a\", \"b\", \"c\", \"c\", \"d\", \"e\", \"a\", \"a\", \"b\", \"b\"),\n  y = c(1, 2, 3, 2, 4, 1, 3, 9, 4, 8, 10, 199)\n)\n\n\n\n\nAko želite zadržati prvi redak iz svakog ponovljenog x, možete koristiti group_by(), consecutive_id() i slice_head():\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\ndf |&gt;\n  group_by(id = consecutive_id(x)) |&gt; \n  slice_head(n = 1)\n\n# A tibble: 7 × 3\n# Groups:   id [7]\n  x         y    id\n  &lt;chr&gt; &lt;dbl&gt; &lt;int&gt;\n1 a         1     1\n2 b         2     2\n3 c         4     3\n4 d         3     4\n5 e         9     5\n6 a         4     6\n7 b        10     7\n\n\n\n\n\nU pokemon_dataset podatkovnom okviru možemo koristiti consecutive_id() za identifikaciju skupina uzastopnih Pokémona iste vrste:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  arrange(id) |&gt;\n  mutate(type_group = consecutive_id(type_1)) |&gt;\n  select(id, name, type_1, type_group) |&gt;\n  head(20)\n\n# A tibble: 20 × 4\n      id name                      type_1 type_group\n   &lt;dbl&gt; &lt;chr&gt;                     &lt;fct&gt;       &lt;int&gt;\n 1     1 bulbasaur                 grass           1\n 2     2 ivysaur                   grass           1\n 3     3 venusaur                  grass           1\n 4     3 venusaurmega venusaur     grass           1\n 5     4 charmander                fire            2\n 6     5 charmeleon                fire            2\n 7     6 charizard                 fire            2\n 8     6 charizardmega charizard x fire            2\n 9     6 charizardmega charizard y fire            2\n10     7 squirtle                  water           3\n11     8 wartortle                 water           3\n12     9 blastoise                 water           3\n13     9 blastoisemega blastoise   water           3\n14    10 caterpie                  bug             4\n15    11 metapod                   bug             4\n16    12 butterfree                bug             4\n17    13 weedle                    bug             4\n18    14 kakuna                    bug             4\n19    15 beedrill                  bug             4\n20    15 beedrillmega beedrill     bug             4\n\n\n\n\n\nOvaj primjer pokazuje kako consecutive_id() stvara nove grupe svaki put kada se promijeni primarna vrsta Pokémona, što može biti korisno za analizu evolucijskih linija ili grupiranja sličnih Pokémona u Pokédexu.\nMožemo također analizirati kako se uzastopne grupe legendarnih i ne-legendarnih Pokémona mijenjaju:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  arrange(id) |&gt;\n  mutate(\n    legendary_group = consecutive_id(legendary)\n  ) |&gt;\n  group_by(legendary_group) |&gt;\n  summarize(\n    legendary = first(legendary),\n    count = n(),\n    first_pokemon = first(name),\n    last_pokemon = last(name)\n  ) |&gt;\n  head(10)\n\n# A tibble: 10 × 5\n   legendary_group legendary count first_pokemon last_pokemon           \n             &lt;int&gt; &lt;lgl&gt;     &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;                  \n 1               1 FALSE       156 bulbasaur     snorlax                \n 2               2 TRUE          3 articuno      moltres                \n 3               3 FALSE         3 dratini       dragonite              \n 4               4 TRUE          3 mewtwo        mewtwomega mewtwo y    \n 5               5 FALSE        97 mew           blissey                \n 6               6 TRUE          3 raikou        suicune                \n 7               7 FALSE         4 larvitar      tyranitarmega tyranitar\n 8               8 TRUE          2 lugia         ho-oh                  \n 9               9 FALSE       143 celebi        metagrossmega metagross\n10              10 TRUE         18 regirock      deoxysspeed forme      \n\n\n\n\n\nOvaj primjer otkriva obrazac distribucije legendarnih Pokémona kroz Pokédex, pokazujući da se obično pojavljuju u skupinama na kraju svake generacije.",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Brojevi</span>"
    ]
  },
  {
    "objectID": "03_04_brojevi.html#sažimanje-brojeva",
    "href": "03_04_brojevi.html#sažimanje-brojeva",
    "title": "7  Brojevi",
    "section": "3 Sažimanje brojeva",
    "text": "3 Sažimanje brojeva\nSamo korištenje brojanja, prosjeka i suma koje smo već uveli može vas odvesti daleko u analizi podataka, ali R pruža mnoge druge korisne funkcije sažimanja. Ovdje je izbor funkcija koje možda smatrate korisnima u radu s numeričkim podacima\nSredište\nDo sada smo većinom koristili mean() za sažimanje središta vektora vrijednosti. Kao što smo vidjeli u ranijim poglavljima, budući da je prosjek suma podijeljena s brojem opservacija, osjetljiv je čak i na samo nekoliko neobično visokih ili niskih vrijednosti. Alternativa je korištenje median() koja pronalazi vrijednost koja leži u “sredini” vektora, odnosno 50 % vrijednosti je iznad nje, a 50% je ispod nje. Ovisno o obliku distribucije varijable koja vas zanima, prosjek ili medijan mogu biti bolja mjera središta. Na primjer, za simetrične distribucije općenito prijavljujemo prosjek, dok za asimetrične distribucije obično prijavljujemo medijan.\nU kontekstu pokemon_dataset podatkovnog okvira možemo usporediti prosjek i medijan za različite statistike:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  summarize(\n    mean_attack = mean(attack, na.rm = TRUE),\n    median_attack = median(attack, na.rm = TRUE),\n    mean_defense = mean(defense, na.rm = TRUE),\n    median_defense = median(defense, na.rm = TRUE),\n    mean_speed = mean(speed, na.rm = TRUE),\n    median_speed = median(speed, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 6\n  mean_attack median_attack mean_defense median_defense mean_speed median_speed\n        &lt;dbl&gt;         &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;      &lt;dbl&gt;        &lt;dbl&gt;\n1        79.0            75         73.8             70       68.3           65\n\n\n\n\n\nOvaj primjer pokazuje da su prosjeci svih statistika nešto viši od medijana, što sugerira blagu pozitivnu asimetričnost u distribucijama - postoje neki Pokémoni s izuzetno visokim vrijednostima koji povlače prosjek prema gore.\nMožemo usporediti prosjek i medijan ukupne snage Pokémona po vrsti:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(type_1) |&gt;\n  summarize(\n    mean_total = mean(total, na.rm = TRUE),\n    median_total = median(total, na.rm = TRUE),\n    n = n()\n  ) |&gt;\n  arrange(desc(mean_total))\n\n# A tibble: 18 × 4\n   type_1   mean_total median_total     n\n   &lt;fct&gt;         &lt;dbl&gt;        &lt;dbl&gt; &lt;int&gt;\n 1 dragon         551.         600     32\n 2 steel          488.         500     27\n 3 flying         485          558.     4\n 4 psychic        476.         485     57\n 5 fire           458.         482     52\n 6 rock           454.         468.    44\n 7 dark           446.         465     31\n 8 electric       443.         478.    44\n 9 ghost          440.         464.    32\n10 ground         438.         440     32\n11 ice            433.         468.    24\n12 water          430.         455    112\n13 grass          421.         430     70\n14 fighting       416.         455     27\n15 fairy          413.         405     17\n16 normal         402.         415     98\n17 poison         399.         402.    28\n18 bug            379.         395     69\n\n\n\n\n\nZa većinu vrsta Pokémona, prosjek i medijan su relativno bliski, što ukazuje na relativno simetrične distribucije unutar svake vrste.\nMožda biste se također pitali o modalnoj vrijednosti, odnosno najčešćoj vrijednosti. Ovo je sažetak koji dobro funkcionira samo za vrlo jednostavne slučajeve, ali ne funkcionira dobro za mnoge stvarne skupove podataka. Ako su podaci diskretni, može postojati više najčešćih vrijednosti, a ako su podaci kontinuirani, možda ne postoji najčešća vrijednost jer je svaka vrijednost malo drugačija. Iz ovih razloga, modus se obično ne koristi od strane statističara i ne postoji funkcija za modus uključena u osnovni R.\nMinimum, maksimum i kvantili\nŠto ako vas zanimaju pozicije različite od središta? Funkcije min() i max() dat će vam najveću i najmanju vrijednost. Još jedan moćan alat je quantile(), koji je generalizacija medijana. Funkcija quantile(x, 0.25) pronaći će vrijednost x koja je veća od 25 % vrijednosti, quantile(x, 0.5) je ekvivalentna medijanu, a quantile(x, 0.95) pronaći će vrijednost koja je veća od 95% vrijednosti.\nU pokemon_dataset podatkovnom okviru možemo istražiti raspon i kvantile različitih statistika:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  summarize(\n    min_attack = min(attack, na.rm = TRUE),\n    q25_attack = quantile(attack, 0.25, na.rm = TRUE),\n    median_attack = median(attack, na.rm = TRUE),\n    q75_attack = quantile(attack, 0.75, na.rm = TRUE),\n    max_attack = max(attack, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 5\n  min_attack q25_attack median_attack q75_attack max_attack\n       &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1          5         55            75        100        190\n\n\n\n\n\nOvaj rezultat pokazuje da najslabiji Pokémon ima napad od samo 5, dok najjači ima 190. Medijalna vrijednost od 75 i kvartili pokazuju da je distribucija napada relativno ravnomjerno raspoređena.\nMožemo pogledati 95. percentil napada umjesto maksimuma, jer će ignorirati 5 % Pokémona s najjačim napadom koji mogu biti ekstremni:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(generation) |&gt;\n  summarize(\n    max_attack = max(attack, na.rm = TRUE),\n    q95_attack = quantile(attack, 0.95, na.rm = TRUE),\n    n = n()\n  )\n\n# A tibble: 6 × 4\n  generation max_attack q95_attack     n\n  &lt;fct&gt;           &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;\n1 1                 190       130    166\n2 5                 170       135    165\n3 3                 180       150    160\n4 4                 170       136    121\n5 2                 185       130    106\n6 6                 160       131.    82\n\n\n\n\n\nOvaj primjer pokazuje da, iako maksimalni napad raste kroz generacije (posebno u generaciji 6), 95. percentil je stabilniji i pruža bolji uvid u tipične vrijednosti napada.\nMožemo analizirati kvantile ukupne snage po vrsti kako bismo dobili potpuniju sliku distribucije:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(type_1) |&gt;\n  summarize(\n    min = min(total, na.rm = TRUE),\n    q25 = quantile(total, 0.25, na.rm = TRUE),\n    median = median(total, 0.5, na.rm = TRUE),\n    q75 = quantile(total, 0.75, na.rm = TRUE),\n    max = max(total, na.rm = TRUE),\n    n = n()\n  ) |&gt;\n  arrange(desc(median))\n\n# A tibble: 18 × 7\n   type_1     min   q25 median   q75   max     n\n   &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n 1 dragon     300  420    600   680    780    32\n 2 flying     245  462.   558.  580    580     4\n 3 steel      300  425    500   580    700    27\n 4 psychic    198  336    485   600    780    57\n 5 fire       250  368    482   534    680    52\n 6 electric   205  362.   478.  520    610    44\n 7 rock       280  360.   468.  516.   700    44\n 8 ice        250  305    468.  526.   580    24\n 9 dark       220  359    465   510    680    31\n10 ghost      275  335    464.  496.   680    32\n11 water      200  329.   455   502.   770   112\n12 fighting   210  326.   455   498.   625    27\n13 ground     265  330.   440   512.   770    32\n14 grass      180  318.   430   497    630    70\n15 normal     190  302.   415   482.   720    98\n16 fairy      218  323    405   483    680    17\n17 poison     245  324.   402.  490    535    28\n18 bug        194  269    395   475    600    69\n\n\n\n\n\nOva analiza otkriva da zmajevi (dragon) imaju najviši medijalan ukupnu snagu, dok razlika između kvartila pokazuje koliko varijabilnosti postoji unutar svake vrste.\nRaspršenost\nPonekad niste toliko zainteresirani za to gdje leži glavni dio podataka, već za to kako su podaci raspoređeni. Dva često korištena sažetka su standardna devijacija sd(x) i interkvartilni raspon IQR(). Nećemo ovdje objašnjavati sd() jer je vjerojatno već poznata, ali IQR() je quantile(x, 0.75) - quantile(x, 0.25) i daje vam raspon koji sadrži srednjih 50 % podataka.\nU pokemon_dataset podatkovnom okviru možemo koristiti ove mjere za analizu varijabilnosti:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  summarize(\n    sd_attack = sd(attack, na.rm = TRUE),\n    iqr_attack = IQR(attack, na.rm = TRUE),\n    sd_defense = sd(defense, na.rm = TRUE),\n    iqr_defense = IQR(defense, na.rm = TRUE),\n    sd_speed = sd(speed, na.rm = TRUE),\n    iqr_speed = IQR(speed, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 6\n  sd_attack iqr_attack sd_defense iqr_defense sd_speed iqr_speed\n      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1      32.5         45       31.2          40     29.1        45\n\n\n\n\n\nOvi rezultati pokazuju da napad ima najveću standardnu devijaciju i interkvartilni raspon, što znači da postoji najveća varijabilnost u napadnim statistikama među Pokémonima.\nMožemo usporediti raspršenost različitih vrsta Pokémona:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(type_1) |&gt;\n  summarize(\n    sd_total = sd(total, na.rm = TRUE),\n    iqr_total = IQR(total, na.rm = TRUE),\n    n = n()\n  ) |&gt;\n  arrange(desc(sd_total))\n\n# A tibble: 18 × 4\n   type_1   sd_total iqr_total     n\n   &lt;fct&gt;       &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;\n 1 flying      161.       118.     4\n 2 dragon      146.       260     32\n 3 psychic     139.       264     57\n 4 ground      124.       183.    32\n 5 fairy       124.       160     17\n 6 bug         118.       206     69\n 7 normal      116.       179     98\n 8 steel       115.       155     27\n 9 water       113.       174.   112\n10 ghost       110.       161.    32\n11 fire        110.       166     52\n12 dark        109.       151     31\n13 ice         108.       221.    24\n14 rock        108.       156.    44\n15 grass       107.       178.    70\n16 electric    106.       158.    44\n17 fighting    102.       171     27\n18 poison       92.4      166.    28\n\n\n\n\n\nNormalni tipovi Pokémona pokazuju najveću standardnu devijaciju, što sugerira da ova kategorija sadrži vrlo različite Pokémone - od vrlo slabih do vrlo jakih.\nMožemo koristiti IQR() za otkrivanje neobičnosti u podacima. Na primjer, možemo istražiti postoji li varijabilnost u visini Pokémona iste vrste:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(type_1) |&gt;\n  summarize(\n    HP_iqr = IQR(HP, na.rm = TRUE),\n    n = n()\n  ) |&gt;\n  filter(HP_iqr &gt; 0) |&gt;\n  arrange(desc(HP_iqr))\n\n# A tibble: 18 × 3\n   type_1   HP_iqr     n\n   &lt;fct&gt;     &lt;dbl&gt; &lt;int&gt;\n 1 water      38     112\n 2 ice        36      24\n 3 normal     35      98\n 4 fairy      35      17\n 5 ground     34.5    32\n 6 dragon     33.8    32\n 7 poison     30.2    28\n 8 psychic    30      57\n 9 rock       30      44\n10 fighting   29      27\n11 bug        25      69\n12 grass      23.8    70\n13 dark       22.5    31\n14 fire       22      52\n15 electric   20      44\n16 ghost      19.2    32\n17 steel      18      27\n18 flying     11.2     4\n\n\n\n\n\nZmajevi pokazuju najveću varijabilnost u visini, što ima smisla jer ova kategorija uključuje i male zmajeve i ogromne legendarne zmajeve.\nDistribucije\nVažno je zapamtiti da su sve gore opisane statistike sažimanja način sažimanja distribucije na jedan broj. To znači da su fundamentalno reduktivne i ako odaberete pogrešan sažetak, lako možete propustiti važne razlike između grupa. Zbog toga je uvijek dobra ideja vizualizirati distribuciju prije nego što se posvetite vašim statistikama sažimanja.\nMožemo vizualizirati cjelokupnu distribuciju napada u pokemon_dataset podatkovnom okviru:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt; \n  ggplot(aes(x = attack)) +\n  geom_histogram(binwidth = 10, fill = \"steelblue\", color = \"white\") +\n  labs(title = \"Distribucija napada Pokémona\", x = \"Napad\", y = \"Broj Pokémona\")\n\n\n\n\n\n\n\n\n\n\n\nDistribucija je asimetrična s dugim repom prema višim vrijednostima, što sugerira da je medijana vjerojatno bolji sažetak od prosjeka. Možemo detaljnije pogledati podatke zumiranjem na područje između 0 i 150:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt; \n  filter(attack &lt;= 150) |&gt;\n  ggplot(aes(x = attack)) +\n  geom_histogram(binwidth = 5, fill = \"steelblue\", color = \"white\") +\n  labs(title = \"Distribucija napada Pokémona (do 150)\", x = \"Napad\", y = \"Broj Pokémona\")\n\n\n\n\n\n\n\n\n\n\n\nTakođer je dobra ideja provjeriti da li distribucije za podgrupe nalikuju cjelini. U sljedećem grafu prikazujemo histograme ukupne snage za svaku generaciju:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt; \n  ggplot(aes(x = total, fill = factor(generation))) +\n  geom_histogram(binwidth = 25, alpha = 0.6, position = \"identity\") +\n  facet_wrap(~ generation, ncol = 2) +\n  labs(title = \"Distribucija ukupne snage po generacijama\", x = \"Ukupna snaga\", y = \"Broj Pokémona\", fill = \"Generacija\")\n\n\n\n\n\n\n\n\n\n\n\nDistribucije izgledaju kao da slijede sličan obrazac kroz sve generacije, što sugerira da je u redu koristiti isti sažetak za svaku generaciju.\nMožemo također koristiti frekvencijske poligone za usporedbu distribucija između vrsta:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt; \n  filter(type_1 %in% c(\"water\", \"fire\", \"grass\", \"electric\")) |&gt;\n  ggplot(aes(x = total, color = type_1)) +\n  geom_freqpoly(binwidth = 25, size = 1) +\n  labs(title = \"Usporedba distribucija ukupne snage\", x = \"Ukupna snaga\", y = \"Broj Pokémona\", color = \"Vrsta\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n\n\nNe bojte se istraživati vlastite prilagođene sažetke specifično prilagođene podacima s kojima radite. U ovom slučaju, to može značiti odvojeno sažimanje legendarnih i ne-legendarnih Pokémona:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(legendary) |&gt;\n  summarize(\n    mean_total = mean(total, na.rm = TRUE),\n    median_total = median(total, na.rm = TRUE),\n    sd_total = sd(total, na.rm = TRUE),\n    n = n()\n  )\n\n# A tibble: 2 × 5\n  legendary mean_total median_total sd_total     n\n  &lt;lgl&gt;          &lt;dbl&gt;        &lt;dbl&gt;    &lt;dbl&gt; &lt;int&gt;\n1 FALSE           417.          425    107.    735\n2 TRUE            637.          600     60.9    65\n\n\n\n\n\nOvaj rezultat jasno pokazuje da legendarni Pokémoni imaju znatno veću prosječnu ukupnu snagu (638 naspram 417), ali manju varijabilnost (standardna devijacija od 60.3 naspram 101), što sugerira da su legendarni Pokémoni konzistentno snažni.\nBudući da su vrijednosti tako asimetrične, možete pokušati logaritamsku transformaciju za bolju analizu:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt; \n  mutate(log_total = log10(total)) |&gt;\n  ggplot(aes(x = log_total)) +\n  geom_histogram(binwidth = 0.1, fill = \"steelblue\", color = \"white\") +\n  labs(title = \"Logaritamska transformacija ukupne snage\", x = \"log10(Ukupna snaga)\", y = \"Broj Pokémona\")\n\n\n\n\n\n\n\n\n\n\n\nNa kraju, nemojte zaboraviti što ste naučili u ranijim poglavljima: kad god stvarate numeričke sažetke, dobra je ideja uključiti broj opservacija u svakoj grupi.\nPozicije\nPostoji još jedna završna vrsta sažetka koja je korisna za numeričke vektore, ali također funkcionira sa svakom drugom vrstom vrijednosti: izvlačenje vrijednosti na specifičnoj poziciji pomoću funkcija first(x), last(x) i nth(x, n).\nNa primjer, možemo pronaći prvog, petog i posljednjeg Pokémona za svaku generaciju:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  arrange(id) |&gt;\n  group_by(generation) |&gt;\n  summarize(\n    first_pokemon = first(name),\n    fifth_pokemon = nth(name, 5),\n    last_pokemon = last(name),\n    n = n()\n  )\n\n# A tibble: 6 × 5\n  generation first_pokemon fifth_pokemon last_pokemon          n\n  &lt;fct&gt;      &lt;chr&gt;         &lt;chr&gt;         &lt;chr&gt;             &lt;int&gt;\n1 1          bulbasaur     charmander    mew                 166\n2 5          victini       tepig         genesect            165\n3 3          treecko       torchic       deoxysspeed forme   160\n4 4          turtwig       monferno      arceus              121\n5 2          chikorita     quilava       celebi              106\n6 6          chespin       braixen       volcanion            82\n\n\n\n\n\nBudući da dplyr funkcije koriste _ za odvajanje komponenti naziva funkcija i argumenata, ove funkcije koriste na_rm umjesto na.rm. Ako izvlačite vrijednosti na pozicijama, možete pružiti zadanu vrijednost ako navedena pozicija ne postoji, argument order_by omogućuje vam lokalno prepisivanje redoslijeda redaka, a argument na_rm omogućuje vam ispuštanje nedostajućih vrijednosti.\nMožemo pronaći Pokémone s najjačim napadom u svakoj generaciji koristeći kombinaciju pozicija i rangiranja:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(generation) |&gt;\n  arrange(desc(attack)) |&gt;\n  summarize(\n    strongest_pokemon = first(name),\n    strongest_attack = first(attack),\n    n = n()\n  )\n\n# A tibble: 6 × 4\n  generation strongest_pokemon       strongest_attack     n\n  &lt;fct&gt;      &lt;chr&gt;                              &lt;dbl&gt; &lt;int&gt;\n1 1          mewtwomega mewtwo x                  190   166\n2 5          kyuremblack kyurem                   170   165\n3 3          groudonprimal groudon                180   160\n4 4          garchompmega garchomp                170   121\n5 2          heracrossmega heracross              185   106\n6 6          dianciemega diancie                  160    82\n\n\n\n\n\nOvaj primjer pokazuje kako se najjači Pokémoni mijenjaju kroz generacije, s mega evolucijom Mewtwoa u generaciji 6 koja drži apsolutni rekord napada.\nIzvlačenje vrijednosti na pozicijama komplementarno je filtriranju na rangovima. Filtriranje daje sve varijable, sa svakom opservacijom u odvojenom retku:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(generation) |&gt;\n  mutate(r = min_rank(desc(attack))) |&gt;\n  filter(r %in% c(1, max(r))) |&gt;\n  select(generation, name, attack, r) |&gt;\n  arrange(generation, r)\n\n# A tibble: 16 × 4\n# Groups:   generation [6]\n   generation name                    attack     r\n   &lt;fct&gt;      &lt;chr&gt;                    &lt;dbl&gt; &lt;int&gt;\n 1 1          mewtwomega mewtwo x        190     1\n 2 1          chansey                      5   166\n 3 5          kyuremblack kyurem         170     1\n 4 5          munna                       25   165\n 5 3          groudonprimal groudon      180     1\n 6 3          rayquazamega rayquaza      180     1\n 7 3          deoxysattack forme         180     1\n 8 3          feebas                      15   160\n 9 4          garchompmega garchomp      170     1\n10 4          happiny                      5   121\n11 2          heracrossmega heracross    185     1\n12 2          shuckle                     10   105\n13 2          blissey                     10   105\n14 6          dianciemega diancie        160     1\n15 6          hoopahoopa unbound         160     1\n16 6          spewpa                      22    82\n\n\n\n\n\nOvaj pristup omogućuje nam da vidimo i najjače i najslabije Pokémone u svakoj generaciji zajedno sa svim njihovim varijablama.\nS glagolom mutate()\nKao što nazivi sugeriraju, funkcije sažimanja obično se koriste s summarize(). Međutim, zbog pravila recikliranja o kojima smo raspravljali ranije, one se također mogu korisno kombinirati s mutate(), osobito kada želite provesti neku vrstu grupne standardizacije.\nIzraz x / sum(x) izračunava proporciju ukupnog iznosa:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(generation) |&gt;\n  mutate(\n    prop_of_total = total / sum(total)\n  ) |&gt;\n  select(generation, name, total, prop_of_total) |&gt;\n  arrange(generation, desc(prop_of_total)) |&gt;\n  head(12)\n\n# A tibble: 12 × 4\n# Groups:   generation [1]\n   generation name                      total prop_of_total\n   &lt;fct&gt;      &lt;chr&gt;                     &lt;dbl&gt;         &lt;dbl&gt;\n 1 1          mewtwomega mewtwo x         780       0.0110 \n 2 1          mewtwomega mewtwo y         780       0.0110 \n 3 1          mewtwo                      680       0.00960\n 4 1          gyaradosmega gyarados       640       0.00903\n 5 1          charizardmega charizard x   634       0.00895\n 6 1          charizardmega charizard y   634       0.00895\n 7 1          blastoisemega blastoise     630       0.00889\n 8 1          venusaurmega venusaur       625       0.00882\n 9 1          aerodactylmega aerodactyl   615       0.00868\n10 1          gengarmega gengar           600       0.00847\n11 1          pinsirmega pinsir           600       0.00847\n12 1          dragonite                   600       0.00847\n\n\n\n\n\nIzraz (x - mean(x)) / sd(x) izračunava Z-score (standardiziran na prosjek 0 i standardnu devijaciju 1):\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(type_1) |&gt;\n  mutate(\n    attack_zscore = (attack - mean(attack)) / sd(attack)\n  ) |&gt;\n  select(type_1, name, attack, attack_zscore) |&gt;\n  arrange(type_1, desc(attack_zscore)) |&gt;\n  head(12)\n\n# A tibble: 12 × 4\n# Groups:   type_1 [1]\n   type_1 name                  attack attack_zscore\n   &lt;fct&gt;  &lt;chr&gt;                  &lt;dbl&gt;         &lt;dbl&gt;\n 1 water  gyaradosmega gyarados    155          2.85\n 2 water  swampertmega swampert    150          2.67\n 3 water  kyogreprimal kyogre      150          2.67\n 4 water  sharpedomega sharpedo    140          2.32\n 5 water  kingler                  130          1.97\n 6 water  gyarados                 125          1.79\n 7 water  sharpedo                 120          1.62\n 8 water  crawdaunt                120          1.62\n 9 water  palkia                   120          1.62\n10 water  swampert                 110          1.26\n11 water  carracosta               108          1.19\n12 water  krabby                   105          1.09\n\n\n\n\n\nIzraz (x - min(x)) / (max(x) - min(x)) standardizira na raspon [0, 1]:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  group_by(generation) |&gt;\n  mutate(attack_scaled = (attack - min(attack)) / (max(attack) - min(attack))) |&gt;\n  select(generation, name, attack, attack_scaled) |&gt;\n  arrange(generation, desc(attack_scaled)) |&gt;\n  head(12)\n\n# A tibble: 12 × 4\n# Groups:   generation [1]\n   generation name                      attack attack_scaled\n   &lt;fct&gt;      &lt;chr&gt;                      &lt;dbl&gt;         &lt;dbl&gt;\n 1 1          mewtwomega mewtwo x          190         1    \n 2 1          pinsirmega pinsir            155         0.811\n 3 1          gyaradosmega gyarados        155         0.811\n 4 1          beedrillmega beedrill        150         0.784\n 5 1          mewtwomega mewtwo y          150         0.784\n 6 1          aerodactylmega aerodactyl    135         0.703\n 7 1          dragonite                    134         0.697\n 8 1          charizardmega charizard x    130         0.676\n 9 1          machamp                      130         0.676\n10 1          kingler                      130         0.676\n11 1          rhydon                       130         0.676\n12 1          flareon                      130         0.676\n\n\n\n\n\nIzraz x / first(x) izračunava indeks temeljen na prvoj opservaciji:\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_dataset |&gt;\n  arrange(id) |&gt;\n  group_by(generation) |&gt;\n  mutate(attack_index = attack / first(attack)) |&gt;\n  select(generation, name, attack, attack_index) |&gt;\n  head(12)\n\n# A tibble: 12 × 4\n# Groups:   generation [1]\n   generation name                      attack attack_index\n   &lt;fct&gt;      &lt;chr&gt;                      &lt;dbl&gt;        &lt;dbl&gt;\n 1 1          bulbasaur                     49        1    \n 2 1          ivysaur                       62        1.27 \n 3 1          venusaur                      82        1.67 \n 4 1          venusaurmega venusaur        100        2.04 \n 5 1          charmander                    52        1.06 \n 6 1          charmeleon                    64        1.31 \n 7 1          charizard                     84        1.71 \n 8 1          charizardmega charizard x    130        2.65 \n 9 1          charizardmega charizard y    104        2.12 \n10 1          squirtle                      48        0.980\n11 1          wartortle                     63        1.29 \n12 1          blastoise                     83        1.69 \n\n\n\n\n\nOve tehnike omogućuju usporedbu Pokémona unutar njihovih grupa na relativnoj skali, što može biti korisnije od apsolutnih vrijednosti kada analizirate obrazce i odnose između različitih kategorija Pokémona.",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Brojevi</span>"
    ]
  },
  {
    "objectID": "03_05_logicke_vrijednosti.html",
    "href": "03_05_logicke_vrijednosti.html",
    "title": "8  Logičke vrijednosti",
    "section": "",
    "text": "Logičke vrijednosti predstavljaju temeljni koncept u znanosti o podacima i programiranju koji omogućuje izražavanje istinitosti ili neistinitosti određenih tvrdnji. U svojoj najjednostavnijoj formi, logičke vrijednosti mogu poprimiti samo dva moguća stanja: istinito ili lažno, što odgovara konceptu Booleove logike nazvanoj po britanskom matematičaru Georgeu Booleu iz 19. stoljeća. Ove binarne vrijednosti čine osnovu za donošenje odluka u analizi podataka, omogućavajući programerima i analitičarima da filtriraju podatke, provjeravaju uvjete i kontroliraju tijek izvršavanja programa.\nU kontekstu znanosti o podacima, logičke vrijednosti igraju ključnu ulogu u procesu istraživanja i transformacije podataka. Analitičari redovito koriste logičke operacije kako bi identificirali redove koji zadovoljavaju određene kriterije, izdvojili relevantne podskupove podataka ili provjerili valjanost podataka. Na primjer, pri analizi skupa podataka o kupcima, logičke vrijednosti omogućuju jednostavno filtriranje kupaca čija je dob veća od određene granice ili čiji ukupni iznos kupnje prelazi određeni prag. Bez mogućnosti izražavanja i evaluacije logičkih uvjeta, moderna analiza podataka bila bi znatno ograničena u svojoj fleksibilnosti i moći.\nU programskom jeziku R, logičke vrijednosti implementirane su kroz poseban tip podataka poznat kao logical. R koristi ključne riječi TRUE i FALSE za predstavljanje istinitih i lažnih vrijednosti, pri čemu je važno napomenuti da R razlikuje velika i mala slova, što znači da moraju biti napisane velikim slovima kako bi bile prepoznate kao logičke konstante. Osim ovih dviju osnovnih vrijednosti, R također podržava posebnu vrijednost NA koja predstavlja nedostajuću ili nepoznatu logičku vrijednost, što je posebno važno pri radu s realnim skupovima podataka koji često sadrže nepotpune informacije. Logički vektori u R-u nastaju kao rezultat usporedbi i logičkih operacija, omogućavajući elegantno i učinkovito manipuliranje podacima kroz vektorizirane operacije koje su jedna od ključnih prednosti ovog programskog jezika.\n\n0.1 Uspoređivanje\nUsporedbe predstavljaju najčešći način stvaranja logičkih vrijednosti u R-u, a temelje se na upotrebi operatora usporedbe koji omogućavaju evaluaciju odnosa između vrijednosti. R pruža standardni skup operatora usporedbe koji uključuju:\n\nveće od (&gt;),\nveće ili jednako (&gt;=),\nmanje od (&lt;),\nmanje ili jednako (&lt;=),\njednako (==) i\nrazličito od (!=).\n\nOvi operatori primjenjuju se na različite tipove podataka, uključujući numeričke vrijednosti, znakovne nizove i datume, pri čemu svaka usporedba kao rezultat vraća logičku vrijednost TRUE ili FALSE.\nKad se koriste operatori usporedbe na numeričkim vrijednostima, R provodi standardne matematičke usporedbe koje su intuitivne i jednostavne za razumijevanje. Na primjer, pri radu sa skupom podataka o Pokemonima pohranjenim u pokemon_dataset, možemo koristiti usporedbe za identificiranje posebno moćnih stvorenja. Ova naredba stvorit će logički vektor koji sadrži TRUE za sve Pokemone čija je vrijednost napada veća od 100, a FALSE za sve ostale. Slično tome, možemo provjeriti koji Pokemoni imaju iznimno visoku obranu.\n\n# Provjera koji Pokemoni imaju Attack veći od 100\npokemon_dataset$attack &gt; 100\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\n [13]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n [97]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[121]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[145] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[157] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n[229]  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[265] FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n[277] FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[313] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349]  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[385] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[397] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[409]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[421]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE\n[433] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE\n[505]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n[517] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[541]  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n[553]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[589] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE\n[601] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[673]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n[685]  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n[697]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[709]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[721]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[745] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[793]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n# Identifikacija Pokemona s visokom obranom\npokemon_dataset$defense &gt;= 120\n\n  [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n [85] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[121]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\n[229] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[325] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[409] FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n[421] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[517]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n[529]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[541]  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[553]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[589] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[625]  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[793] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE\n\n\nOperator jednakosti (==) zahtijeva posebnu pažnju jer se razlikuje od operatora dodjele (=) koji se koristi za pripisivanje vrijednosti varijablama. Ova distinkcija je kritična za izbjegavanje čestih grešaka. Pri uspoređivanju znakovih nizova, operator == provjerava potpunu jednakost između stringova, uključujući razlikovanje velikih i malih slova. U kontekstu Pokemona, možemo identificirati specifične tipove ili je li pokemon dio skupine legendarnih pokemona. Prvi izraz vratit će logički vektor koji identificira sve Pokemone čiji je primarni tip “Water”, dok će drugi identificirati sve legendarne Pokemone u skupu podataka.\n\n# Identifikacija svih Water-type Pokemona\npokemon_dataset$type_1 == \"Water\"\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n# Provjera koji Pokemoni su legendarni\npokemon_dataset$legendary == TRUE\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[265]  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[421]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[541]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[553]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[709]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nPosebnu pažnju treba obratiti na rad s decimalnim brojevima i njihovim usporedbama. Zbog načina na koji računala interno pohranjuju decimalne brojeve, mogu se pojaviti problemi s numeričkom preciznošću. Usporedba poput (0.1 + 0.2) == 0.3 može neočekivano vratiti FALSE zbog minimalnih razlika u reprezentaciji brojeva koje su posljedica ograničenja preciznosti računala. Za sigurnije uspoređivanje decimalnih brojeva, preporučuje se korištenje funkcije near() koja omogućava usporedbu s određenom tolerancijom pogreške. Ova funkcija je posebno korisna pri analizi podataka gdje se radi s izračunatim vrijednostima koje mogu sadržavati male zaokruživačke pogreške.\n\n# Nesigurna usporedba decimalnih brojeva\n(0.1 + 0.2) == 0.3\n\n[1] FALSE\n\n# Sigurnija usporedba koristeći near()\nnear(0.1 + 0.2, 0.3)\n\n[1] TRUE\n\n\nUsporedbe se mogu provoditi i na znakovima nizovima, pri čemu R koristi leksikografski poredak temeljen na Unicode vrijednostima znakova. To znači da \"a\" &lt; \"b\" vraća TRUE jer slovo “a” dolazi prije slova “b” u abecedi. Pri radu s podacima o Pokemonima, možemo koristiti ovakve usporedbe za sortiranje ili filtriranje prema imenima, na primjer pokemon_dataset$name &lt; \"M\" identificira sve Pokemone čija imena abecedno dolaze prije slova “M”. Međutim, važno je napomenuti da R razlikuje velika i mala slova gdje velika slova dolaze prije malih slova u Unicode poretku.\n\n# Identifikacija Pokemona čija imena dolaze prije slova M\npokemon_dataset$name &lt; \"M\"\n\n  [1]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n [13]  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE\n [49] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\n [61]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n [73] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n [97] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[109] FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[121] FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n[133] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[145]  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n[157]  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[169] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE\n[181]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE\n[193] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE\n[205]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE\n[229] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241]  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[253] FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE\n[265] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[277] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[289] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE\n[325] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[337] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n[349] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE\n[361] FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE\n[373] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[385]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n[397]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE\n[409] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[421]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[433] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE\n[445]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[457]  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE\n[469]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[481] FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE\n[493]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[505] FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE\n[517] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[529] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[541]  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE\n[553]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE\n[565] FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[589]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n[613]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[625]  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE\n[637]  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\n[649]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[661]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[673]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE\n[685]  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE\n[697]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[709]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n[721]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[733] FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[745]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[757]  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[769]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[793] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n\n# Provjera imena koja dolaze nakon slova P\npokemon_dataset$name &gt; \"P\"\n\n  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n [13] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n [49] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE\n [61] FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE\n [85]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n [97] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[121]  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE\n[133]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[157] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[181] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n[193]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE\n[205] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n[217]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE\n[229]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[241] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\n[253]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\n[265]  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE\n[277]  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE\n[289]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE\n[301]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n[313]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[325]  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n[349]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE\n[361]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE\n[373]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE\n[397] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE\n[409]  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n[433]  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[445] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE\n[457] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\n[469] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481]  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[493] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[505]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE\n[517]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[529]  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[541] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE\n[553] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE\n[565]  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[577] FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[589] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[601]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[625] FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE\n[637] FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n[685] FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n[697] FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[733]  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE\n[757] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[769] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE\n[781]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE\n\n\nNedostajuće vrijednosti zahtijevaju poseban tretman pri usporedbama. Bilo koja usporedba koja uključuje NA kao rezultat će vratiti NA umjesto TRUE ili FALSE što odražava činjenicu da ne možemo sa sigurnošću tvrditi je li nepoznata vrijednost veća, manja ili jednaka nekoj drugoj vrijednosti. Ako u skupu podataka o Pokemonima neki Pokemoni imaju nedostajuće vrijednosti za brzinu, izraz pokemon_dataset$speed &gt; 80 vratit će NA za te specifične slučajeve.\n\n# Usporedba koja može sadržavati NA vrijednosti\npokemon_dataset$type_2 &gt; \"M\"\n\nWarning in Ops.factor(pokemon_dataset$type_2, \"M\"): '&gt;' not meaningful for\nfactors\n\n\n  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[101] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[126] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[151] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[176] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[201] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[226] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[251] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[276] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[301] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[326] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[351] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[376] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[401] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[426] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[451] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[476] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[501] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[526] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[551] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[576] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[601] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[626] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[651] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[676] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[701] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[726] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[751] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[776] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n\n# Eksplicitna provjera nedostajućih vrijednosti\nis.na(pokemon_dataset$type_2)\n\n  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n [13]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37] FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n [73]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n [85]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE\n [97]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[109]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[121] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[133] FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE\n[145]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[157] FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[169]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[193] FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[205] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n[217]  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[241] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[253]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[265]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE\n[277]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[289]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE\n[313]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[325]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[337] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE\n[349] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[361] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\n[373] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[385]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[397]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[421] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[433]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[445]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n[457] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[469]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n[481]  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\n[505] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[517]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE\n[529] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[541] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[553]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[565]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[577]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[589]  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE\n[613] FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE\n[625]  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[637]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n[649] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[661]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE\n[673]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE\n[685] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[721] FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n[733]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[745]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[793]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nRezultati usporedbi često se koriste za indeksiranje i filtriranje podataka, što predstavlja jednu od najmoćnijih primjena logičkih vrijednosti u R-u. Logički vektori mogu se koristiti unutar uglate zagrade za odabir podskupa podataka koji zadovoljavaju određene kriterije. Na primjer, pokemon_dataset[pokemon_dataset$HP &gt; 100, ] izdvojit će sve retke podataka gdje Pokemoni imaju više od 100 HP-ova, omogućavajući analitičarima da se fokusiraju na robusnije Pokemone. Kombiniranjem više usporedbi moguće je stvarati složenije filtere koji istovremeno provjeravaju više uvjeta, što omogućava preciznu selekciju podataka prema specifičnim potrebama analize.\n\n# Filtriranje Pokemona s više od 100 HP\npokemon_dataset[pokemon_dataset$HP &gt; 100, ]\n\n# A tibble: 67 × 13\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1    39 jigglypuff      normal fairy    270   115     45      20             45\n 2    40 wigglytuff      normal fairy    435   140     70      45             85\n 3    89 muk             poison &lt;NA&gt;     500   105    105      75             65\n 4   112 rhydon          ground rock     485   105    130     120             45\n 5   113 chansey         normal &lt;NA&gt;     450   250      5       5             35\n 6   115 kangaskhan      normal &lt;NA&gt;     490   105     95      80             40\n 7   115 kangaskhanmega… normal &lt;NA&gt;     590   105    125     100             60\n 8   131 lapras          water  ice      535   130     85      80             85\n 9   134 vaporeon        water  &lt;NA&gt;     525   130     65      60            110\n10   143 snorlax         normal &lt;NA&gt;     540   160    110      65             65\n# ℹ 57 more rows\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;\n\n# Odabir Pokemona s Attack većim od 150\nsnazni_pokemoni &lt;- pokemon_dataset[pokemon_dataset$attack &gt; 150, ]\nsnazni_pokemoni\n\n# A tibble: 18 × 13\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1   127 pinsirmega pin… bug    flying   600    65    155     120             65\n 2   130 gyaradosmega g… water  dark     640    95    155     109             70\n 3   150 mewtwomega mew… psych… fight…   780   106    190     100            154\n 4   214 heracrossmega … bug    fight…   600    80    185     115             40\n 5   248 tyranitarmega … rock   dark     700   100    164     150             95\n 6   257 blazikenmega b… fire   fight…   630    80    160      80            130\n 7   289 slaking         normal &lt;NA&gt;     670   150    160     100             95\n 8   354 banettemega ba… ghost  &lt;NA&gt;     555    64    165      75             93\n 9   383 groudonprimal … ground fire     770   100    180     160            150\n10   384 rayquazamega r… dragon flying   780   105    180     100            180\n11   386 deoxysattack f… psych… &lt;NA&gt;     600    50    180      20            180\n12   409 rampardos       rock   &lt;NA&gt;     495    97    165      60             65\n13   445 garchompmega g… dragon ground   700   108    170     115            120\n14   475 gallademega ga… psych… fight…   618    68    165      95             65\n15   486 regigigas       normal &lt;NA&gt;     670   110    160     110             80\n16   646 kyuremblack ky… dragon ice      700   125    170     100            120\n17   719 dianciemega di… rock   fairy    700    50    160     110            160\n18   720 hoopahoopa unb… psych… dark     680    80    160      60            170\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;\n\n# Izdvajanje Fire-type Pokemona\nvaterni_pokemoni &lt;- pokemon_dataset[pokemon_dataset$type_1 == \"Fire\", ]\nvaterni_pokemoni\n\n# A tibble: 0 × 13\n# ℹ 13 variables: id &lt;dbl&gt;, name &lt;chr&gt;, type_1 &lt;fct&gt;, type_2 &lt;fct&gt;,\n#   total &lt;dbl&gt;, HP &lt;dbl&gt;, attack &lt;dbl&gt;, defense &lt;dbl&gt;, special_attack &lt;dbl&gt;,\n#   special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;, legendary &lt;lgl&gt;\n\n\n\n\n0.2 Booleova algebra\nBooleova algebra predstavlja matematički sustav za rad s logičkim vrijednostima koji omogućava kombiniranje jednostavnih logičkih izraza u složenije uvjete. Ovaj sustav, nazvan po britanskom matematičaru Georgeu Booleu, temelji se na trima osnovnim operacijama koji su implementirani kroz posebne simbole\n\nAND (logičko I) - simbol &,\nOR (logičko ILI) - simbol | i\nNOT (logička negacija) - simbol !.\n\nOve operacije omogućuju analitičarima da konstruiraju kompleksne logičke uvjete koji precizno opisuju kriterije za filtriranje i analizu podataka.\nOperator AND vraća TRUE samo kada su obje usporedbe istinite, dok u svim ostalim slučajevima vraća FALSE. Ovaj operator je posebno koristan kada trebamo identificirati podatke koji istovremeno zadovoljavaju više uvjeta. U kontekstu Pokemona, možemo kombinirati više kriterija za pronalaženje specifičnih podskupova:\n\n# Pronalaženje Pokemona s visokim Attack i Defense\npokemon_dataset$attack &gt; 100 & pokemon_dataset$defense &gt; 100\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n [13]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[229] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[433] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE\n[517] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[541]  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[793] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE\n\n# Identifikacija snažnih Water-type Pokemona\npokemon_dataset$type_1 == \"Water\" & pokemon_dataset$total &gt; 500\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nPrvi primjer identificira Pokemone koji imaju i napad i obranu veću od 100, što predstavlja balansirane borce s dobrim ofenzivnim i obrambenim sposobnostima. Drugi primjer pronalazi Water-type Pokemone koji su generalno snažni, s ukupnim statistikama većim od 500.\nOperator OR vraća TRUE ako je barem jedna od usporedbi istinita, a FALSE samo kada su obje usporedbe lažne. Ovaj operator omogućava fleksibilnije filtriranje gdje tražimo podatke koji zadovoljavaju bilo koji od navedenih uvjeta:\n\n# Pokemoni koji su ili legendarni ili imaju visok Attack\npokemon_dataset$legendary == TRUE | pokemon_dataset$attack &gt; 150\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157]  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[265]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[421]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[541]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[553]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[709]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n# Fire ili Dragon type Pokemoni\npokemon_dataset$type_1 == \"Fire\" | pokemon_dataset$type_1 == \"Dragon\"\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n# Pokemoni s izuzetno visokom brzinom ili HP\npokemon_dataset$speed &gt; 120 | pokemon_dataset$HP &gt; 150\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE\n[553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nPrvi izraz identificira sve Pokemone koji su ili legendarni ili posjeduju iznimno visok napad, omogućavajući široku selekciju moćnih stvorenja. Drugi primjer pokazuje kako možemo odabrati Pokemone koji pripadaju bilo kojem od dva željena tipa, što je korisno pri analizi specifičnih grupa Pokemona.\nOperator NOT invertira logičku vrijednost tako da TRUE postaje FALSE i obrnuto. Ovaj operator je koristan za negiranje uvjeta ili za identificiranje komplementarnih skupova podataka:\n\n# Pokemoni koji NISU Water type\n!pokemon_dataset$type_1 == \"Water\"\n\n  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[121] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[136] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[151] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[166] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[181] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[196] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[211] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[226] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[241] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[256] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[271] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[286] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[301] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[316] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[331] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[346] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[361] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[376] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[391] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[406] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[421] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[436] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[451] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[466] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[481] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[496] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[511] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[526] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[541] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[556] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[571] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[586] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[601] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[616] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[631] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[646] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[661] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[676] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[691] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[706] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[721] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[736] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[751] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[766] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[781] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[796] TRUE TRUE TRUE TRUE TRUE\n\n# Ekvivalentno prethodnom izrazu\npokemon_dataset$type_1 != \"Water\"\n\n  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[121] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[136] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[151] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[166] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[181] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[196] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[211] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[226] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[241] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[256] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[271] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[286] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[301] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[316] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[331] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[346] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[361] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[376] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[391] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[406] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[421] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[436] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[451] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[466] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[481] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[496] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[511] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[526] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[541] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[556] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[571] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[586] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[601] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[616] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[631] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[646] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[661] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[676] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[691] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[706] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[721] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[736] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[751] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[766] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[781] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[796] TRUE TRUE TRUE TRUE TRUE\n\n# Pokemoni koji NISU legendarni\n!pokemon_dataset$legendary\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [73]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [85]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[109]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[121]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[133]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[145]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[157] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[169]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[181]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[193]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[205]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[217]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[229]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[241]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[253]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[265] FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[277]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[289]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[301]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[313]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[325]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[337]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[349]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[361]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[373]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[385]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[397]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[409]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[433]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[445]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[457]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[469]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[481]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[493]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[505]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[517]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[529]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[553] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[565]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[577]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[589]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[601]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[613]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[625]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[637]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[649]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[661]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[673]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[685]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[697]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[721]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[733]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[745]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[757]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[769]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[781]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n# Pokemoni koji NEMAJU visok Attack\n!(pokemon_dataset$attack &gt; 100)\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE\n [13] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [73]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n [85]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n [97] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[109]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[121] FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[133] FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[145]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[157]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[169]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[181]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[193]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[205]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[217]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n[229] FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[241]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[253]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[265]  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n[277]  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[289]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[301]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[313]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[325]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[337]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[349] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[361]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n[373]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[385]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[397]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[409] FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[421] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE\n[433]  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[445]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n[457]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[469]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n[481]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[493]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE\n[505] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n[517]  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[529]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[541] FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[553] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[565]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[577]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[589]  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n[601]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[613]  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[625]  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[637]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[649]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[661]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[673] FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n[685] FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[697] FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[721] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[733]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[745]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[757]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[769]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[781]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[793] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\nOvi primjeri pokazuju kako možemo koristiti negaciju za pronalaženje Pokemona koji ne zadovoljavaju određene kriterije, što je često jednako važno kao i pronalaženje onih koji ih zadovoljavaju.\nBooleovi operatori mogu se kombinirati u složene izraze koji omogućavaju preciznu specifikaciju kriterija, ali je važno razumjeti prioritet operatora i koristiti zagrade za eksplicitno definiranje redoslijeda evaluacije. Operator NOT ima najviši prioritet, zatim slijedi AND, a najniži prioritet ima OR. Bez pravilne upotrebe zagrada, složeni izrazi mogu proizvesti neočekivane rezultate:\n\n# Pronalaženje moćnih Pokemona specifičnih tipova\n(pokemon_dataset$type_1 == \"Fire\" | pokemon_dataset$type_1 == \"Dragon\") & pokemon_dataset$attack &gt; 100\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n# Legendarni Pokemoni s visokom brzinom ili neobično jakom obranom\npokemon_dataset$legendary == TRUE & (pokemon_dataset$speed &gt; 100 | pokemon_dataset$defense &gt; 120)\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[265] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[421]  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE\n[553]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n[709]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\n# Balansirani Pokemoni koji nisu Normal type\n!pokemon_dataset$type_1 == \"Normal\" & pokemon_dataset$attack &gt; 80 & pokemon_dataset$defense &gt; 80\n\n  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE\n [13]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n [37]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[109] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[121]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n[157]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[169]  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\n[229]  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE  TRUE\n[253] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[265] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n[337]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE\n[373] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n[409] FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE\n[421]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE\n[433] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\n[493] FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE\n[517]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE\n[529] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[541]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE\n[553]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[565] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE\n[625] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[649] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[661] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[685] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[697]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\n[709]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[721]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[793]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nPrvi primjer koristi zagrade kako bi osigurao da se prvo evaluira OR uvjet između Fire i Dragon tipova, a zatim se taj rezultat kombinira s uvjetom za visok napad. Bez zagrada, prioritet operatora mogao bi proizvesti različit rezultat.\nDe Morganovi zakoni predstavljaju važna pravila u Booleovoj algebri koja opisuju kako se negacija distribuira preko AND i OR operatora. Prvi zakon kaže da negacija AND operacije ekvivalentna je OR operaciji negiranih operanada: !(A & B) je isto što i !A | !B. Drugi zakon kaže da negacija OR operacije ekvivalentna je AND operaciji negiranih operanada: !(A | B) je isto što i !A & !B. Ovi zakoni mogu pojednostaviti kompleksne logičke izraze i učiniti kod čitljivijim:\n\n# Pokemoni koji NISU istovremeno Fire type I legendarni\n!(pokemon_dataset$type_1 == \"Fire\" & pokemon_dataset$legendary == TRUE)\n\n  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[121] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[136] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[151] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[166] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[181] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[196] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[211] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[226] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[241] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[256] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[271] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[286] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[301] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[316] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[331] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[346] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[361] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[376] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[391] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[406] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[421] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[436] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[451] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[466] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[481] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[496] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[511] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[526] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[541] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[556] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[571] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[586] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[601] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[616] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[631] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[646] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[661] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[676] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[691] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[706] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[721] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[736] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[751] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[766] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[781] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[796] TRUE TRUE TRUE TRUE TRUE\n\n# Ekvivalentno prema De Morganovim zakonima\npokemon_dataset$type_1 != \"Fire\" | pokemon_dataset$legendary != TRUE\n\n  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[121] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[136] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[151] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[166] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[181] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[196] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[211] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[226] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[241] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[256] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[271] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[286] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[301] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[316] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[331] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[346] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[361] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[376] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[391] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[406] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[421] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[436] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[451] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[466] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[481] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[496] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[511] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[526] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[541] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[556] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[571] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[586] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[601] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[616] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[631] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[646] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[661] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[676] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[691] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[706] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[721] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[736] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[751] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[766] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[781] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[796] TRUE TRUE TRUE TRUE TRUE\n\n# Pokemoni koji nemaju niti visok Attack niti visok Speed\n!(pokemon_dataset$attack &gt; 120 | pokemon_dataset$speed &gt; 100)\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n [73]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [85] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n[109]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[121] FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[133] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE\n[145]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n[157]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[169]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[181]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[193]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[205] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[217]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[229] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[241]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[253]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[265]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n[277]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[289]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[301] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[313]  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[325]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[337]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[349]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[361]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[373]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[385]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[397]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[409] FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[421] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n[433]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[445]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n[457]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[469]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE\n[481] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[493]  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[505]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n[517]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[529]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[541]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE\n[553] FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[565]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n[577]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE\n[589]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n[601]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[613]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[625]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n[637]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[649] FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[661]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[673]  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE\n[685] FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[697]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[709] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE\n[721]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n[733]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[745] FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[757]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE\n[769]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[781]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[793] FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n\n# Ekvivalentno\npokemon_dataset$attack &lt;= 120 & pokemon_dataset$speed &lt;= 100\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n [73]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [85] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n[109]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[121] FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[133] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE\n[145]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n[157]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n[169]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[181]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[193]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[205] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[217]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[229] FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[241]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[253]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[265]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE\n[277]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[289]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[301] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[313]  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[325]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[337]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[349]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[361]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[373]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[385]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE\n[397]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[409] FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n[421] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n[433]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[445]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE\n[457]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n[469]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE\n[481] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[493]  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[505]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE FALSE\n[517]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE FALSE\n[529]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[541]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE\n[553] FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[565]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n[577]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE\n[589]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n[601]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[613]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[625]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n[637]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[649] FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[661]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[673]  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE\n[685] FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE\n[697]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[709] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE  TRUE  TRUE  TRUE\n[721]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n[733]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[745] FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[757]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE FALSE\n[769]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[781]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n[793] FALSE FALSE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n\n\nOvi primjeri ilustriraju kako isti logički uvjet može biti izražen na različite načine, a razumijevanje De Morganovih zakona pomaže u pisanju jasnog i efikasnog koda.\nPosebnu kategoriju Booleovih operatora čine vektorizirane verzije & i | te njihove kratko-spojene varijante && i ||. Vektorizirane verzije (&, |) primjenjuju se element-po-element na cijele vektore i vraćaju vektor logičkih vrijednosti iste duljine kao operandi, što je standardno ponašanje u R-u prilikom rada s vektorima podataka. S druge strane, kratko-spojene verzije (&&, ||) evaluiraju samo prvi element svakog vektora i vraćaju jednu logičku vrijednost, te se koriste prvenstveno u kontrolnim strukturama kao što su if naredbe:\n\n# Vektorizirana operacija - vraća vektor\npokemon_dataset$attack &gt; 100 & pokemon_dataset$defense &gt; 100\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n [13]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[229] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[433] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE\n[517] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n[541]  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n[793] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE\n\n# Brojanje koliko Pokemona zadovoljava oba uvjeta\nsum(pokemon_dataset$attack &gt; 100 & pokemon_dataset$defense &gt; 100)\n\n[1] 48\n\n# Provođenje analize samo ako postoje legendarni Pokemoni\nif (any(pokemon_dataset$legendary == TRUE) && nrow(pokemon_dataset) &gt; 0) {\n  legendarni &lt;- pokemon_dataset[pokemon_dataset$legendary == TRUE, ]\n  print(paste(\"Pronađeno\", nrow(legendarni), \"legendarnih Pokemona\"))\n}\n\n[1] \"Pronađeno 65 legendarnih Pokemona\"\n\n\nU prvom primjeru, operator & uspoređuje svaki element vektora Attack sa svakim elementom vektora Defense, rezultirajući vektorom logičkih vrijednosti. U if strukturi koristimo && jer evaluiramo pojedinačne logičke uvjete, a ne vektore.\nFunkcija %in% predstavlja specijaliziran operator koji provjerava pripada li vrijednost skupu mogućih vrijednosti, što je elegantnije rješenje od korištenja višestrukih OR operatora. Ovaj operator je posebno koristan pri filtriranju podataka prema višestrukim kategorijama:\n\n# Tradicionalni pristup s višestrukim OR operatorima\npokemon_dataset$type_1 == \"Fire\" | pokemon_dataset$type_1 == \"Water\" | pokemon_dataset$type_1 == \"Grass\"\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n# Elegantniji pristup koristeći %in%\npokemon_dataset$type_1 %in% c(\"Fire\", \"Water\", \"Grass\")\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n# Pronalaženje Pokemona iz određenih generacija\npokemon_dataset$generation %in% c(1, 2, 3)\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [73]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [85]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[109]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[121]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[133]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[145]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[157]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[169]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[181]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[193]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[205]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[217]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[229]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[241]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[253]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[265]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[277]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[289]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[301]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[313]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[325]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[337]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[349]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[361]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[373]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[385]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[397]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[409]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[421]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n# Identifikacija specifičnih legendarnih Pokemona\npokemon_dataset$name %in% c(\"Mewtwo\", \"Lugia\", \"Rayquaza\")\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[433] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[445] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[457] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[469] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[481] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[493] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[505] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[517] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[529] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[541] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[553] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[565] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[577] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[589] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[601] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[613] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[625] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[637] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[649] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[661] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[673] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[685] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[697] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[709] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[721] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[733] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[745] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[757] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[769] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[781] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[793] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nPrvi primjer pokazuje kako %in% operator zamjenjuje niz OR usporedbi, čineći kod znatno kraćim i čitljivijim. Ovaj pristup posebno briljira kada radimo s dugim listama mogućih vrijednosti.\nKombiniranje Booleovih operatora s funkcijama za sumiranje i agregaciju omogućava moćne analitičke uvide. Funkcije poput sum(), mean(), any() i all() mogu raditi s logičkim vektorima za stvaranje numeričkih sažetaka:\n\n# Brojanje Pokemona s visokim Attack\nsum(pokemon_dataset$attack &gt; 100)\n\n[1] 170\n\n# Postotak legendarnih Pokemona\nmean(pokemon_dataset$legendary == TRUE) * 100\n\n[1] 8.125\n\n# Provjera postoji li barem jedan Dragon type Pokemon\nany(pokemon_dataset$type_1 == \"Dragon\")\n\n[1] FALSE\n\n# Provjera imaju li svi Pokemoni pozitivan HP\nall(pokemon_dataset$HP &gt; 0)\n\n[1] TRUE\n\n# Prosječan Attack Fire-type Pokemona\nmean(pokemon_dataset$attack[pokemon_dataset$type_1 == \"Fire\"])\n\n[1] NaN\n\n\nOvi primjeri demonstriraju kako logički vektori, kada se koriste s numeričkim funkcijama, omogućavaju brzo izračunavanje statistika o podskupovima podataka koji zadovoljavaju određene uvjete, što je fundamentalna tehnika u eksplorativnoj analizi podataka.\n\n\n0.3 Sažimanje logičkih vektora\nSažimanje logičkih vektora predstavlja moćnu tehniku u analizi podataka koja omogućava brzo izvlačenje agregatnih informacija o podacima koji zadovoljavaju određene uvjete. Dvije najvažnije funkcije za numeričko sažimanje logičkih vektora su sum() i mean() koje koriste činjenicu da R tretira TRUE kao 1 i FALSE kao 0 pri numeričkim operacijama. Ova konverzija omogućava intuitivno brojanje i izračunavanje proporcija na temelju logičkih uvjeta.\nFunkcija sum() broji koliko elemenata u logičkom vektoru ima vrijednost TRUE što je izuzetno korisno za određivanje koliko zapisa u skupu podataka zadovoljava određeni kriterij. Pri radu s Pokemonima, ova funkcija omogućava brzo odgovaranje na pitanja o učestalosti određenih karakteristika:\n\n# Koliko Pokemona ima Attack veći od 100\nsum(pokemon_dataset$attack &gt; 100)\n\n[1] 170\n\n# Broj legendarnih Pokemona u skupu podataka\nsum(pokemon_dataset$legendary == TRUE)\n\n[1] 65\n\n# Brojanje Water-type Pokemona\nsum(pokemon_dataset$type_1 == \"Water\")\n\n[1] 0\n\n# Koliko Pokemona ima HP veći od 80\nsum(pokemon_dataset$HP &gt; 80)\n\n[1] 193\n\n# Broj Pokemona s visokom obranom (Defense &gt; 100)\nsum(pokemon_dataset$defense &gt; 100)\n\n[1] 123\n\n\nSvaki od ovih izraza vraća jedan numerički rezultat koji predstavlja točan broj Pokemona koji zadovoljavaju navedeni uvjet, omogućavajući brzu kvantitativnu procjenu distribucije karakteristika u skupu podataka.\nFunkcija mean() izračunava proporciju TRUE vrijednosti u logičkom vektoru što je ekvivalentno dijeljenju broja TRUE vrijednosti s ukupnim brojem elemenata. Rezultat je decimalni broj između 0 i 1 koji predstavlja udio zapisa koji zadovoljavaju uvjet, a može se jednostavno pretvoriti u postotak množenjem sa 100:\n\n# Postotak Pokemona s visokim Attack\nmean(pokemon_dataset$attack &gt; 100) * 100\n\n[1] 21.25\n\n# Udio legendarnih Pokemona\nmean(pokemon_dataset$legendary == TRUE)\n\n[1] 0.08125\n\n# Postotak Fire-type Pokemona\nmean(pokemon_dataset$type_1 == \"Fire\") * 100\n\n[1] 0\n\n# Koliki udio Pokemona ima Speed veći od 80\nmean(pokemon_dataset$speed &gt; 80)\n\n[1] 0.32875\n\n# Proporcija Pokemona s ukupnim statistikama većim od 500\nmean(pokemon_dataset$total &gt; 500)\n\n[1] 0.28\n\n\nOvi primjeri pokazuju kako mean() pruža perspektivu relativne učestalosti što je često informativnije od apsolutnih brojeva jer omogućava lakšu usporedbu između različitih kategorija ili skupova podataka različitih veličina.\nKombiniranje sum() i mean() funkcija s Booleovim operatorima omogućava analizu kompleksnijih uvjeta koji uključuju više kriterija istovremeno. Ovo je posebno korisno pri istraživanju interakcija između različitih karakteristika u podacima:\n\n# Broj Pokemona koji su istovremeno Fire type i legendarni\nsum(pokemon_dataset$type_1 == \"Fire\" & pokemon_dataset$legendary == TRUE)\n\n[1] 0\n\n# Postotak Pokemona s visokim Attack ILI visokom Defense\nmean(pokemon_dataset$attack &gt; 100 | pokemon_dataset$defense &gt; 100) * 100\n\n[1] 30.625\n\n# Koliko Pokemona ima balansiran Attack i Defense (oba veća od 80)\nsum(pokemon_dataset$attack &gt; 80 & pokemon_dataset$defense &gt; 80)\n\n[1] 167\n\n# Udio Pokemona prve generacije s visokim Total\nmean(pokemon_dataset$generation == 1 & pokemon_dataset$total &gt; 450)\n\n[1] 0.09375\n\n# Broj Pokemona koji nisu Normal type i imaju Speed veći od 100\nsum(pokemon_dataset$type_1 != \"Normal\" & pokemon_dataset$speed &gt; 100)\n\n[1] 106\n\n\nOvi složeniji primjeri demonstriraju kako logički operatori omogućavaju preciznu specifikaciju uvjeta za analizu, a funkcije sažimanja ih pretvaraju u lako interpretabilne numeričke rezultate.\nLogičke funkcije any() i all() pružaju drugačiji tip sažetka koji odgovara na pitanja o postojanju ili univerzalnosti određenih uvjeta u podacima. Funkcija any() vraća TRUE ako barem jedan element u logičkom vektoru ima vrijednost TRUE, dok all() vraća TRUE samo ako svi elementi imaju vrijednost TRUE. Ove funkcije su posebno korisne za validaciju podataka i provjeru pretpostavki:\n\n# Postoji li barem jedan Dragon type Pokemon\nany(pokemon_dataset$type_1 == \"Dragon\")\n\n[1] FALSE\n\n# Ima li barem jedan Pokemon s Attack većim od 180\nany(pokemon_dataset$attack &gt; 180)\n\n[1] TRUE\n\n# Imaju li svi Pokemoni pozitivne HP vrijednosti\nall(pokemon_dataset$HP &gt; 0)\n\n[1] TRUE\n\n# Jesu li svi Pokemoni iz poznatih generacija (1-7)\nall(pokemon_dataset$generation %in% 1:7)\n\n[1] TRUE\n\n# Postoji li barem jedan legendarni Pokemon u svakoj generaciji\ntapply(pokemon_dataset$legendary, pokemon_dataset$generation, any)\n\n   1    5    3    4    2    6 \nTRUE TRUE TRUE TRUE TRUE TRUE \n\n\nPrvi primjer provjerava prisutnost Dragon type Pokemona u skupu podataka, što bi moglo biti važno za istraživanje raznolikosti tipova. Treći primjer osigurava integritet podataka provjerom da svi Pokemoni imaju validne zdravstvene bodove, što je osnovna provjera kvalitete podataka.\nFunkcija which() predstavlja komplementarnu tehniku sažimanja koja vraća indekse elemenata koji zadovoljavaju uvjet, umjesto same logičke vrijednosti ili brojčanog sažetka. Ova funkcija je korisna kada trebamo znati ne samo koliko elemenata zadovoljava uvjet, već i njihove točne pozicije u vektoru:\n\n# Indeksi Pokemona s najvišim Attack (veći od 150)\nwhich(pokemon_dataset$attack &gt; 150)\n\n [1] 138 142 164 233 269 280 314 388 425 427 430 455 495 528 544 712 797 799\n\n# Pozicije legendarnih Pokemona u skupu podataka\nwhich(pokemon_dataset$legendary == TRUE)\n\n [1] 157 158 159 163 164 165 263 264 265 270 271 415 416 417 418 419 420 421 422\n[20] 423 424 425 426 427 428 429 430 431 432 538 539 540 541 542 543 544 545 546\n[39] 550 551 552 553 554 700 701 702 703 704 705 706 707 708 709 710 711 712 713\n[58] 793 794 795 796 797 798 799 800\n\n# Indeksi prvih 10 Water-type Pokemona\nhead(which(pokemon_dataset$type_1 == \"Water\"), 10)\n\ninteger(0)\n\n# Pronalaženje pozicije specifičnog Pokemona\nwhich(pokemon_dataset$name == \"Pikachu\")\n\ninteger(0)\n\n# Indeksi Pokemona s izuzetno visokim Speed (veći od 130)\nwhich(pokemon_dataset$speed &gt; 130)\n\n [1]  20  72 110 155 165 276 316 340 429 430 432 477 679\n\n\nRezultati funkcije which() mogu se koristiti za direktno indeksiranje i pristup specifičnim recima podataka, što je korisno pri detaljnijem istraživanju podataka koji zadovoljavaju određene kriterije.\nKombiniranje funkcija sažimanja s grupiranjem podataka omogućava usporednu analizu različitih podskupina podataka. Funkcije poput tapply(), aggregate() ili funkcije iz paketa dplyr omogućavaju primjenu sažimanja na grupe definirane kategoričkom varijablom:\n\n# Prosječan broj Pokemona s visokim Attack po generaciji\ntapply(pokemon_dataset$attack &gt; 100, pokemon_dataset$generation, mean)\n\n        1         5         3         4         2         6 \n0.1927711 0.2545455 0.2312500 0.2561983 0.1320755 0.1707317 \n\n# Ukupan broj legendarnih Pokemona po generaciji\ntapply(pokemon_dataset$legendary, pokemon_dataset$generation, sum)\n\n 1  5  3  4  2  6 \n 6 15 18 13  5  8 \n\n# Postotak Pokemona s visokim HP po tipu\ntapply(pokemon_dataset$HP &gt; 80, pokemon_dataset$type_1, mean) * 100\n\n    water    normal     grass       bug   psychic      fire  electric      rock \n32.142857 35.714286 18.571429  2.898551 22.807018 21.153846 11.363636 18.181818 \n   dragon     ghost    ground      dark    poison  fighting     steel       ice \n43.750000 18.750000 40.625000 19.354839 25.000000 22.222222 11.111111 29.166667 \n    fairy    flying \n41.176471 25.000000 \n\n# Provođenje validacije: imaju li sve generacije barem jednog Pokemona\ntapply(rep(TRUE, nrow(pokemon_dataset)), pokemon_dataset$generation, any)\n\n   1    5    3    4    2    6 \nTRUE TRUE TRUE TRUE TRUE TRUE \n\n# Prosječan Attack po tipu za Pokemone s visokom obranom\ntapply(pokemon_dataset$attack[pokemon_dataset$defense &gt; 100], pokemon_dataset$type_1[pokemon_dataset$defense &gt; 100], mean)\n\n    water    normal     grass       bug   psychic      fire  electric      rock \n101.69231 105.00000 100.87500 108.80000  82.00000  82.50000  70.00000  95.15000 \n   dragon     ghost    ground      dark    poison  fighting     steel       ice \n129.16667  86.88889 113.81818  76.25000  90.00000        NA 103.06250  88.50000 \n    fairy    flying \n       NA        NA \n\n\nOvi primjeri pokazuju kako grupiranje podataka s funkcijama sažimanja omogućava identifikaciju obrazaca i razlika između kategorija, što je ključno za razumijevanje strukture podataka.\nFunkcije cumsum(), cumprod(), cummin() i cummax() pružaju kumulativne sažetke koji zadržavaju duljinu originalnog vektora, za razliku od prethodno spomenutih funkcija koje vraćaju jedan rezultat. Kumulativni sažeci omogućavaju praćenje kako se određena vrijednost mijenja kroz vektor:\n\n# Kumulativni broj legendarnih Pokemona kroz skup podataka\ncumsum(pokemon_dataset$legendary == TRUE)\n\n  [1]  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n [26]  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n [51]  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n [76]  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n[101]  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n[126]  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n[151]  0  0  0  0  0  0  1  2  3  3  3  3  4  5  6  6  6  6  6  6  6  6  6  6  6\n[176]  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6\n[201]  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6\n[226]  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6  6\n[251]  6  6  6  6  6  6  6  6  6  6  6  6  7  8  9  9  9  9  9 10 11 11 11 11 11\n[276] 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11\n[301] 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11\n[326] 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11\n[351] 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11\n[376] 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11\n[401] 11 11 11 11 11 11 11 11 11 11 11 11 11 11 12 13 14 15 16 17 18 19 20 21 22\n[426] 23 24 25 26 27 28 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29\n[451] 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29\n[476] 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29\n[501] 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29 29\n[526] 29 29 29 29 29 29 29 29 29 29 29 29 30 31 32 33 34 35 36 37 38 38 38 38 39\n[551] 40 41 42 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43\n[576] 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43\n[601] 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43\n[626] 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43\n[651] 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43\n[676] 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 43 44\n[701] 45 46 47 48 49 50 51 52 53 54 55 56 57 57 57 57 57 57 57 57 57 57 57 57 57\n[726] 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57\n[751] 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57\n[776] 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 57 58 59 60 61 62 63 64 65\n\n# Koliko je Pokemona s visokim Attack viđeno do svakog reda\ncumsum(pokemon_dataset$attack &gt; 100)\n\n  [1]   0   0   0   0   0   0   0   1   2   2   2   2   3   3   3   3   3   3\n [19]   3   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4\n [37]   4   4   4   5   5   5   5   5   5   5   5   5   5   5   5   5   5   5\n [55]   5   5   5   5   5   5   5   5   6   6   7   7   7   7   7   7   7   7\n [73]   7   7   8   8   8   9   9   9   9   9  10  10  10  10  10  10  10  10\n [91]  10  10  11  11  11  11  12  12  12  12  12  12  12  12  12  12  13  14\n[109]  14  14  14  14  14  14  15  16  16  16  16  16  17  17  17  17  18  18\n[127]  18  18  18  18  18  18  19  19  19  19  20  21  21  21  22  23  23  23\n[145]  23  23  23  24  24  24  24  24  25  26  27  28  28  28  28  28  28  29\n[163]  30  31  32  32  32  32  32  32  32  32  32  32  33  33  33  33  33  33\n[181]  33  33  33  33  33  33  33  33  33  33  33  33  33  33  33  33  33  33\n[199]  33  33  33  33  33  33  33  33  33  33  33  33  33  33  33  33  33  33\n[217]  33  33  33  33  33  33  33  33  34  34  35  35  36  37  37  38  39  39\n[235]  39  40  40  40  40  40  40  40  41  41  41  41  41  41  41  41  41  42\n[253]  42  42  42  42  42  42  42  42  42  42  42  43  43  43  43  44  45  45\n[271]  46  46  46  46  46  47  47  47  48  49  49  49  50  51  51  51  51  51\n[289]  51  51  51  51  51  51  51  51  51  51  51  51  51  51  51  51  51  51\n[307]  51  51  51  51  52  52  52  53  53  53  53  53  53  53  53  54  54  54\n[325]  54  54  54  54  54  55  55  55  56  57  57  57  57  57  57  57  57  57\n[343]  57  57  57  57  57  57  58  59  59  59  59  59  60  60  60  60  60  60\n[361]  60  60  60  61  61  61  62  63  63  63  63  63  63  63  64  64  64  64\n[379]  64  64  65  65  65  65  65  65  66  67  67  67  67  67  68  69  69  69\n[397]  69  70  70  70  70  70  71  71  71  71  71  71  72  73  73  73  74  75\n[415]  75  75  75  75  75  75  76  76  77  78  79  80  81  81  82  83  83  83\n[433]  83  83  84  84  84  85  85  85  85  85  85  86  86  86  86  86  86  86\n[451]  87  87  87  88  89  89  89  89  89  89  89  89  89  89  89  89  90  90\n[469]  90  90  90  90  90  90  90  90  91  91  92  92  92  92  92  92  92  92\n[487]  92  92  92  92  92  92  92  93  94  94  94  95  96  96  97  97  97  97\n[505]  98  98  98  98  98  98  98  99 100 100 100 101 101 102 102 102 102 103\n[523] 103 103 104 104 105 106 106 106 106 106 106 106 106 106 106 106 107 108\n[541] 109 110 110 111 111 112 112 112 112 112 112 113 114 114 114 114 114 114\n[559] 114 115 115 115 115 115 115 115 115 116 116 116 116 116 116 116 116 116\n[577] 116 116 116 116 117 117 117 117 118 119 119 119 119 120 120 120 120 121\n[595] 122 122 122 122 122 123 123 123 124 124 124 124 124 124 124 124 124 124\n[613] 124 125 125 126 126 126 126 126 126 126 126 126 126 126 127 128 129 129\n[631] 129 129 130 130 130 130 130 130 130 130 130 130 130 130 130 130 130 130\n[649] 130 130 131 131 131 131 131 131 131 131 131 131 131 131 131 131 131 132\n[667] 132 132 132 132 132 132 133 134 134 135 135 135 135 135 135 136 137 137\n[685] 138 138 139 140 140 141 141 141 141 142 142 142 143 143 143 143 144 144\n[703] 145 145 146 147 148 149 150 151 152 153 154 154 154 154 155 156 156 156\n[721] 157 157 157 157 157 157 157 157 157 157 157 157 157 157 157 157 157 157\n[739] 157 157 157 157 157 158 158 158 158 158 158 159 160 160 160 160 160 160\n[757] 160 160 160 161 161 161 161 161 161 161 161 162 162 162 162 162 162 162\n[775] 162 162 162 162 162 163 163 163 163 163 163 163 163 163 163 164 164 164\n[793] 165 166 166 166 167 168 169 170\n\n# Kumulativni postotak Water-type Pokemona\ncumsum(pokemon_dataset$type_1 == \"Water\") / seq_along(pokemon_dataset$type_1) * 100\n\n  [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[112] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[149] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[186] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[223] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[260] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[297] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[334] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[371] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[408] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[445] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[482] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[519] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[556] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[593] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[630] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[667] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[704] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[741] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n[778] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n\n# Praćenje maksimalnog Attack viđenog do svakog reda\ncummax(pokemon_dataset$attack)\n\n  [1]  49  62  82 100 100 100 100 130 130 130 130 130 130 130 130 130 130 130\n [19] 130 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150\n [37] 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150\n [55] 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150\n [73] 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150\n [91] 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150\n[109] 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150 150\n[127] 150 150 150 150 150 150 150 150 150 150 150 155 155 155 155 155 155 155\n[145] 155 155 155 155 155 155 155 155 155 155 155 155 155 155 155 155 155 155\n[163] 155 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[181] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[199] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[217] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[235] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[253] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[271] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[289] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[307] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[325] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[343] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[361] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[379] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[397] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[415] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[433] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[451] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[469] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[487] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[505] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[523] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[541] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[559] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[577] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[595] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[613] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[631] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[649] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[667] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[685] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[703] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[721] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[739] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[757] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[775] 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190 190\n[793] 190 190 190 190 190 190 190 190\n\n# Broj Pokemona s brzinom većom od 100 akumuliran kroz skup\ncumsum(pokemon_dataset$speed &gt; 100)\n\n  [1]   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0\n [19]   0   1   1   1   2   3   3   3   3   3   3   3   3   4   4   4   4   4\n [37]   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4   4\n [55]   4   4   5   5   6   6   6   6   6   6   6   6   6   6   6   7   8   9\n [73]   9   9   9   9   9   9   9   9   9   9   9   9  10  10  10  10  10  10\n [91]  10  10  10  10  10  10  10  10  10  10  10  11  12  12  12  12  12  12\n[109]  12  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13  13\n[127]  13  13  13  13  14  14  15  15  16  16  16  17  18  18  18  18  18  18\n[145]  18  18  19  19  19  19  19  19  19  20  21  21  21  21  21  21  21  21\n[163]  22  23  24  24  24  24  24  24  24  24  24  24  24  24  24  24  24  24\n[181]  24  24  24  25  25  25  25  25  25  25  25  25  25  25  25  25  25  25\n[199]  25  25  25  25  25  25  26  26  26  26  26  26  26  27  27  27  27  27\n[217]  27  27  27  27  27  27  27  27  27  27  27  27  27  27  27  27  27  28\n[235]  28  28  28  28  28  28  28  28  28  28  28  28  28  28  29  29  29  29\n[253]  29  29  29  29  29  29  29  29  29  29  30  30  30  30  30  30  30  31\n[271]  31  31  31  31  32  33  33  33  33  33  33  33  33  33  33  33  33  33\n[289]  33  33  33  33  33  33  33  33  33  33  33  33  34  34  34  34  34  34\n[307]  34  34  34  34  34  34  34  34  34  35  35  35  35  35  35  35  35  35\n[325]  35  35  35  35  35  35  35  35  35  35  35  35  35  35  36  37  37  37\n[343]  37  37  37  37  37  37  37  38  38  38  38  38  38  38  38  38  38  38\n[361]  38  38  38  38  38  38  38  38  38  38  38  38  38  38  38  38  38  38\n[379]  38  38  38  38  38  38  38  38  38  38  38  38  38  38  38  39  39  39\n[397]  39  39  39  39  39  39  39  39  39  39  39  39  39  40  40  40  40  41\n[415]  41  41  41  42  43  44  45  45  45  45  45  45  46  46  47  48  48  49\n[433]  49  49  49  49  49  50  50  50  50  50  50  50  50  50  50  50  50  50\n[451]  50  50  50  50  50  50  50  50  50  50  50  50  50  50  50  50  51  51\n[469]  51  51  51  52  52  52  52  53  54  55  55  55  56  56  56  56  56  56\n[487]  56  56  56  56  56  56  56  57  57  57  57  57  58  58  58  58  58  58\n[505]  58  58  58  58  58  58  58  58  59  59  59  59  59  59  59  59  59  59\n[523]  59  59  59  59  59  60  60  60  61  61  61  61  61  61  61  61  61  62\n[541]  62  62  62  62  62  62  62  62  62  63  63  64  65  65  65  65  66  66\n[559]  66  66  66  66  66  66  66  66  66  66  66  67  67  68  68  69  69  70\n[577]  70  70  70  70  70  70  71  71  71  71  71  72  72  72  72  72  72  72\n[595]  72  72  72  72  72  72  72  72  72  72  72  73  73  74  74  74  74  74\n[613]  74  74  74  74  74  74  74  74  74  74  74  74  74  74  74  74  75  75\n[631]  75  75  76  76  77  77  77  77  77  77  77  77  77  77  77  77  77  77\n[649]  78  78  78  78  78  78  78  78  78  79  79  79  79  79  79  79  79  79\n[667]  79  79  79  79  79  79  79  79  79  79  80  80  81  81  81  82  82  82\n[685]  82  82  82  82  82  82  82  82  82  83  83  83  83  83  83  84  85  86\n[703]  87  88  89  90  90  90  91  91  91  91  91  92  93  93  94  94  94  94\n[721]  94  94  94  95  95  95  96  96  96  96  96  97  97  97  97  97  98  98\n[739]  98  98  98  98  98  98  99  99 100 101 101 101 101 101 101 101 101 101\n[757] 101 101 101 101 101 101 101 101 101 102 102 102 102 102 102 103 104 104\n[775] 104 104 104 104 104 104 104 104 104 104 104 104 104 104 104 104 104 105\n[793] 105 105 105 105 106 106 106 106\n\n\nKumulativni sažeci su posebno korisni pri vizualizaciji trenda kako se određena karakteristika mijenja kroz redoslijed podataka, što može otkriti obrasce povezane s redoslijedom Pokemona u skupu podataka.\nNedostajuće vrijednosti u logičkim operacijama zahtijevaju pažljivo rukovanje pri sažimanju. Većina funkcija sažimanja ima argument na.rm koji kontrolira kako se nedostajuće vrijednosti tretiraju. Ako postoje NA vrijednosti u logičkom vektoru, funkcije poput sum() i mean() vratit će NA kao rezultat osim ako se eksplicitno ne postavi na.rm = TRUE:\n\n# Brojanje Pokemona s visokim Speed, ignoriranje NA vrijednosti\nsum(pokemon_dataset$speed &gt; 100, na.rm = TRUE)\n\n[1] 106\n\n# Postotak legendarnih Pokemona, isključujući nedostajuće\nmean(pokemon_dataset$legendary == TRUE, na.rm = TRUE) * 100\n\n[1] 8.125\n\n# Provjera postoje li NA vrijednosti u Attack stupcu\nany(is.na(pokemon_dataset$attack))\n\n[1] FALSE\n\n# Ukupan broj nedostajućih vrijednosti u Defense\nsum(is.na(pokemon_dataset$defense))\n\n[1] 0\n\n# Postotak podataka s kompletnim informacijama o brzini\nmean(!is.na(pokemon_dataset$speed)) * 100\n\n[1] 100\n\n\nPravilno rukovanje nedostajućim vrijednostima osigurava da sažeci točno odražavaju dostupne podatke i sprječava neočekivane rezultate u analizi, što je kritično za pouzdanost zaključaka izvedenih iz podataka.\n\n\n0.4 Uvjetne transformacije\nUvjetne transformacije omogućavaju kreiranje novih vrijednosti ili modifikaciju postojećih na temelju logičkih uvjeta, što predstavlja fundamentalnu tehniku u pripremi i čišćenju podataka. Za razliku od funkcija sažimanja koje reduciraju vektor na jednu ili nekoliko vrijednosti, uvjetne transformacije vraćaju vektor iste duljine kao ulazni podaci, pri čemu svaki element može biti transformiran na temelju toga zadovoljava li određeni uvjet. R pruža nekoliko funkcija za provođenje uvjetnih transformacija, od kojih su najvažnije if_else() i case_when().\nFunkcija if_else() predstavlja vektoriziranu verziju standardne if-else kontrolne strukture koja omogućava odabir između dvije vrijednosti na temelju logičkog uvjeta. Ova funkcija prima tri argumenta: logički uvjet koji se testira, vrijednost koja se vraća kada je uvjet istinit, i vrijednost koja se vraća kada je uvjet lažan. Za razliku od klasične if naredbe koja radi s pojedinačnim vrijednostima, if_else() primjenjuje se na cijele vektore element po element:\n\n# Klasifikacija Pokemona kao \"Snažan\" ili \"Slab\" na temelju Attack\npokemon_dataset$attack_category &lt;- if_else(\n  pokemon_dataset$attack &gt; 100,\n  \"Snažan\",\n  \"Slab\"\n)\n\n# Određivanje je li Pokemon brz ili spor\npokemon_dataset$speed_level &lt;- if_else(\n  pokemon_dataset$speed &gt; 80,\n  \"Brz\",\n  \"Spor\"\n)\n\n# Identifikacija Pokemona s visokim HP\npokemon_dataset$high_hp &lt;- if_else(\n  pokemon_dataset$HP &gt; 90,\n  \"Visok HP\",\n  \"Normalan HP\"\n)\n\n# Kreiranje binarne oznake za legendary status\npokemon_dataset$legendary_label &lt;- if_else(\n  pokemon_dataset$legendary == TRUE,\n  \"Legendarni\",\n  \"Obični\"\n)\n\npokemon_dataset |&gt; select(name, attack, attack_category, speed, speed_level, HP, high_hp, legendary, legendary_label)\n\n# A tibble: 800 × 9\n   name         attack attack_category speed speed_level    HP high_hp legendary\n   &lt;chr&gt;         &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;lgl&gt;    \n 1 bulbasaur        49 Slab               45 Spor           45 Normal… FALSE    \n 2 ivysaur          62 Slab               60 Spor           60 Normal… FALSE    \n 3 venusaur         82 Slab               80 Spor           80 Normal… FALSE    \n 4 venusaurmeg…    100 Slab               80 Spor           80 Normal… FALSE    \n 5 charmander       52 Slab               65 Spor           39 Normal… FALSE    \n 6 charmeleon       64 Slab               80 Spor           58 Normal… FALSE    \n 7 charizard        84 Slab              100 Brz            78 Normal… FALSE    \n 8 charizardme…    130 Snažan            100 Brz            78 Normal… FALSE    \n 9 charizardme…    104 Snažan            100 Brz            78 Normal… FALSE    \n10 squirtle         48 Slab               43 Spor           44 Normal… FALSE    \n# ℹ 790 more rows\n# ℹ 1 more variable: legendary_label &lt;chr&gt;\n\n\nOvi primjeri pokazuju kako if_else() omogućava kreiranje novih kategoričkih varijabli koje opisuju karakteristike Pokemona na jednostavniji, razumljiviji način nego originalne numeričke vrijednosti.\nVažna karakteristika funkcije if_else() je da zahtijeva da obje povratne vrijednosti (za TRUE i FALSE slučajeve) budu istog tipa podataka. Ovo osigurava konzistentnost rezultirajućeg vektora i sprječava neočekivane konverzije tipova koje bi mogle uzrokovati probleme u daljnjoj analizi. Ako pokušamo kombinirati različite tipove podataka, R će prijaviti grešku:\n\n# Korektna upotreba - oba rezultata su znakovi\npokemon_dataset$power_status &lt;- if_else(\n  pokemon_dataset$total &gt; 500,\n  \"Moćan\",\n  \"Prosječan\"\n)\n\n# Korektna upotreba - oba rezultata su brojevi\npokemon_dataset$attack_bonus &lt;- if_else(\n  pokemon_dataset$type_1 == \"Fighting\",\n  10,\n  0\n)\n\n# Kreiranje numeričke oznake za generaciju\npokemon_dataset$gen_numeric &lt;- if_else(\n  pokemon_dataset$generation &lt;= 3,\n  1,\n  2\n)\n\nWarning in Ops.factor(pokemon_dataset$generation, 3): '&lt;=' not meaningful for\nfactors\n\npokemon_dataset |&gt; select(name, total, power_status, type_1, attack_bonus, generation, gen_numeric)\n\n# A tibble: 800 × 7\n   name            total power_status type_1 attack_bonus generation gen_numeric\n   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;         &lt;dbl&gt; &lt;fct&gt;            &lt;dbl&gt;\n 1 bulbasaur         318 Prosječan    grass             0 1                   NA\n 2 ivysaur           405 Prosječan    grass             0 1                   NA\n 3 venusaur          525 Moćan        grass             0 1                   NA\n 4 venusaurmega v…   625 Moćan        grass             0 1                   NA\n 5 charmander        309 Prosječan    fire              0 1                   NA\n 6 charmeleon        405 Prosječan    fire              0 1                   NA\n 7 charizard         534 Moćan        fire              0 1                   NA\n 8 charizardmega …   634 Moćan        fire              0 1                   NA\n 9 charizardmega …   634 Moćan        fire              0 1                   NA\n10 squirtle          314 Prosječan    water             0 1                   NA\n# ℹ 790 more rows\n\n\nOva ograničenja stvaraju predvidljivost u tipu rezultata i omogućavaju sigurnije programiranje, što je posebno važno pri složenijim transformacijama podataka.\nFunkcija if_else() također omogućava eksplicitno specificiranje što se događa s nedostajućim vrijednostima putem argumenta missing. Ako logički uvjet vraća NA, možemo odrediti koja vrijednost će biti korištena umjesto standardnog NA:\n\n# Rukovanje nedostajućim vrijednostima s default vrijednošću\npokemon_dataset$defense_category &lt;- if_else(\n  pokemon_dataset$defense &gt; 80,\n  \"Jaka obrana\",\n  \"Slaba obrana\",\n  missing = \"Nepoznato\"\n)\n\n# Klasifikacija brzine s rukovanjem NA\npokemon_dataset$speed_class &lt;- if_else(\n  pokemon_dataset$speed &gt; 100,\n  \"Vrlo brz\",\n  \"Umjereno brz\",\n  missing = \"Podaci nedostaju\"\n)\n\npokemon_dataset |&gt; select(name, defense, defense_category, speed, speed_class)\n\n# A tibble: 800 × 5\n   name                      defense defense_category speed speed_class \n   &lt;chr&gt;                       &lt;dbl&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;chr&gt;       \n 1 bulbasaur                      49 Slaba obrana        45 Umjereno brz\n 2 ivysaur                        63 Slaba obrana        60 Umjereno brz\n 3 venusaur                       83 Jaka obrana         80 Umjereno brz\n 4 venusaurmega venusaur         123 Jaka obrana         80 Umjereno brz\n 5 charmander                     43 Slaba obrana        65 Umjereno brz\n 6 charmeleon                     58 Slaba obrana        80 Umjereno brz\n 7 charizard                      78 Slaba obrana       100 Umjereno brz\n 8 charizardmega charizard x     111 Jaka obrana        100 Umjereno brz\n 9 charizardmega charizard y      78 Slaba obrana       100 Umjereno brz\n10 squirtle                       65 Slaba obrana        43 Umjereno brz\n# ℹ 790 more rows\n\n\nOva funkcionalnost je kritična pri radu s realnim skupovima podataka koji često sadrže nepotpune informacije, omogućavajući analitičarima da eksplicitno definiraju kako će se tretirati nepoznate vrijednosti.\nFunkcija case_when() proširuje koncept uvjetne transformacije na više od dva moguća ishoda, omogućavajući sekvencu uvjeta koji se provjeravaju redom dok se ne pronađe prvi istinit uvjet. Svaki uvjet specificira se formulom gdje lijeva strana predstavlja logički test, a desna strana vrijednost koja će biti vraćena ako je test istinit:\n\n# Višestruka klasifikacija snage Pokemona\npokemon_dataset$power_tier &lt;- case_when(\n  pokemon_dataset$total &gt; 600 ~ \"S Tier\",\n  pokemon_dataset$total &gt; 500 ~ \"A Tier\",\n  pokemon_dataset$total &gt; 400 ~ \"B Tier\",\n  pokemon_dataset$total &gt; 300 ~ \"C Tier\",\n  TRUE ~ \"D Tier\"\n)\n\n# Kategorizacija Pokemona prema Attack\npokemon_dataset$attack_class &lt;- case_when(\n  pokemon_dataset$attack &gt; 130 ~ \"Vrlo visok\",\n  pokemon_dataset$attack &gt; 100 ~ \"Visok\",\n  pokemon_dataset$attack &gt; 70 ~ \"Srednji\",\n  pokemon_dataset$attack &gt; 40 ~ \"Nizak\",\n  TRUE ~ \"Vrlo nizak\"\n)\n\n# Klasifikacija na temelju Type_1\npokemon_dataset$type_group &lt;- case_when(\n  pokemon_dataset$type_1 %in% c(\"Fire\", \"Water\", \"Grass\") ~ \"Početni tipovi\",\n  pokemon_dataset$type_1 %in% c(\"Dragon\", \"Psychic\", \"Dark\") ~ \"Specijalni tipovi\",\n  pokemon_dataset$type_1 %in% c(\"Normal\", \"Flying\") ~ \"Česti tipovi\",\n  TRUE ~ \"Ostali tipovi\"\n)\n\npokemon_dataset |&gt; select(name, total, power_tier, attack, attack_class, type_1, type_group)\n\n# A tibble: 800 × 7\n   name                   total power_tier attack attack_class type_1 type_group\n   &lt;chr&gt;                  &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;  &lt;chr&gt;     \n 1 bulbasaur                318 C Tier         49 Nizak        grass  Ostali ti…\n 2 ivysaur                  405 B Tier         62 Nizak        grass  Ostali ti…\n 3 venusaur                 525 A Tier         82 Srednji      grass  Ostali ti…\n 4 venusaurmega venusaur    625 S Tier        100 Srednji      grass  Ostali ti…\n 5 charmander               309 C Tier         52 Nizak        fire   Ostali ti…\n 6 charmeleon               405 B Tier         64 Nizak        fire   Ostali ti…\n 7 charizard                534 A Tier         84 Srednji      fire   Ostali ti…\n 8 charizardmega chariza…   634 S Tier        130 Visok        fire   Ostali ti…\n 9 charizardmega chariza…   634 S Tier        104 Visok        fire   Ostali ti…\n10 squirtle                 314 C Tier         48 Nizak        water  Ostali ti…\n# ℹ 790 more rows\n\n\nU ovim primjerima, uvjeti se evaluiraju sekvencijalno odozgo prema dolje, a čim je jedan uvjet zadovoljen, evaluacija se zaustavlja i vraća se odgovarajuća vrijednost. Korištenje TRUE kao posljednjeg uvjeta osigurava da svi slučajevi koji ne zadovoljavaju prethodne uvjete dobiju default vrijednost.\nFunkcija case_when() posebno je korisna pri kreiranju složenih kategorizacija koje kombiniraju više različitih uvjeta i varijabli. Za razliku od ugniježđenih if_else() poziva koji mogu postati teško čitljivi, case_when() održava kod čistim i razumljivim:\n\n# Složena kategorizacija na temelju više karakteristika\npokemon_dataset$battle_role &lt;- case_when(\n  pokemon_dataset$attack &gt; 120 & pokemon_dataset$speed &gt; 100 ~ \"Brzi napadač\",\n  pokemon_dataset$attack &gt; 120 & pokemon_dataset$speed &lt;= 100 ~ \"Spori napadač\",\n  pokemon_dataset$defense &gt; 120 & pokemon_dataset$HP &gt; 100 ~ \"Tank\",\n  pokemon_dataset$speed &gt; 120 ~ \"Speedster\",\n  pokemon_dataset$HP &gt; 120 ~ \"Izdržljiv\",\n  TRUE ~ \"Balansirani\"\n)\n\n# Kategorizacija prema generaciji i snazi\npokemon_dataset$pokemon_era &lt;- case_when(\n  as.numeric(pokemon_dataset$generation) &lt;= 2 & pokemon_dataset$total &gt; 500 ~ \"Stari moćni\",\n  as.numeric(pokemon_dataset$generation) &lt;= 2 & pokemon_dataset$total &lt;= 500 ~ \"Stari obični\",\n  as.numeric(pokemon_dataset$generation) &gt; 2 & pokemon_dataset$total &gt; 500 ~ \"Novi moćni\",\n  as.numeric(pokemon_dataset$generation) &gt; 2 & pokemon_dataset$total &lt;= 500 ~ \"Novi obični\",\n  TRUE ~ \"Nepoznato\"\n)\n\n# Identifikacija specifičnih kombinacija tipova i statistika\npokemon_dataset$special_category &lt;- case_when(\n  pokemon_dataset$type_1 == \"Dragon\" & pokemon_dataset$legendary == TRUE ~ \"Legendarni Dragon\",\n  pokemon_dataset$type_1 == \"Psychic\" & pokemon_dataset$special_attack &gt; 120 ~ \"Moćni Psychic\",\n  pokemon_dataset$type_1 == \"Fighting\" & pokemon_dataset$attack &gt; 130 ~ \"Elitni borac\",\n  pokemon_dataset$legendary == TRUE ~ \"Ostali legendarni\",\n  TRUE ~ \"Standardni Pokemon\"\n)\n\nOvi složeni primjeri demonstriraju kako case_when() omogućava kreiranje sofisticiranih klasifikacijskih shema koje uzimaju u obzir višestruke dimenzije podataka istovremeno.\nRedoslijed uvjeta u case_when() funkciji je kritičan jer se uvjeti evaluiraju sekvencom, a čim je jedan zadovoljen, preostali se ignoriraju. Stoga je važno staviti specifičnije uvjete prije općenitijih kako bi se osiguralo da svaki element bude pravilno klasificiran:\n\n# POGREŠAN redoslijed - općenitiji uvjet prvo\npokemon_dataset$wrong_classification &lt;- case_when(\n  pokemon_dataset$total &gt; 300 ~ \"Jak\",\n  pokemon_dataset$total &gt; 500 ~ \"Vrlo jak\",\n  TRUE ~ \"Slab\"\n)\n\n# ISPRAVAN redoslijed - specifičniji uvjeti prvo\npokemon_dataset$correct_classification &lt;- case_when(\n  pokemon_dataset$total &gt; 500 ~ \"Vrlo jak\",\n  pokemon_dataset$total &gt; 300 ~ \"Jak\",\n  TRUE ~ \"Slab\"\n)\n\n# Demonstration s Attack statistikom\npokemon_dataset$attack_rating &lt;- case_when(\n  pokemon_dataset$attack &gt;= 150 ~ \"Ekspertni napad\",\n  pokemon_dataset$attack &gt;= 120 ~ \"Odličan napad\",\n  pokemon_dataset$attack &gt;= 90 ~ \"Dobar napad\",\n  pokemon_dataset$attack &gt;= 60 ~ \"Pristojan napad\",\n  TRUE ~ \"Slab napad\"\n)\n\nPrvi primjer pokazuje čest propust gdje općenitiji uvjet hvata sve slučajeve prije nego što specifičniji uvjet bude provjeren, dok drugi primjer demonstrira ispravan pristup koji osigurava točnu klasifikaciju.\nFunkcije if_else() i case_when() mogu se kombinirati s drugim transformacijama podataka za kreiranje deriviranih varijabli koje obogaćuju analitičke mogućnosti. Ove nove varijable mogu olakšati vizualizaciju, omogućiti grupiranje za agregirane analize, ili poslužiti kao značajke u modeliranju:\n\n# Kreiranje kompozitne ocjene na temelju više statistika\npokemon_dataset$offensive_score &lt;- pokemon_dataset$attack + pokemon_dataset$special_attack\npokemon_dataset$offensive_category &lt;- case_when(\n  pokemon_dataset$offensive_score &gt; 200 ~ \"Elitni napadač\",\n  pokemon_dataset$offensive_score &gt; 150 ~ \"Jak napadač\",\n  pokemon_dataset$offensive_score &gt; 100 ~ \"Prosječni napadač\",\n  TRUE ~ \"Slab napadač\"\n)\n\n# Balans između napada i obrane\npokemon_dataset$balance_ratio &lt;- pokemon_dataset$attack / pokemon_dataset$defense\npokemon_dataset$playstyle &lt;- case_when(\n  pokemon_dataset$balance_ratio &gt; 1.5 ~ \"Ofenzivan\",\n  pokemon_dataset$balance_ratio &lt; 0.67 ~ \"Defenzivan\",\n  TRUE ~ \"Balansiran\"\n)\n\n# Kombinirana kategorizacija legendary statusa i generacije\npokemon_dataset$pokemon_prestige &lt;- case_when(\n  pokemon_dataset$legendary == TRUE & pokemon_dataset$generation == 1 ~ \"Originalni legendarni\",\n  pokemon_dataset$legendary == TRUE ~ \"Legendarni\",\n  pokemon_dataset$generation == 1 & pokemon_dataset$total &gt; 450 ~ \"Klasični jako\",\n  pokemon_dataset$generation == 1 ~ \"Klasični\",\n  TRUE ~ \"Moderni\"\n)\n\nOvi primjeri ilustriraju kako uvjetne transformacije mogu kreirati nove perspektive na podatke koje nisu izravno vidljive iz originalnih varijabli, omogućavajući bogatiju interpretaciju i analizu.\nUvjetne transformacije također mogu biti korištene za ispravljanje ili normalizaciju podataka, zamjenu outliera, ili popunjavanje nedostajućih vrijednosti na temelju logike domene:\n\n# Korekcija potencijalno pogrešnih vrijednosti\npokemon_dataset$corrected_speed &lt;- if_else(\n  pokemon_dataset$speed &gt; 200,\n  NA_real_,\n  pokemon_dataset$speed\n)\n\n# Popunjavanje nedostajućih vrijednosti na temelju kategorije\npokemon_dataset$estimated_attack &lt;- case_when(\n  !is.na(pokemon_dataset$attack) ~ pokemon_dataset$attack,\n  pokemon_dataset$legendary == TRUE ~ 120,\n  pokemon_dataset$type_1 == \"Fighting\" ~ 100,\n  TRUE ~ 70\n)\n\n# Normalizacija kategorija s različitim zapisima\npokemon_dataset$standardized_type &lt;- case_when(\n  pokemon_dataset$type_1 %in% c(\"water\", \"WATER\", \"Water\") ~ \"Water\",\n  pokemon_dataset$type_1 %in% c(\"fire\", \"FIRE\", \"Fire\") ~ \"Fire\",\n  TRUE ~ pokemon_dataset$type_1\n)\n\nOve tehnike čišćenja podataka osiguravaju konzistentnost i kvalitetu skupa podataka, što je preduvjet za pouzdanu analizu i modeliranje.",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Logičke vrijednosti</span>"
    ]
  },
  {
    "objectID": "03_06_faktori.html",
    "href": "03_06_faktori.html",
    "title": "9  Faktori",
    "section": "",
    "text": "Faktori (Factors) su ključna vrsta podataka u R-u koja se koristi za rad s kategorijskim varijablama koje imaju konačan i poznati skup mogućih vrijednosti. Njihovo je glavno obilježje da postoji ograničen broj mogućih kategorija koje faktori mogu poprimiti. Primjeri kategorijskih faktora varijable kao što je je spol (muški, ženski ili drugi spolovi), dani u tjednu (ponedjeljak, utorak, srijeda itd.), mjeseci (siječanj, veljača, ožujak itd.) bračni status (samac, oženjen, razveden, udovac i sl.) ocjene na Likertovoj skali (npr. od “u potpunosti se ne slažem” do “u potpunosti se slažem”).\nZa kreiranje faktora u R-u koristi se funkcija factor(). Funkcija uzima listu karakternih vrijednosti od kojih se stvaraju faktori.\n\n\n\n\n\n\nTipFunkcija factor()\n\n\n\n\n\nFunkcija factor() je temeljna funkcija u R-u koja pripada osnovnom skupu funkcija. Funkcija služi za pretvaranje vektora u faktor, odnosno omogućuje R-u da prepozna koje varijable predstavljaju kategorije umjesto kontinuiranih vrijednosti. Ovo je ključno jer R tretira faktore i obične vektore različito u statističkim modelima, vizualizacijama i drugim analizama.\n\n\n\n\n\n\n\nAtgument\nObjašnjenje\n\n\n\n\nx\nVektor podataka koji sadrži podatke koji se pretvaraju u faktor.\n\n\nlevels\nNeobavezni vektor jedinstvenih vrijednosti koje vektor može imati. Zadana vrijednost je jedinstven skup vrijednosti dobiven pomoću as.character(x), sortiran u rastućem redoslijed od x.\n\n\nlabels\nMože biti neobavezni znakovni vektor za razine (u istom redoslijed kao levels) ili znakovni niz.\n\n\nexclude\nVektor vrijednosti koje treba isključiti pri formiranju skupa razina. Ovo može biti faktor s istim skupom razina kao x ili treba biti character.\n\n\nordered\nLogička vrijednost koja određuje trebaju li se razine poredati u danom redoslijedu. Kada je TRUE, stvara se uređeni faktor koji implicira hijerarhiju između razina.\n\n\nnmax\nGornja granica broja razina.\n\n\nifany\nDodaje NA razinu ako se koristi. Ovo kontrolira hoće li se automatski dodati NA kao razina faktora.\n\n\n\n\n\n\n\n\n\n\n\n\nNotePrimjer\n\n\n\n\n\n\npokemon_types &lt;- c(\"water\", \"normal\", \"grass\", \"bug\", \"psychic\", \"fire\", \"electric\", \"rock\", \"dragon\", \"ghost\")\nfactor(\n  x = pokemon_types,\n  ordered = FALSE\n)\n\n [1] water    normal   grass    bug      psychic  fire     electric rock    \n [9] dragon   ghost   \nLevels: bug dragon electric fire ghost grass normal psychic rock water\n\ngenerations &lt;- c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\")\npokemon_generations &lt;- factor(\n  x = generations,\n  levels = c(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"),\n  labels = c(\"Prva generacija\", \"Druga generacija\", \"Treća generacija\", \"Četvrta generacija\", \"Peta generacija\", \"Šesta generacija\"),\n  ordered = TRUE\n)\npokemon_generations\n\n[1] Prva generacija    Druga generacija   Treća generacija   Četvrta generacija\n[5] Peta generacija    Šesta generacija  \n6 Levels: Prva generacija &lt; Druga generacija &lt; ... &lt; Šesta generacija\n\nprint(pokemon_types[c(1, 4, 5)])\n\n[1] \"water\"   \"bug\"     \"psychic\"\n\n\n\n\n\nZa dodatne provjere provjere ili modifikacije razina već napravljenog faktora može se koristiti funkcija levels().\n\n\n\n\n\n\nTipFunkcija levels()\n\n\n\n\n\nFunkcija levels() ima svrhu dohvaćanja razina faktora kada se pozove bez dodjele, ali i postavljanja razina kada se koristi s operatorom dodjele omogućujući mijenjanje naziva razina ili dodavanje novih razina\n\n\n\n\n\n\n\nArgument\nObjašnjenje\n\n\n\n\nx\nGlavni argument koji predstavlja faktor čije razine želite dohvatiti ili modificirati.\n\n\nvalue\nKoristi se kada mijenjamo razine faktora pomoću operatora dodjele (&lt;-), a tip vrijednosti ovisi o metodi:\n\n\n\n\nAko postavimo NULL (zadano), onda će se ukloniti sve razine, a ako se postavi znakovni vektor, onda će se definirati nove razine faktora.\nZa faktor metodu se stavlja vektor znakovnih nizova s duljinom najmanje jednakom broju razina od x ili imenovani popis koji specificira kako preimenovati razine. Duži vektor omogućuje dodavanje novih razina, dok imenovani popis omogućuje precizno mapiranje starih naziva razina u nove. |\n\n\n\n\n\n# Dohvaćanje razina\nlevels(pokemon_generations)\n\n[1] \"Prva generacija\"    \"Druga generacija\"   \"Treća generacija\"  \n[4] \"Četvrta generacija\" \"Peta generacija\"    \"Šesta generacija\"  \n\n# Mijenjanje naziva razina\nlevels(pokemon_generations) &lt;- c(\"PRVA GENERACIJA\", \"DRUGA GENERACIJA\", \"TREĆA GENERACIJA\", \"ČETVRTA GENERACIJA\", \"PETA GENERACIJA\", \"ŠESTA GENERACIJA\")\n\nlevels(pokemon_generations) &lt;- c(levels(pokemon_generations), \"SEDMA GENERACIJA\")\n\n# Dodavanje nove razine\nlevels(pokemon_generations) &lt;- c(\"PRVA GENERACIJA\", \"DRUGA GENERACIJA\", \"TREĆA GENERACIJA\", \"ČETVRTA GENERACIJA\", \"PETA GENERACIJA\", \"ŠESTA GENERACIJA\", \"SEDMA GENERACIJA\")\n\npokemon_generations\n\n[1] PRVA GENERACIJA    DRUGA GENERACIJA   TREĆA GENERACIJA   ČETVRTA GENERACIJA\n[5] PETA GENERACIJA    ŠESTA GENERACIJA  \n7 Levels: PRVA GENERACIJA &lt; DRUGA GENERACIJA &lt; ... &lt; SEDMA GENERACIJA\n\n\nZa različite situacije postoje posebne funkcije forcats za rad s faktorima koje omogućuju premještanje faktora:\n\nfct_reorder() za promjenu nivoa faktora,\nfct_relevel() za mijenjanje određenih nivoa na početak,\nfct_infreq() za sortiranje nivoa po učestalosti pojavljivanja i\nfct_rev() za obrtanje redoslijeda nivoa.\n\nOve se funkcije uobičajeno koriste kod vizualizacije faktora u ggplot2 paketu, a izvan vizualizacija nemaju puno svrhe.\nJoš je jedna mogućnost u radu s faktorima promjena njihovih vrijednosti. Ovo omogućuje da se razjasne leveli, odnosno nazivi faktora, sažmu nivoi ili promijene nazivi nivoa. To se u R-u omogućuje funkcijom fct_recode().\n\n\n\n\n\n\nTipFunkcija fct_recode()\n\n\n\n\n\nFunkcija fct_recode() omogućuje promjenu vrijednosti (naziva) razina faktora.\nArgument | Objašnjenje |\n.f | faktor (ili znakovni vektor) čije razine želimo promijeniti, lijeva strana predstavlja novu razinu, a desna strana staru razinu, razine koje nisu spomenute ostat će nepromijenjene, a razine se mogu ukloniti tako da im se dodijeli NULL |\n\n\n\n\npokemon_dataset |&gt;\n  mutate(\n    type_1 = fct_recode(type_1,\n      \"vodeni\" = \"water\",\n      \"normalni\" = \"normal\",\n      \"zemljani\" = \"grass\",\n      \"buba\" = \"bug\",\n      \"psio\" = \"psychic\",\n      \"vatreni\" = \"fire\",\n      \"strujni\" = \"electric\",\n      \"zemljani\" = \"rock\",\n      \"zmaj\" = \"dragon\",\n      \"duh\" = \"ghost\"\n    )\n  )\n\n# A tibble: 800 × 13\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1     1 bulbasaur       zemlj… poison   318    45     49      49             65\n 2     2 ivysaur         zemlj… poison   405    60     62      63             80\n 3     3 venusaur        zemlj… poison   525    80     82      83            100\n 4     3 venusaurmega v… zemlj… poison   625    80    100     123            122\n 5     4 charmander      vatre… &lt;NA&gt;     309    39     52      43             60\n 6     5 charmeleon      vatre… &lt;NA&gt;     405    58     64      58             80\n 7     6 charizard       vatre… flying   534    78     84      78            109\n 8     6 charizardmega … vatre… dragon   634    78    130     111            130\n 9     6 charizardmega … vatre… flying   634    78    104      78            159\n10     7 squirtle        vodeni &lt;NA&gt;     314    44     48      65             50\n# ℹ 790 more rows\n# ℹ 4 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;\n\n\nJedna od karakteristika faktora je mogućnost njihovog hijerarhiziranja. Drugim riječima, faktori se mogu grupirati u različite grupe faktora na temelju neke zajedničke karakteristike. Time se omogućuje jednostavno sažimanje velikog broja kategorija u manji skup s kojim se lakše upravlja. Za to unutar forcats paketa postoji funkcija fct_collapse().\n\n\n\n\n\n\nTipFunkcija fct_collapse()\n\n\n\n\n\nFunkcija fct_collapse() je specijalizirana varijanta funkcije fct_recode() koja je posebno dizajnirana za grupiranje više razina faktora u manje grupa.\nArgumenti | Objašnjenje |\n.f | faktor čije razine grupiraju |\n... | serija imenovanih znakovnih vektora gdje je naziv lijevoj strani nova grupa, a vrijednost vektora na desnoj strani |\nother_level | vrijednost razine koja se koristi za “ostale” vrijednosti |\n\n\n\n\npokemon_dataset_type_groups &lt;- pokemon_dataset |&gt;\n  mutate(\n    type_groups = fct_collapse(\n      .f = pokemon_dataset$type_1,\n      \"elementary types\" = c(\"fire\", \"water\", \"grass\", \"electric\", \"rock\"),\n      \"normal pokemons\" = \"normal\",\n      \"creature pokemons\" = c(\"bug\", \"dragon\", \"ghost\"),\n      other_level = \"other types\"\n    )\n  )\n\npokemon_dataset_type_groups\n\n# A tibble: 800 × 14\n      id name            type_1 type_2 total    HP attack defense special_attack\n   &lt;dbl&gt; &lt;chr&gt;           &lt;fct&gt;  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;          &lt;dbl&gt;\n 1     1 bulbasaur       grass  poison   318    45     49      49             65\n 2     2 ivysaur         grass  poison   405    60     62      63             80\n 3     3 venusaur        grass  poison   525    80     82      83            100\n 4     3 venusaurmega v… grass  poison   625    80    100     123            122\n 5     4 charmander      fire   &lt;NA&gt;     309    39     52      43             60\n 6     5 charmeleon      fire   &lt;NA&gt;     405    58     64      58             80\n 7     6 charizard       fire   flying   534    78     84      78            109\n 8     6 charizardmega … fire   dragon   634    78    130     111            130\n 9     6 charizardmega … fire   flying   634    78    104      78            159\n10     7 squirtle        water  &lt;NA&gt;     314    44     48      65             50\n# ℹ 790 more rows\n# ℹ 5 more variables: special_defense &lt;dbl&gt;, speed &lt;dbl&gt;, generation &lt;fct&gt;,\n#   legendary &lt;lgl&gt;, type_groups &lt;fct&gt;\n\n\n\n\n\n\n\n\nTipFunkcija fct_lump*()\n\n\n\n\n\nforcats paket sadrži i posebnu skupinu fct_lump*() funkcija za sažimanje malih grupa u faktoru u jednu “Other” kategoriju. Ovo je korisno kada imamo faktor s mnogo razina, a neke se pojavljuju vrlo rijetko.\n\nfct_lump_min() - sažima razine koje se pojavljuju manje od min puta,\nfct_lump_prop() - sažima razine koje se pojavljuju u manje od (ili jednako) prop * n slučajeva,\nfct_lump_n() - zadržava samo n najčešćih (ili najrjeđih ako je n &lt; 0) razina i\nfct_lump_lowfreq() - sažima najrjeđe razine osiguravajući da “Other” i dalje ostane najmanja razina.\n\nArgumenti | Objašnjenje |\nf | faktor (ili znakovni vektor) koji želite sažeti |\nn za fct_lump_n() | Pozitivni n: zadržava n najčešćih razina, Negativni n: zadržava n najrjeđih razina |\nprop za fct_lump_prop() | Pozitivni prop: sažima razine koje se ne pojavljuju barem prop vremena, Negativni prop: sažima razine koje se ne pojavljuju najviše -prop vremena\nminza fct_lump_min() | zadržava razine koje se pojavljuju barem min puta |\nw | neobavezni numerički vektor koji daje težine za učestalost svake vrijednosti |\nother_level | vrijednost razine koja se koristi za “ostale” vrijednosti |\nties.method | znakovni niz koji specificira kako se tretiraju izjednačenja |",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Faktori</span>"
    ]
  },
  {
    "objectID": "03_07_nizovi.html",
    "href": "03_07_nizovi.html",
    "title": "10  Nizovi",
    "section": "",
    "text": "Nizovi (Strings) predstavljaju temeljnu vrstu podataka koja se sastoji od sekvence znakova. Posebno su važni jer omogućuju pohranu i manipulaciju tekstualnih informacija koje se često nalaze u velikim količinama podataka. U istraživanju i analizi podataka rijetko se susrećemo sa čisto numeričkim podacima. Umjesto toga, podaci često dolaze u obliku koji kombinira brojčane vrijednosti s opisnim informacijama, kategorijskim varijablama, identifikatorima ili metapodacima koji su po svojoj prirodi tekstualni podaci.\nVažnost nizova u znanosti o podacima proizlazi iz nekoliko ključnih činjenica. Prvo, podaci iz stvarnog svijeta često dolaze u nestrukturiranom ili polustrukturiranom obliku što znači da sadrže mnoge tekstualne elemente koje je potrebno obraditi prije analize. Drugo, nizovi omogućuju pohranu složenih informacija poput imena, adresa, opisa proizvoda, komentara korisnika ili bilo koje druge tekstualne informacije koja može biti relevantna za analizu.\nRad s nizovima uključuje raznovrsne operacije poput stvaranja nizova, kombiniranja višestrukih nizova u složenije strukture te izdvajanja specifičnih dijelova informacija iz postojećih nizova. Ove operacije su ključne za pripremu podataka, čišćenje podataka i pretvaranje sirovih podataka u oblik pogodan za analizu.\nNizovi služe kao most između sirovih, nestrukturiranih podataka i strukturiranih podatkovnih okvira pogodnih za statističku analizu. Oni omogućuju transformaciju kvalitativnih informacija u kvantitativne mjere kroz različite tehnike poput brojanja pojavljivanja određenih riječi, ekstraktiranja uzoraka ili kategorizacije teksta prema unaprijed definiranim kriterijima. U širem kontekstu znanosti o podacima, nizovi su temelj za naprednije tehnike poput analize prirodnog jezika, rudarenja teksta i semantičke analize.\nNajbolji način za rad s nizovima u R-u je pomoću paketa stringr koji je dio tidyverse ekosustava i predstavlja specijalizirani skup funkcija namijenjen radu s nizovima u R-u. Paket je razvijen s ciljem pružanja konzistentnog i intuitivnog sučelja za sve osnovne operacije nad nizovima. Sve funkcije u stringr paketu počinju prefiksom str_ što omogućuje njegovo jednostavno prepoznavanje i korištenje. Paket je dizajniran prema principima tidyverse paketa što znači da poštuje uobičajena tidyverse pravila za rukovanje podacima. Ova konzistentnost jednostavnim za kombinaciju s drugim paketima poput dplyr, ggplot2 i tidyr.\nNizove možemo stvarati koristeći jednostruke navodnike (') ili dvostruke navodnike (\"). Nema razlike u ponašanju između ove dvije vrste navodnika. Preporučeno je korištenje korištenje dvostrukih navodnika, osim ako niz ne sadrži više dvostrukih navodnika kao znakove niza pa se, za razlikovanje navodnika koji definiraju niz i navodnika koji su dio samog niza, koriste jednostruki navodnici. Ovakav pristup osigurava konzistentnost u kodiranju i smanjuje mogućnost pogrešaka.\n\ncharmander_string &lt;- \"Charmander's tail flame shows its emotions\"\ncharmander_string\n\n[1] \"Charmander's tail flame shows its emotions\"\n\npikachu_string_1 &lt;- 'Pikachu is an \"Electric\" type Pokemon'\npikachu_string_1\n\n[1] \"Pikachu is an \\\"Electric\\\" type Pokemon\"\n\n\nZa uključivanje literalnih jednostrukih ili dvostrukih navodnika u niz, možemo koristiti znak \\. Ovaj mehanizam omogućuje uključivanje znakova koji inače imaju posebno značenje u R sintaksi.\n\npikachu_string_2 &lt;- \"Pikachu is an \\\"Electric\\\" type Pokemon\"\npikachu_string_2\n\n[1] \"Pikachu is an \\\"Electric\\\" type Pokemon\"\n\n\nIspisani prikaz nizova u dosadašnjim ispisima nije isti kao tekstualni niz jer ispisani prikaz prikazuje izlaze kodova, a ne znakove. Kako bi se ispisao sirovi sadržaj niza koristi se funkcija str_view().\n\n\n\n\n\n\nTipFunkcija str_view()\n\n\n\n\n\nFunkcija str_view() predstavlja specijalizirani alat za vizualno pregledavanje nizova i uzoraka unutar njih.\n\n\n\n\n\n\n\nArgument\nObjašnjenje\n\n\n\n\nstring\nulazni vektor koji može biti karakter vektor ili bilo što što se može pretvoriti u karakter vektor\n\n\npattern\ndefinira uzorak za traženje unutar nizova. Zadana interpretacija je regularni izraz. Funkcija podržava nekoliko različitih načina interpretacije uzorka: regularni izrazi (omogućuju pretraživanje uzoraka), fixed() funkcije omogućuje brže pretraživanje točnih znakova bez interpretacije kao regularni izraz, coll() funkcija respektira pravila poklapanja znakova za specificiranu lokalizaciju, boundary() funkcija za granice znakova, riječi, redaka i rečenica.\n\n\nmatch\nkontrolira koje elemente prikazati kada je pattern specificiran: TRUE (zadano) - prikazuje samo elemente koji se poklapaju s uzorkom, NA - prikazuje sve elemente bez obzira na poklapanje, FALSE - prikazuje samo elemente koji se NE poklapaju s uzorkom\n\n\nhtml\nodređuje tip izlaza: TRUE - stvara HTML widget koji omogućuje interaktivni prikaz, FALSE - koristi ANSI escape sekvence za stiliziranje u konzoli\n\n\nuse_escapes\nkontrolira prikaz ne-ASCII znakova: TRUE - svi ne-ASCII znakovi prikazuju se pomoću Unicode escape sekvenci, FALSE - znakovi se prikazuju u svojem prirodnom obliku\n\n\n\n\n\n\n\npokemon_descriptions &lt;- c(\"Pikachu is \\\"Electric\\\" type Pokemon\", \"Charmander's tail flame shows its emotions\", \"Bulbasaur can go days without eating thanks to photosynthesis\")\n\npokemon_descriptions\n\n[1] \"Pikachu is \\\"Electric\\\" type Pokemon\"                         \n[2] \"Charmander's tail flame shows its emotions\"                   \n[3] \"Bulbasaur can go days without eating thanks to photosynthesis\"\n\nstr_view(pokemon_descriptions)\n\n[1] │ Pikachu is \"Electric\" type Pokemon\n[2] │ Charmander's tail flame shows its emotions\n[3] │ Bulbasaur can go days without eating thanks to photosynthesis\n\n\nStvaranje nizova s više navodnika ili obrnutih kosih crta može postati zbunjujuće i može doći do mnogo pogrešaka. Za rješavanje ovog problema, R uvodi koncept raw nizova koji obično počinju s r\"( i završavaju s )\" znakovima što omogućuje pisanje složenijih nizova bez potrebe za escape sekvencama.\n\npokemon_raw_strings &lt;- c(\n  r\"(Ash's Pokédex entry: \"Pikachu - Electric type. Height: 1'04\" Weight: 13.2 lbs\")\",\n  r\"(Team Rocket's plan: Find Pikachu -&gt; Capture Pikachu -&gt; Give to Boss -&gt; Get promoted)\",\n  r\"(File path: C:\\Users\\Trainer\\Documents\\Pokemon\\Pikachu\\battle_stats.txt)\"\n)\n\nstr_view(pokemon_raw_strings)\n\n[1] │ Ash's Pokédex entry: \"Pikachu - Electric type. Height: 1'04\" Weight: 13.2 lbs\"\n[2] │ Team Rocket's plan: Find Pikachu -&gt; Capture Pikachu -&gt; Give to Boss -&gt; Get promoted\n[3] │ File path: C:\\Users\\Trainer\\Documents\\Pokemon\\Pikachu\\battle_stats.txt\n\n\nPostoji još nekoliko drugih specijalnih znakova koji mogu biti korisni. Najčešći takvi znakovi su \\n za novi red i \\t za tabulator. Osim toga, nizovi mogu sadrževati i Unicode escape sekvence koje počinju s \\u ili \\U kojima se pišu znakovi poput emotikona.\n\npokemon_enter &lt;- c(\n  \"Pokemon names:\\nPikachu\\nCharmander\\nBulbasaur\\nSquirtle\",\n  \"Ash Ketchum\\nis the\\nbest trainer\\nin Pallet Town\",\n  \"Team Rocket motto:\\nPrepare for trouble!\\nAnd make it double!\",\n  \"Professor Oak said:\\n\\\"A Pokemon trainer's journey\\nis never easy,\\nbut always rewarding.\\\"\"\n)\n\nstr_view(pokemon_enter)\n\n[1] │ Pokemon names:\n    │ Pikachu\n    │ Charmander\n    │ Bulbasaur\n    │ Squirtle\n[2] │ Ash Ketchum\n    │ is the\n    │ best trainer\n    │ in Pallet Town\n[3] │ Team Rocket motto:\n    │ Prepare for trouble!\n    │ And make it double!\n[4] │ Professor Oak said:\n    │ \"A Pokemon trainer's journey\n    │ is never easy,\n    │ but always rewarding.\"\n\npokemon_tabulator &lt;- c(\n  \"Pokemon\\tType\\tLevel\\nPikachu\\tElectric\\t25\",\n  \"ID\\tName\\t\\tHP\\tAttack\\n001\\tBulbasaur\\t45\\t49\",\n  \"Trainer:\\tAsh\\t\\tBadges:\\t8\\t\\tRegion:\\tKanto\",\n  \"Move\\t\\tType\\t\\tPower\\tAccuracy\\nThunderbolt\\tElectric\\t90\\t100\"\n)\n\nstr_view(pokemon_tabulator)\n\n[1] │ Pokemon{\\t}Type{\\t}Level\n    │ Pikachu{\\t}Electric{\\t}25\n[2] │ ID{\\t}Name{\\t\\t}HP{\\t}Attack\n    │ 001{\\t}Bulbasaur{\\t}45{\\t}49\n[3] │ Trainer:{\\t}Ash{\\t\\t}Badges:{\\t}8{\\t\\t}Region:{\\t}Kanto\n[4] │ Move{\\t\\t}Type{\\t\\t}Power{\\t}Accuracy\n    │ Thunderbolt{\\t}Electric{\\t}90{\\t}100\n\npokemon_unicode_basic &lt;- c(\n  \"Pika pika! \\u2661\",\n  \"Electric attack \\u26A1\",\n  \"Fire type \\u1F525\",\n  \"Poison warning \\u2620\",\n  \"Star rating \\u2605\\u2605\\u2605\\u2605\\u2605\"\n)\n\nstr_view(pokemon_unicode_basic)\n\n[1] │ Pika pika! ♡\n[2] │ Electric attack ⚡\n[3] │ Fire type ὒ5\n[4] │ Poison warning ☠\n[5] │ Star rating ★★★★★\n\n\nSljedeći korak uključuje rad s kompleksnijim scenarijima gdje je potrebno kombinirati postojeće podatke u nove nizove, odnosno postojeće nizove u skup nizova. Ovaj pristup pomaže riješiti čest problem gdje imamo neki tekst koji želimo kombinirati s nizovima iz podatkovnih okvira. Za takvo se kombiniranje može koristiti nekoliko funkcija stringr paketa.\n\n\n\n\n\n\nTipFunkcija str_c()\n\n\n\n\n\nFunkcija str_c() kombinira više vektora znakova u jedan vektor znakova. Slična je funkciji paste0(), ali koristi tidyverse princip funkcioniranja i pravila za nedostajajuće vrijednosti.\n\n\n\n\n\n\n\nArgument\nObjašnjenje\n\n\n\n\n...\nomogućuje proslijedirvanje jednog ili više karakternih vektora koji se trebaju spojiti\n\n\nsep\ndefinira niz koji se umeće između ulaznih vektora tijekom spajanja. Ovaj argument omogućuje kontroliranje kako se elementi kombiniraju. Zadana vrijednost je prazan niz što znači da se elementi spajaju direktno bez dodatnih znakova između njih.\n\n\ncollapse\npredstavlja opcionalni niz koji se koristi za kombiniranje izlaza u jedan niz. Kada je specificiran, svi rezultirajući elementi se dodatno kombiniraju u jedan konsolidiran niz koristeći zadani separator.\n\n\n\n\n\n\n\npokemon_sentences &lt;- str_c(\n  \"Pikachu je \\\"Electric-type\\\" Pokemon.\",\n  \"Charmander's tail flame shows its emotions.\",\n  \"Bulbasaur can go days without eating thanks to photosynthesis.\",\n  \"Squirtle withdrawns into its shell when attacked.\",\n  sep = \" \"\n)\n\nstr_view(pokemon_sentences)\n\n[1] │ Pikachu je \"Electric-type\" Pokemon. Charmander's tail flame shows its emotions. Bulbasaur can go days without eating thanks to photosynthesis. Squirtle withdrawns into its shell when attacked.\n\npokemon_names &lt;- pokemon_dataset$name\n\nhead(str_c(\"Hello \", pokemon_names), 10)\n\n [1] \"Hello bulbasaur\"                 \"Hello ivysaur\"                  \n [3] \"Hello venusaur\"                  \"Hello venusaurmega venusaur\"    \n [5] \"Hello charmander\"                \"Hello charmeleon\"               \n [7] \"Hello charizard\"                 \"Hello charizardmega charizard x\"\n [9] \"Hello charizardmega charizard y\" \"Hello squirtle\"                 \n\npokemon_names_and_types &lt;- pokemon_names |&gt;\n  as.tibble() |&gt;\n  mutate(\n    name_and_type_1 = str_c(\"Pokemon called \", pokemon_names, \"is \", pokemon_dataset$type_1, \"type of Pokemon!\"),\n    name_and_type_2 = str_c(\"Pokemon called \", pokemon_names, \"is \", coalesce(pokemon_dataset$type_2, \"NO TYPE 2 \"), \"type of Pokemon!\")\n  )\n\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see `?as_tibble`.\n\nhead(pokemon_names_and_types, 10)\n\n# A tibble: 10 × 3\n   value                     name_and_type_1                     name_and_type_2\n   &lt;chr&gt;                     &lt;chr&gt;                               &lt;chr&gt;          \n 1 bulbasaur                 Pokemon called bulbasauris grassty… Pokemon called…\n 2 ivysaur                   Pokemon called ivysauris grasstype… Pokemon called…\n 3 venusaur                  Pokemon called venusauris grasstyp… Pokemon called…\n 4 venusaurmega venusaur     Pokemon called venusaurmega venusa… Pokemon called…\n 5 charmander                Pokemon called charmanderis firety… Pokemon called…\n 6 charmeleon                Pokemon called charmeleonis firety… Pokemon called…\n 7 charizard                 Pokemon called charizardis firetyp… Pokemon called…\n 8 charizardmega charizard x Pokemon called charizardmega chari… Pokemon called…\n 9 charizardmega charizard y Pokemon called charizardmega chari… Pokemon called…\n10 squirtle                  Pokemon called squirtleis watertyp… Pokemon called…\n\n\n\n\n\n\n\n\nTipFunkcija str_glue()\n\n\n\n\n\nFunkcija str_glue() predstavlja elegantan pristup kombiniranju fiksnog teksta s varijabilnim podacima. str_glue() omogućuje specificiranje jednog niza koji ima posebnu značajku unutar vitičastih zagrada. Ova funkcionalnost omogućuje prirodniju sintaksu za kombiniranje različitih podatkovnih elemenata.\n\n\n\n\n\n\n\nArgumenti\nObjašnjenje\n\n\n\n\n...\nnizovi za formatiranje\n\n\n.sep\ndefinira separator koji se koristi za odvajanje elemenata kada se kombiniraju međusobno (zadana vrijednost je prazan niz)\n\n\n.envir\nspecificira okruženje u kojem se evaluira svaki izraz (zadana vrijednost je parent.frame() što znači da se varijable traže u okruženju koje je pozvalo funkciju)\n\n\n.x\nomogućuje korištenje okruženja, liste ili podatkovnog okvira za traženje vrijednosti\n\n\n.na\nkontrolira kako se rukuje nedostajućim vrijednostima - zadana vrijednost je NA što znači da se NA vrijednosti zamjenjuju stringom “NA”, a može biti i specifičan string koji zamjenjuje NA vrijednosti zadanim tekstom i NULL koji omogućuje propagaciju nedostajućih vrijednosti\n\n\n\n\n\n\n\npokemon_names_glue &lt;- pokemon_names |&gt;\n  as.tibble() |&gt;\n  mutate( name_and_type_1 = str_glue(\"Pokemon called {pokemon_names} is {pokemon_dataset$type_1} type of Pokemon!\"))\n\nhead(pokemon_names_glue, 10)\n\n# A tibble: 10 × 2\n   value                     name_and_type_1                                    \n   &lt;chr&gt;                     &lt;glue&gt;                                             \n 1 bulbasaur                 Pokemon called bulbasaur is grass type of Pokemon! \n 2 ivysaur                   Pokemon called ivysaur is grass type of Pokemon!   \n 3 venusaur                  Pokemon called venusaur is grass type of Pokemon!  \n 4 venusaurmega venusaur     Pokemon called venusaurmega venusaur is grass type…\n 5 charmander                Pokemon called charmander is fire type of Pokemon! \n 6 charmeleon                Pokemon called charmeleon is fire type of Pokemon! \n 7 charizard                 Pokemon called charizard is fire type of Pokemon!  \n 8 charizardmega charizard x Pokemon called charizardmega charizard x is fire t…\n 9 charizardmega charizard y Pokemon called charizardmega charizard y is fire t…\n10 squirtle                  Pokemon called squirtle is water type of Pokemon!  \n\n\n\n\n\n\n\n\nTipFunkcija str_flatten()\n\n\n\n\n\nJoš jedna funkcija za povezivanje nizova je str_flatten() za kombiniranje elemenata karakternog vektora u jedan konsolidiran niz. str_flatten() prima karakter vektor i kombinira svaki element vektora u jedan niz što je čini idealnom za situacije gdje trebamo pretvoriti više vrijednosti u jednu tekstualnu reprezentaciju. str_flatten() čini pogodnom za rad s summarize() jer uvijek vraća jedan niz što je ključno za agregacijske operacije u analizi podataka.\n\n\n\n\n\n\n\nArgumenti\nObjašnjenje\n\n\n\n\nstring\nulazni vektor koji može biti karakter vektor ili bilo što što se može pretvoriti u karakter vektor\n\n\ncollapse\ndefinira niz koji se umeće između svakog dijela tijekom spajanja (zadana vrijednost je “” - prazan niz)\n\n\nlast\nniz koji se koristi umjesto finalnog separatora - str_flatten(c(\"x\", \"y\", \"z\"), \", \", last = \", i \") rezultira s “x, y, i z”\n\n\nna.rm\nkontrolira kako se rukuje nedostajućim vrijednostima - zadana vrijednost je FALSE, što znači da će rezultat biti NA ako bilo koji element ulaznog vektora sadrži NA\n\n\n\n\n\n\n\nstr_flatten(\n  c(\"Pikachu\", \"Charmander\", \"Bulbasaur\", NA, \"Squirtle\", \"Jigglypuff\", \"Meowth\", \"Psyduck\", \"Machamp\"),\n  collapse = \", \",\n  last = \" and \",\n  na.rm = TRUE\n)\n\n[1] \"Pikachu, Charmander, Bulbasaur, Squirtle, Jigglypuff, Meowth, Psyduck and Machamp\"\n\n\nNadalje, uobičajeno je da je više varijabli spojenih u jedan niz. U mnogim se situacijama analize podataka susrećemo se s podacima gdje su različite informacije kombinirane u jednom tekstualnom polju što zahtijeva tehnike za razdvajanje i ekstraktiranje relevantnih komponenti. Za njihovo se izdvajanje koriste četiri tidyr funkcije: separate_longer_delim(), separate_longer_position(), separate_wider_delim(), separate_wider_position(). Pritom logika funkcija slijedi uobičajen uzorak: separate_, zatim longer ili wider, zatim _, zatim delim ili position. Ova logična struktura odražava dva temeljna principa:\n\n\n\n\n\n\n\nSmjer transformacije podataka\nNačin razdvajanja\n\n\n\n\n_longer funkcije čine podatkovni okvir duljim stvaranjem novih redaka\ndelim dijeli niz s delimitatorom poput \", \" ili \" \"\n\n\n_wider funkcije čine podatkovni širim generiranjem novih stupaca\nposition dijeli na specificiranim širinama, poput c(3, 5, 2)\n\n\n\nRazdvajanje niza u redove (longer funkcije) obično je najkorisniji kada broj komponenti varira od reda do reda. Ovaj pristup je idealan kada imamo podatke gdje svaki red može sadržavati različit broj elemenata. Najčešći slučaj zahtijeva separate_longer_delim() za dijeljenje na temelju delimitatora. Ovaj pristup omogućuje prirodno rukovanje podacima gdje svaki red može sadržavati različit broj vrijednosti odvojen istim separatorom.\n\npokemon_teams &lt;- tibble(\n  trainer = c(\"Ash\", \"Misty\", \"Brock\", \"Gary\", \"Team Rocket\"),\n  pokemon_team = c(\n    \"Pikachu, Charizard, Bulbasaur, Squirtle, Snorlax, Lapras\",\n    \"Staryu, Starmie, Psyduck, Goldeen\", \n    \"Onix, Graveler, Crobat\",\n    \"Blastoise, Arcanine, Nidoking, Alakazam, Tyranitar\",\n    \"Meowth, Arbok, Weezing\"\n  )\n)\n\npokemon_teams\n\n# A tibble: 5 × 2\n  trainer     pokemon_team                                            \n  &lt;chr&gt;       &lt;chr&gt;                                                   \n1 Ash         Pikachu, Charizard, Bulbasaur, Squirtle, Snorlax, Lapras\n2 Misty       Staryu, Starmie, Psyduck, Goldeen                       \n3 Brock       Onix, Graveler, Crobat                                  \n4 Gary        Blastoise, Arcanine, Nidoking, Alakazam, Tyranitar      \n5 Team Rocket Meowth, Arbok, Weezing                                  \n\npokemon_teams |&gt;\n  separate_longer_delim(pokemon_team, delim = \", \")\n\n# A tibble: 21 × 2\n   trainer pokemon_team\n   &lt;chr&gt;   &lt;chr&gt;       \n 1 Ash     Pikachu     \n 2 Ash     Charizard   \n 3 Ash     Bulbasaur   \n 4 Ash     Squirtle    \n 5 Ash     Snorlax     \n 6 Ash     Lapras      \n 7 Misty   Staryu      \n 8 Misty   Starmie     \n 9 Misty   Psyduck     \n10 Misty   Goldeen     \n# ℹ 11 more rows\n\n\nRjeđe se koristi separate_longer_position(), osim kod skupova podataka koji koriste vrlo kompaktan format gdje se svaki znak koristi za bilježenje vrijednosti. Ova funkcija je korisna za rad s nasleđenim formatima podataka ili vrlo kompaktnim kodnim sustavima.\n\npokemon_stats_compact &lt;- tibble(\n  pokemon = c(\"Pikachu\", \"Charmander\", \"Bulbasaur\", \"Squirtle\"),\n  stats_string = c(\n    \"354055409050\",\n    \"394352605065\",\n    \"454549654545\",\n    \"444865504365\"\n  )\n)\n\npokemon_stats_compact\n\n# A tibble: 4 × 2\n  pokemon    stats_string\n  &lt;chr&gt;      &lt;chr&gt;       \n1 Pikachu    354055409050\n2 Charmander 394352605065\n3 Bulbasaur  454549654545\n4 Squirtle   444865504365\n\npokemon_stats_compact |&gt;\n  separate_longer_position(stats_string, width = 2) |&gt;\n  group_by(pokemon) |&gt;\n  mutate(\n    stat_name = c(\"HP\", \"Attack\", \"Defense\", \"Sp_Attack\", \"Sp_Defense\", \"Speed\"),\n    stat_value = as.numeric(stats_string)\n  ) |&gt;\n  select(-stats_string) |&gt;\n  pivot_wider(\n    values_from = stat_value,\n    names_from = stat_name\n  )\n\n# A tibble: 4 × 7\n# Groups:   pokemon [4]\n  pokemon       HP Attack Defense Sp_Attack Sp_Defense Speed\n  &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n1 Pikachu       35     40      55        40         90    50\n2 Charmander    39     43      52        60         50    65\n3 Bulbasaur     45     45      49        65         45    45\n4 Squirtle      44     48      65        50         43    65\n\n\nRazdvajanje niza u stupce korisno je kada postoji fiksiran broj komponenti u svakom nizu, a želimo ih proširiti u stupce. Ovaj pristup je idealan za strukturirane podatke s predvidljivim brojem elemenata.\nZa korištenje separate_wider_delim(), opskrbljujemo delimiter i imena u dva argumenta. Ako određeni dio nije koristan, možete koristiti NA ime da ga izostavite iz rezultata.\n\npokemon_id_codes &lt;- tibble(\n  pokemon_code = c(\n    \"025-Pikachu-Electric\",\n    \"004-Charmander-Fire\",\n    \"001-Bulbasaur-Grass\",\n    \"007-Squirtle-Water\",\n    \"150-Mewtwo-Psychic\"\n  )\n)\n\npokemon_id_codes\n\n# A tibble: 5 × 1\n  pokemon_code        \n  &lt;chr&gt;               \n1 025-Pikachu-Electric\n2 004-Charmander-Fire \n3 001-Bulbasaur-Grass \n4 007-Squirtle-Water  \n5 150-Mewtwo-Psychic  \n\npokemon_id_codes |&gt;\n  separate_wider_delim(\n    pokemon_code,\n    delim = \"-\",\n    names = c(NA, \"Name\", \"Type\")\n  )\n\n# A tibble: 5 × 2\n  Name       Type    \n  &lt;chr&gt;      &lt;chr&gt;   \n1 Pikachu    Electric\n2 Charmander Fire    \n3 Bulbasaur  Grass   \n4 Squirtle   Water   \n5 Mewtwo     Psychic \n\n\nseparate_wider_delim() zahtijeva fiksiran i poznat skup stupaca, no neki redovi nemaju očekivani broj dijelova što je čest problem u stvarnim podacima gdje format nije uvijek konzistentan. Postoje dva moguća problema, previše ili premalo dijelova, pa separate_wider_delim() pruža dva argumenta za pomoć, too_few i too_many.\nAko postoji problem premalo dijelova, R uobičajenim načinom rada izbacuje grešku pa je potrebno dodati argument too_few. Koristeći debug način rada dobivamo tri dodatna stupca:\n\n“x_ok”: omogućuje brzo pronalaženje ulaza koji su neuspješni,\n“x_pieces”: govori koliko je dijelova pronađeno u usporedbi s očekivana 3 (pomaže razumjeti koliko dijelova nedostaje),\n“x_remainder”: nije koristan kada ima premalo dijelova, ali ćemo ga vidjeti ponovo uskoro.\n\nOsim debug moda, u drugim slučajevima bolje je popuniti nedostajuće dijelove s NA što je moguće s align_start i align_end dodacima u argument - razlika je u tome gdje se postavljaju NA vrijednosti - na početak ili na kraj rezultujućeg vektora.\n\npokemon_ids_problematic &lt;- tibble(\n  pokemon_data = c(\n    \"025-Pikachu-Electric-Mouse\",\n    \"004-Charmander-Fire\",\n    \"001-Bulbasaur\",\n    \"007-Squirtle-Water-Turtle\",\n    \"150-Mewtwo-Psychic-Genetic\",\n    \"052-Meowth\",\n    \"054-Psyduck-Water\",\n    \"068\"\n  )\n)\n\npokemon_ids_problematic |&gt;\n  separate_wider_delim(\n    pokemon_data,\n    delim = \"-\",\n    names = c(\"id\", \"name\", \"type\", \"species\"),\n    too_few = \"debug\"\n  )\n\nWarning: Debug mode activated: adding variables `pokemon_data_ok`,\n`pokemon_data_pieces`, and `pokemon_data_remainder`.\n\n\n# A tibble: 8 × 8\n  id    name      type  species pokemon_data pokemon_data_ok pokemon_data_pieces\n  &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;        &lt;lgl&gt;                         &lt;int&gt;\n1 025   Pikachu   Elec… Mouse   025-Pikachu… TRUE                              4\n2 004   Charmand… Fire  &lt;NA&gt;    004-Charman… FALSE                             3\n3 001   Bulbasaur &lt;NA&gt;  &lt;NA&gt;    001-Bulbasa… FALSE                             2\n4 007   Squirtle  Water Turtle  007-Squirtl… TRUE                              4\n5 150   Mewtwo    Psyc… Genetic 150-Mewtwo-… TRUE                              4\n6 052   Meowth    &lt;NA&gt;  &lt;NA&gt;    052-Meowth   FALSE                             2\n7 054   Psyduck   Water &lt;NA&gt;    054-Psyduck… FALSE                             3\n8 068   &lt;NA&gt;      &lt;NA&gt;  &lt;NA&gt;    068          FALSE                             1\n# ℹ 1 more variable: pokemon_data_remainder &lt;chr&gt;\n\npokemon_ids_problematic |&gt;\n  separate_wider_delim(\n    pokemon_data,\n    delim = \"-\",\n    names = c(\"id\", \"name\", \"type\", \"species\"),\n    too_few = \"align_start\"\n  )\n\n# A tibble: 8 × 4\n  id    name       type     species\n  &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;  \n1 025   Pikachu    Electric Mouse  \n2 004   Charmander Fire     &lt;NA&gt;   \n3 001   Bulbasaur  &lt;NA&gt;     &lt;NA&gt;   \n4 007   Squirtle   Water    Turtle \n5 150   Mewtwo     Psychic  Genetic\n6 052   Meowth     &lt;NA&gt;     &lt;NA&gt;   \n7 054   Psyduck    Water    &lt;NA&gt;   \n8 068   &lt;NA&gt;       &lt;NA&gt;     &lt;NA&gt;   \n\npokemon_ids_problematic |&gt;\n  separate_wider_delim(\n    pokemon_data,\n    delim = \"-\",\n    names = c(\"id\", \"name\", \"type\", \"species\"),\n    too_few = \"align_end\"\n  )\n\n# A tibble: 8 × 4\n  id    name     type       species  \n  &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;    \n1 025   Pikachu  Electric   Mouse    \n2 &lt;NA&gt;  004      Charmander Fire     \n3 &lt;NA&gt;  &lt;NA&gt;     001        Bulbasaur\n4 007   Squirtle Water      Turtle   \n5 150   Mewtwo   Psychic    Genetic  \n6 &lt;NA&gt;  &lt;NA&gt;     052        Meowth   \n7 &lt;NA&gt;  054      Psyduck    Water    \n8 &lt;NA&gt;  &lt;NA&gt;     &lt;NA&gt;       068      \n\n\nIsti principi se primjenjuju ako postoji previše dijelova, no koristi se argument too_many. Koristeći debug dodaje se stupac “x_remainder” koji sada pokazuje što je “ostalo” nakon što su uzeta tri očekivana dijela, omogućujući analizu dodatnog sadržaja. U drugim se slučajevima može koristiti drop za uklanjanje suvišnih dijelova ili merge za spajanje u zadnji stupac.\n\npokemon_battles_problematic &lt;- tibble(\n  battle_info = c(\n    \"Ash-Pikachu-Victory-Quick\",\n    \"Misty-Staryu-Defeat-Long-Intense\",\n    \"Gary-Blastoise-Victory-Medium-Easy-Dominating\",\n    \"Team-Rocket-Meowth-Defeat-Short-Embarrassing-Public-Humiliating\",\n    \"Red-Charizard-Victory-Epic-Legendary\",\n    \"Blue-Venusaur-Draw-Quick-Unexpected\",\n    \"Lance-Dragonite-Victory-Legendary-Champion-Level-Incredible-Display\"\n  )\n)\n\npokemon_battles_problematic |&gt;\n  separate_wider_delim(\n    battle_info,\n    delim = \"-\",\n    names = c(\"trainer\", \"pokemon\", \"result\", \"duration\"),\n    too_many = \"debug\"\n  )\n\nWarning: Debug mode activated: adding variables `battle_info_ok`, `battle_info_pieces`,\nand `battle_info_remainder`.\n\n\n# A tibble: 7 × 8\n  trainer pokemon  result duration battle_info battle_info_ok battle_info_pieces\n  &lt;chr&gt;   &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;    &lt;chr&gt;       &lt;lgl&gt;                       &lt;int&gt;\n1 Ash     Pikachu  Victo… Quick    Ash-Pikach… TRUE                            4\n2 Misty   Staryu   Defeat Long     Misty-Star… FALSE                           5\n3 Gary    Blastoi… Victo… Medium   Gary-Blast… FALSE                           6\n4 Team    Rocket   Meowth Defeat   Team-Rocke… FALSE                           8\n5 Red     Chariza… Victo… Epic     Red-Chariz… FALSE                           5\n6 Blue    Venusaur Draw   Quick    Blue-Venus… FALSE                           5\n7 Lance   Dragoni… Victo… Legenda… Lance-Drag… FALSE                           8\n# ℹ 1 more variable: battle_info_remainder &lt;chr&gt;\n\npokemon_battles_problematic |&gt;\n  separate_wider_delim(\n    battle_info,\n    delim = \"-\",\n    names = c(\"trainer\", \"pokemon\", \"result\", \"duration\"),\n    too_many = \"drop\"\n  )\n\n# A tibble: 7 × 4\n  trainer pokemon   result  duration \n  &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;    \n1 Ash     Pikachu   Victory Quick    \n2 Misty   Staryu    Defeat  Long     \n3 Gary    Blastoise Victory Medium   \n4 Team    Rocket    Meowth  Defeat   \n5 Red     Charizard Victory Epic     \n6 Blue    Venusaur  Draw    Quick    \n7 Lance   Dragonite Victory Legendary\n\npokemon_battles_problematic |&gt;\n  separate_wider_delim(\n    battle_info,\n    delim = \"-\",\n    names = c(\"trainer\", \"pokemon\", \"result\", \"extra_info\"),\n    too_many = \"merge\"\n  )\n\n# A tibble: 7 × 4\n  trainer pokemon   result  extra_info                                  \n  &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;                                       \n1 Ash     Pikachu   Victory Quick                                       \n2 Misty   Staryu    Defeat  Long-Intense                                \n3 Gary    Blastoise Victory Medium-Easy-Dominating                      \n4 Team    Rocket    Meowth  Defeat-Short-Embarrassing-Public-Humiliating\n5 Red     Charizard Victory Epic-Legendary                              \n6 Blue    Venusaur  Draw    Quick-Unexpected                            \n7 Lance   Dragonite Victory Legendary-Champion-Level-Incredible-Display \n\n\nseparate_wider_position() radi nešto drugačije jer obično želite specificirati širinu svakog stupca. Ova funkcija koristi imenovani cjelobrojni vektor gdje ime označava novi stupac, a vrijednost broj znakova.\n\npokemon_coordinates &lt;- tibble(\n  position_data = c(\n    \"1253456782\",  # X:125, Y:345, Z:67, Level:82\n    \"0982341154\",  # X:098, Y:234, Z:11, Level:54  \n    \"1566778893\",  # X:156, Y:677, Z:88, Level:93\n    \"2013445561\",  # X:201, Y:344, Z:55, Level:61\n    \"3335557773\"   # X:333, Y:555, Z:77, Level:73\n  )\n)\n\npokemon_coordinates\n\n# A tibble: 5 × 1\n  position_data\n  &lt;chr&gt;        \n1 1253456782   \n2 0982341154   \n3 1566778893   \n4 2013445561   \n5 3335557773   \n\npokemon_coordinates |&gt;\n  separate_wider_position(\n    position_data,\n    widths = c(X = 3, Y = 3, Z = 2, Level = 2)\n  )\n\n# A tibble: 5 × 4\n  X     Y     Z     Level\n  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n1 125   345   67    82   \n2 098   234   11    54   \n3 156   677   88    93   \n4 201   344   55    61   \n5 333   555   77    73   \n\n\nIdući je dio bavljenja nizovima je rad sa slovima. Funkcija str_length() govori broj slova u nizu. Ova funkcija predstavlja temeljni alat za analizu tekstualnih podataka jer omogućuje kvantificiranje duljine tekstualnog sadržaja. Funkcija broji znakove u nizu, uključujući slova, brojeve, interpunkcijske znakove i razmake.\n\npokemon_names &lt;- c(\"Pikachu\", \"Charmander\", \"Bulbasaur\", NA, \"Squirtle\")\n\npokemon_names\n\n[1] \"Pikachu\"    \"Charmander\" \"Bulbasaur\"  NA           \"Squirtle\"  \n\nstr_length(pokemon_names)\n\n[1]  7 10  9 NA  8\n\npokemon_descriptions &lt;- c(\n  \"Electric mouse Pokemon\",\n  \"Fire lizard \\U0001F525\",\n  \"Grass/Poison seed\",\n  \"\"\n)\n\npokemon_descriptions\n\n[1] \"Electric mouse Pokemon\" \"Fire lizard 🔥\"         \"Grass/Poison seed\"     \n[4] \"\"                      \n\nstr_length(pokemon_descriptions)\n\n[1] 22 13 17  0\n\n\nMožete koristiti ovo s count() da pronađete distribuciju duljina imena. Ova tehnika se može primijeniti na bilo koje tekstualne podatke za analizu njihove strukture. Ovakva analiza može otkriti zanimljive uzorke u podacima, poput toga jesu li kraća imena češća za određene tipove Pokemona.\n\npokemon_data &lt;- tibble(\n  name = c(\"Pikachu\", \"Charmander\", \"Bulbasaur\", \"Squirtle\", \"Jigglypuff\", \"Meowth\", \"Psyduck\", \"Machamp\", \"Alakazam\", \"Gengar\"),\n  type = c(\"Electric\", \"Fire\", \"Grass\", \"Water\", \"Normal\", \"Normal\", \"Water\", \"Fighting\", \"Psychic\", \"Ghost\")\n)\n\npokemon_data |&gt;\n  count(length = str_length(name)) |&gt;\n  arrange(length)\n\n# A tibble: 5 × 2\n  length     n\n   &lt;int&gt; &lt;int&gt;\n1      6     2\n2      7     3\n3      8     2\n4      9     1\n5     10     2\n\n\n\n# Pokemon s imenima duljim od 8 znakova\nlong_names &lt;- pokemon_data |&gt;\n  filter(str_length(name) &gt; 8) |&gt;\n  select(name, type)\n\n# Statistike duljine po tipovima\ntype_length_stats &lt;- pokemon_data |&gt;\n  group_by(type) |&gt;\n  summarise(\n    avg_name_length = mean(str_length(name)),\n    min_length = min(str_length(name)),\n    max_length = max(str_length(name)),\n    .groups = \"drop\"\n  )\n\n# Sortiranje Pokemon-a po duljini imena\npokemon_data |&gt;\n  arrange(str_length(name)) |&gt;\n  mutate(name_length = str_length(name))\n\n# A tibble: 10 × 3\n   name       type     name_length\n   &lt;chr&gt;      &lt;chr&gt;          &lt;int&gt;\n 1 Meowth     Normal             6\n 2 Gengar     Ghost              6\n 3 Pikachu    Electric           7\n 4 Psyduck    Water              7\n 5 Machamp    Fighting           7\n 6 Squirtle   Water              8\n 7 Alakazam   Psychic            8\n 8 Bulbasaur  Grass              9\n 9 Charmander Fire              10\n10 Jigglypuff Normal            10\n\n# Top 3 najduža imena\npokemon_data |&gt;\n  arrange(desc(str_length(name))) |&gt;\n  slice_head(n = 3)\n\n# A tibble: 3 × 2\n  name       type  \n  &lt;chr&gt;      &lt;chr&gt; \n1 Charmander Fire  \n2 Jigglypuff Normal\n3 Bulbasaur  Grass",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Nizovi</span>"
    ]
  },
  {
    "objectID": "03_08_regularni_izrazi.html",
    "href": "03_08_regularni_izrazi.html",
    "title": "11  Regularni izrazi",
    "section": "",
    "text": "Regularni izrazi (regular expressions, regex) su koncizan jezik za opisivanje uzoraka unutar nizova znakova. Funkcioniraju kao formalni jezik koji omogućuje precizno definiranje uzoraka pretraživanja u tekstualnim podacima kroz kombinaciju literalnih znakova i metaznakova. Osnovni elementi regularnih izraza čine literalni znakovi koji se poklapaju s odgovarajućim znakovima u tekstu te metaznakovi koji imaju posebna značenja. Slova i brojevi su literalni znakovi, a većina interpunkcijskih znakova (., +, *, [, ], i ?) ima posebna značenja i pa su oni metaznakovi.\nRegularni izrazi predstavljaju nezamjenjiv alat u znanosti o podacima. Prvenstveno, omogućavaju sofisticiranu manipulaciju tekstualnih podataka što je posebno važno u kontekstu nestrukturiranih podataka. Osim toga, u procesu čišćenja podataka regularni izrazi omogućavaju identificiranje i uklanjanje neispravnih ili nepotrebnih dijelova teksta, normalizaciju formata podataka te standardizaciju unosa. Nadalje, regularni izrazi omogućuju ekstrakciju specifičnih informacija iz velikih skupova tekstualnih podataka. Klase znakova su definirane sa [] i omogućavaju poklapanje skupa znakova, a što je korisno za izdvajanje strukturiranih informacija poput datuma, adresa ili identifikacijskih brojeva.\nTekstualni podaci čine značajan dio ukupne količine podataka. Regularni izrazi omogućavaju transformaciju nestrukturiranih tekstualnih podataka u strukturirane formate pogodne za analizu. Ova sposobnost je osobito važna u područjima poput analize sentimenta, obradi prirodnog jezika i analizi teksta.\nRegularni izrazi također omogućavaju validaciju podataka kroz definiranje preciznih kriterija za prihvatljive formate unosa. Ovo je posebno važno u fazama prikupljanja i pretprocesiranja podataka gdje je potrebno osigurati konzistentnost i kvalitetu podataka prije početka analize.\nNajjednostavniji uzorci se sastoje od slova i brojeva koji se poklapaju točno s tim znakovima. U kontekstu analize Pokémon naziva, ovo znači da možemo tražiti određene Pokémone pomoću jednostavnih literalnih znakova. Na primjer, ako želimo pronaći sve Pokémone čiji naziv sadrži “char”, jednostavno ćemo koristiti uzorak “char” koji će pronaći Pokémone poput Charmander, Charmeleon ili Charizard. Slova i brojevi se poklapaju točno te se nazivaju literalni znakovi. Većina interpunkcijskih znakova ima posebna značenja i nazivaju se metaznakovi. Kada analiziramo Pokémon nazive, posebno je korisno razumjeti da točka (.) kao metaznak može zamijeniti bilo koji znak. Tako uzorak “p.ka” može pronaći “Pika” u nazivu Pikachu.\n\npokemon_names &lt;- c(\"Pikachu\", \"Charmander\", \"Charmeleon\", \"Charizard\", \"Bulbasaur\", \"Ivysaur\", \"Venusaur\", \"Squirtle\", \"Wartortle\", \"Blastoise\", \"Magikarp\", \"Gyarados\", \"Nidoran\", \"Nidoking\", \"Nidoqueen\", \"Alakazam\", \"Abra\", \"Kadabra\", \"Scyther\", \"Scizor\", \"Rattata\", \"Wigglytuff\", \"Jigglypuff\", \"Oddish\", \"Gloom\")\n\nstr_view(pokemon_names, \"Char\")\n\n[2] │ &lt;Char&gt;mander\n[3] │ &lt;Char&gt;meleon\n[4] │ &lt;Char&gt;izard\n\nstr_view(pokemon_names, \"saur\")\n\n[5] │ Bulba&lt;saur&gt;\n[6] │ Ivy&lt;saur&gt;\n[7] │ Venu&lt;saur&gt;\n\nstr_view(pokemon_names, \"P.ka\")\n\n[1] │ &lt;Pika&gt;chu\n\nstr_view(pokemon_names, \"ar.e\")\n\n[3] │ Ch&lt;arme&gt;leon\n\n\nKvantifikatori kontroliraju koliko se puta uzorak može poklapati. U analizi Pokémon naziva, kvantifikatori omogućavaju fleksibilno pretraživanje različitih varijanti. Zato znak upitnik čini uzorak opcijonalnim (tj. poklapaju se 0 ili 1 put). Kod Pokémona, ovo je korisno za pronalaženje naziva koji mogu imati opcijska slova. Na primjer, uzorak “nidos?aur” pronaći će i “Nidosaur” (ako takav postoji) i “Nidosaurus” varijante naziva. Osim toga, on omogućava uzorku ponavljanje (tj. poklapaju se najmanje jednom). Kod analizi Pokémon tipova, uzorak “gras+” može pronaći sve varijante tipa “grass” s jednim ili više slova ‘s’ na kraju. Također, omogućava uzorku biti opcionalan ili se ponavljati (tj. poklapaju se bilo koji broj puta, uključujući 0). Ovo je posebno korisno za pronalaženje Pokémona s varijabilnim brojem određenih slova u nazivu.\n\nstr_view(pokemon_names, \"nido(ran)?\")\n\n✖ Empty `string` provided.\n\nstr_view(pokemon_names, \"t+\")\n\n [8] │ Squir&lt;t&gt;le\n [9] │ War&lt;t&gt;or&lt;t&gt;le\n[10] │ Blas&lt;t&gt;oise\n[19] │ Scy&lt;t&gt;her\n[21] │ Ra&lt;tt&gt;a&lt;t&gt;a\n[22] │ Wiggly&lt;t&gt;uff\n\nstr_view(pokemon_names, \"l+\")\n\n [3] │ Charme&lt;l&gt;eon\n [5] │ Bu&lt;l&gt;basaur\n [8] │ Squirt&lt;l&gt;e\n [9] │ Wartort&lt;l&gt;e\n[10] │ B&lt;l&gt;astoise\n[16] │ A&lt;l&gt;akazam\n[22] │ Wigg&lt;l&gt;ytuff\n[23] │ Jigg&lt;l&gt;ypuff\n[25] │ G&lt;l&gt;oom\n\nstr_view(pokemon_names, \"Glo*m\")\n\n[25] │ &lt;Gloom&gt;\n\n\nKlase znakova su definirane sa [] i omogućavaju poklapanje skupa znakova, npr. [abcd] se poklapaju s “a”, “b”, “c”, ili “d”. U analizi Pokémon naziva, ovo omogućava traženje naziva koji počinju određenim skupom slova. Na primjer, [PFBSW] može pronaći Pokémone čiji nazivi počinju slovima P (Pikachu), F (Feraligatr), B (Blastoise), S (Squirtle), ili W (Wartortle). Također možete invertirati poklapanje počevši s ^: [^abcd] poklapaju sve osim “a”, “b”, “c”, ili “d”. Kod analize Pokémon tipova, možemo koristiti [^FireWater] za pronalaženje svih tipova osim Fire i Water tipova.\n\n# Pokémoni koji počinju s određenim slovima\nstr_view(pokemon_names, \"^[BCPV]\")\n\n [1] │ &lt;P&gt;ikachu\n [2] │ &lt;C&gt;harmander\n [3] │ &lt;C&gt;harmeleon\n [4] │ &lt;C&gt;harizard\n [5] │ &lt;B&gt;ulbasaur\n [7] │ &lt;V&gt;enusaur\n[10] │ &lt;B&gt;lastoise\n\n# Pokémoni koji završavaju samoglasnicima\nstr_view(pokemon_names, \"[aeiou]$\")\n\n [1] │ Pikach&lt;u&gt;\n [8] │ Squirtl&lt;e&gt;\n [9] │ Wartortl&lt;e&gt;\n[10] │ Blastois&lt;e&gt;\n[17] │ Abr&lt;a&gt;\n[18] │ Kadabr&lt;a&gt;\n[21] │ Rattat&lt;a&gt;\n\n\nMožete koristiti alternaciju | za biranje između jednog ili više alternativnih uzoraka. U kontekstu Pokémon analize, ovo je korisno za traženje različitih tipova ili grupa Pokémona. Na primjer, uzorak \"fire|water|grass\" može pronaći sve Pokémone osnovnih tipova. Također, uzorci traženja ponavljanih samoglasnika kao što je \"aa|ee|ii|oo|uu\" mogu biti korisni za pronalaženje Pokémona s karakterističnim duplikovanim slovima u nazivima, poput nekih japanskih naziva koji su transliterirani u engleski jezik.\n\n# Dodajemo tipove za demonstraciju\npokemon_with_types &lt;- c(\"Pikachu Electric\", \"Charmander Fire\", \"Squirtle Water\", \"Bulbasaur Grass Poison\", \"Geodude Rock Ground\", \"Zubat Poison Flying\")\n\n# Tražimo Pokémone Fire, Water ili Grass tipova\nstr_view(pokemon_with_types, \"Fire|Water|Grass\")\n\n[2] │ Charmander &lt;Fire&gt;\n[3] │ Squirtle &lt;Water&gt;\n[4] │ Bulbasaur &lt;Grass&gt; Poison\n\n# Tražimo Pokémone s duplikovanim slovima u nazivu\nstr_view(pokemon_names, \"([a-z])\\\\1\")\n\n[15] │ Nidoqu&lt;ee&gt;n\n[21] │ Ra&lt;tt&gt;ata\n[22] │ Wi&lt;gg&gt;lytu&lt;ff&gt;\n[23] │ Ji&lt;gg&gt;lypu&lt;ff&gt;\n[24] │ O&lt;dd&gt;ish\n[25] │ Gl&lt;oo&gt;m\n\n\nRegularni izrazi su vrlo kompaktni i koriste mnogo interpunkcijskih znakova pa mogu djelovati zastrašujuće i teški za čitanje, no kada se primjenjuju na konkretan skup podataka poput Pokémon naziva i tipova, njihova praktička korist postaje jasnija. U praktičnoj primjeni na Pokémon podacima, ovi osnovni uzorci omogućavaju efikasno kategoriziranje Pokémona prema različitim kriterijima, analizu obrazaca u imenima te pripremu podataka za dublju analizu performansi i karakteristika različitih grupa Pokémona.\n\n# Simuliramo Pokémon podatke s HP vrijednostima\npokemon_stats &lt;- c(\"Pikachu HP:35\", \"Charizard HP:78\", \"Blastoise HP:79\", \"Venusaur HP:80\", \"Alakazam HP:55\", \"Machamp HP:90\")\n\n# Tražimo Pokémone s HP između 70-89\nstr_view(pokemon_stats, \"HP:[7-8][0-9]\")\n\n[2] │ Charizard &lt;HP:78&gt;\n[3] │ Blastoise &lt;HP:79&gt;\n[4] │ Venusaur &lt;HP:80&gt;\n\n# Tražimo sve HP vrijednosti\nstr_view(pokemon_stats, \"HP:[0-9]+\")\n\n[1] │ Pikachu &lt;HP:35&gt;\n[2] │ Charizard &lt;HP:78&gt;\n[3] │ Blastoise &lt;HP:79&gt;\n[4] │ Venusaur &lt;HP:80&gt;\n[5] │ Alakazam &lt;HP:55&gt;\n[6] │ Machamp &lt;HP:90&gt;\n\n\n\n0.1 Ključne funkcije za rad s regularnim izrazima\nDetektiranje poklapanja\nstr_detect() vraća logički vektor koji je TRUE ako se uzorak poklapa s elementom znakovna vektora i FALSE inače. Budući da str_detect() vraća logički vektor iste duljine kao početni vektor, funkcija dobro se uparuje s filter() glagolom iz dplyr paketa. Također možemo koristiti str_detect() s summarize() koji daje izračun broja opažanja koja se poklapaju ili mean() koja govori udio koji se poklapa.\n\n# Stvaramo vektor Pokémon naziva\npokemon_names &lt;- c(\"Pikachu\", \"Charmander\", \"Charmeleon\", \"Charizard\", \"Bulbasaur\", \"Ivysaur\", \"Venusaur\", \"Squirtle\", \"Wartortle\", \"Blastoise\")\n\n# Detektiramo koji Pokémoni sadrže \"char\"\nstr_detect(pokemon_names, \"char\")\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n# Koji Pokémoni završavaju sa \"saur\"\nstr_detect(pokemon_names, \"saur$\")\n\n [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE\n\n# Stvaramo Pokémon data frame\nlibrary(dplyr)\npokemon_data &lt;- data.frame(\n  name = c(\"Pikachu\", \"Raichu\", \"Charmander\", \"Charmeleon\", \"Charizard\", \"Alakazam\", \"Machamp\", \"Gyarados\", \"Dragonite\", \"Mewtwo\"),\n  type = c(\"Electric\", \"Electric\", \"Fire\", \"Fire\", \"Fire\", \"Psychic\", \"Fighting\", \"Water\", \"Dragon\", \"Psychic\"),\n  generation = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)\n)\n\n# Pronalazimo sve Pokémone koji sadrže slovo \"a\"\npokemon_data |&gt;\n  filter(str_detect(name, \"a\")) |&gt;\n  count(name, sort = TRUE)\n\n        name n\n1   Alakazam 1\n2  Charizard 1\n3 Charmander 1\n4 Charmeleon 1\n5  Dragonite 1\n6   Gyarados 1\n7    Machamp 1\n8    Pikachu 1\n9     Raichu 1\n\n# Dodajemo više Pokémon generacija\npokemon_extended &lt;- data.frame(\n  name = c(\"Pikachu\", \"Charmander\", \"Alakazam\", \"Dragonite\", \"Chikorita\", \"Cyndaquil\", \"Totodile\", \"Lugia\"),\n  generation = c(1, 1, 1, 1, 2, 2, 2, 2)\n)\n\n# Analiziramo udio Pokémona koji sadrže \"a\" po generacijama\npokemon_extended |&gt;\n  group_by(generation) |&gt;\n  summarize(\n    total_pokemon = n(),\n    with_a = sum(str_detect(name, \"a\")),\n    proportion_with_a = mean(str_detect(name, \"a\"))\n  )\n\n# A tibble: 2 × 4\n  generation total_pokemon with_a proportion_with_a\n       &lt;dbl&gt;         &lt;int&gt;  &lt;int&gt;             &lt;dbl&gt;\n1          1             4      4              1   \n2          2             4      3              0.75\n\n\nPostoje dvije funkcije koje su usko povezane s str_detect(), str_subset() i str_which(). str_subset() vraća znakovni vektor koji sadrži samo nizove koji se poklapaju, a str_which() vraća cjelobrojni vektor koji daje pozicije nizova koji se poklapaju.\n\n# str_subset() - vraća samo Pokémone s \"char\"\nstr_subset(pokemon_names, \"char\")\n\ncharacter(0)\n\n# str_which() - vraća pozicije Pokémona s \"char\"\nstr_which(pokemon_names, \"char\")\n\ninteger(0)\n\n\nBrojanje poklapanja\nSljedeći korak je brojanje poklapanja funkcijom str_count() koja umjesto TRUE ili FALSE, govori koliko je poklapanja u svakom nizu.\n\n# Brojimo koliko puta se pojavljuje slovo \"a\" u Pokémon nazivima\nstr_count(pokemon_names, \"a\")\n\n [1] 1 2 1 2 2 1 1 0 1 1\n\n# Pokémoni s ponavljajućim slovima\npokemon_repeats &lt;- c(\"Rattata\", \"Wigglytuff\", \"Jigglypuff\", \"Oddish\", \"Seel\")\nstr_count(pokemon_repeats, \"l\")\n\n[1] 0 1 1 0 1\n\n\nVažno je napomenuti da se svako poklapanje počinje na kraju prethodnog poklapanja, tj. regex poklapanja se nikad ne preklapaju. Na primjer, u “abababa”, koliko će se puta poklopiti uzorak “aba”? Regularni izrazi kažu dva, ne tri.\n\n# Demonstracija s Pokémon nazivom\nstr_count(\"Rattata\", \"tat\")\n\n[1] 1\n\n\nPrirodno je koristiti str_count() s mutate(). Sljedeći primjer koristi klase znakova za brojanje samoglasnika i suglasnika u svakom naziv.\n\n# Analiziramo samoglasnike i suglasnike u Pokémon nazivima\npokemon_data |&gt;\n  mutate(\n    vowels = str_count(str_to_lower(name), \"[aeiou]\"),\n    consonants = str_count(str_to_lower(name), \"[^aeiou]\")\n  ) |&gt;\n  select(name, vowels, consonants)\n\n         name vowels consonants\n1     Pikachu      3          4\n2      Raichu      3          3\n3  Charmander      3          7\n4  Charmeleon      4          6\n5   Charizard      3          6\n6    Alakazam      4          4\n7     Machamp      2          5\n8    Gyarados      3          5\n9   Dragonite      4          5\n10     Mewtwo      2          4\n\n\nZamjena vrijednosti\nRegularne izraze možemo modificirati s funkcijom str_replace() i str_replace_all(). str_replace() zamjenjuje samo prvo poklapanje, a str_replace_all() zamjenjuje sva poklapanja prema nekom kriteriju.\n\n# Zamjenjujemo \"char\" s \"flame\" u Pokémon nazivima\nstr_replace(pokemon_names, \"[Cc]har\", \"Flame\")\n\n [1] \"Pikachu\"     \"Flamemander\" \"Flamemeleon\" \"Flameizard\"  \"Bulbasaur\"  \n [6] \"Ivysaur\"     \"Venusaur\"    \"Squirtle\"    \"Wartortle\"   \"Blastoise\"  \n\n# Uklanjamo sve samoglasnike iz naziva\nstr_replace_all(pokemon_names, \"[aeiou]\", \"\")\n\n [1] \"Pkch\"    \"Chrmndr\" \"Chrmln\"  \"Chrzrd\"  \"Blbsr\"   \"Ivysr\"   \"Vnsr\"   \n [8] \"Sqrtl\"   \"Wrtrtl\"  \"Blsts\"  \n\n# Uklanjamo \"char\" iz naziva\nstr_remove(pokemon_names, \"[Cc]har\")\n\n [1] \"Pikachu\"   \"mander\"    \"meleon\"    \"izard\"     \"Bulbasaur\" \"Ivysaur\"  \n [7] \"Venusaur\"  \"Squirtle\"  \"Wartortle\" \"Blastoise\"\n\n# Čišćenje Pokémon tipova s nekonzistentnim formatiranjem\npokemon_types &lt;- c(\"Electric-type\", \"Fire/Flying\", \"Grass & Poison\", \"Water_type\")\npokemon_types |&gt;\n  str_remove_all(\"-type|_type\") |&gt;\n  str_replace_all(\"[&/]\", \" \")\n\n[1] \"Electric\"       \"Fire Flying\"    \"Grass   Poison\" \"Water\"         \n\n\nEkstraktiranje varijabli\nPosljednja funkcija ove skupine je separate_wider_regex() koja koristi regularne izraze za ekstraktiranje podataka iz jednog stupca u jedan ili više novih stupaca.\n\n# Složeni Pokémon podaci u jednom stupcu\npokemon_complex &lt;- data.frame(\n  pokemon_info = c(\n    \"&lt;Pikachu&gt;-E_025\",\n    \"&lt;Charmander&gt;-F_004\",\n    \"&lt;Bulbasaur&gt;-G_001\",\n    \"&lt;Squirtle&gt;-W_007\"\n  )\n)\n\n# Ekstraktiramo komponente koristeći separate_wider_regex()\npokemon_complex |&gt;\n  separate_wider_regex(\n    pokemon_info,\n    patterns = c(\n      \"&lt;\",\n      name = \"[A-Za-z]+\",\n      \"&gt;-\",\n      type_code = \".\",\n      \"_\",\n      pokedex_number = \"[0-9]+\"\n    )\n  )\n\n# A tibble: 4 × 3\n  name       type_code pokedex_number\n  &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;         \n1 Pikachu    E         025           \n2 Charmander F         004           \n3 Bulbasaur  G         001           \n4 Squirtle   W         007           \n\n# Pokémon podaci s miješanim formatom borbi\npokemon_battle_data &lt;- data.frame(\n  battle_info = c(\n    \"Pikachu HP:35 ATK:55 won\",\n    \"Charizard HP:78 ATK:84 lost\",\n    \"Blastoise HP:79 ATK:83 won\"\n  )\n)\n\npokemon_battle_data |&gt;\n  separate_wider_regex(\n    battle_info,\n    patterns = c(\n      name = \"[A-Za-z]+\", \" HP:\",\n      hp = \"[0-9]+\", \" ATK:\",\n      attack = \"[0-9]+\", \" \",\n      result = \"[a-z]+\"\n    )\n  )\n\n# A tibble: 3 × 4\n  name      hp    attack result\n  &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; \n1 Pikachu   35    55     won   \n2 Charizard 78    84     lost  \n3 Blastoise 79    83     won   \n\n\n\n\n0.2 Detalji uzoraka u regularnim izrazima\nDrugi dio bavljenja regularnim izrazima je ulazak u detalje regularnih izraza. To uključuje escaping koji omogućava poklapanje metaznakova koji bi inače bili tretirani posebno, anchore koji omogućavaju poklapanje početka ili kraja niza, klasame znakova i njihove prečace koji omogućavaju poklapanje bilo kojeg znaka iz skupa, detalje kvantifikatora koji kontroliraju koliko se puta uzorak može poklapati te prioritete operatora i zagrada.\nEscaping\nDa biste se poklopili s literalnom točkom (.), trebate escape koji govori regularnom izrazu da se poklopi s metaznakovima doslovno. Kao i nizovi, regexovi koriste backslash za escaping. Dakle, da se poklopite s točkom, trebate regex. Nažalost, ovo stvara problem. Koristimo nizove za predstavljanje regularnih izraza, a  se također koristi kao escape simbol u nizovima. Dakle, da biste stvorili regularni izraz ., trebate niz \"\\.\".\n\n# Pokémon nazivi s točkama (često kod skraćenica)\npokemon_with_dots &lt;- c(\"Mr. Mime\", \"Mime Jr.\", \"Type: Null\", \"Farfetch'd\", \"Ho-Oh\")\n\n# Pogrešno - traži bilo koji znak umjesto točke\nstr_view(pokemon_with_dots, \".\")\n\n[1] │ &lt;M&gt;&lt;r&gt;&lt;.&gt;&lt; &gt;&lt;M&gt;&lt;i&gt;&lt;m&gt;&lt;e&gt;\n[2] │ &lt;M&gt;&lt;i&gt;&lt;m&gt;&lt;e&gt;&lt; &gt;&lt;J&gt;&lt;r&gt;&lt;.&gt;\n[3] │ &lt;T&gt;&lt;y&gt;&lt;p&gt;&lt;e&gt;&lt;:&gt;&lt; &gt;&lt;N&gt;&lt;u&gt;&lt;l&gt;&lt;l&gt;\n[4] │ &lt;F&gt;&lt;a&gt;&lt;r&gt;&lt;f&gt;&lt;e&gt;&lt;t&gt;&lt;c&gt;&lt;h&gt;&lt;'&gt;&lt;d&gt;\n[5] │ &lt;H&gt;&lt;o&gt;&lt;-&gt;&lt;O&gt;&lt;h&gt;\n\n# Ispravno - traži literalnu točku\nstr_view(pokemon_with_dots, \"\\\\.\")\n\n[1] │ Mr&lt;.&gt; Mime\n[2] │ Mime Jr&lt;.&gt;\n\n\nAko \\ se koristi kao escape znak u regularnim izrazima, kako se poklapate s literalnim? Pa, morate ga escapati, stvarajući regularni izraz \\. Da biste stvorili taj regularni izraz, morate koristiti niz koji također mora escapati. To znači da se za poklapanje s literalnim \\ morate napisati \"\\\\\".\n\n# Pokémon putanje s backslash znakovima (hipotetski primjer)\npokemon_paths &lt;- c(\"data\\\\pokemon\\\\pikachu.txt\", \"stats\\\\charizard.csv\")\n\n# Tražimo literalni backslash\nstr_view(pokemon_paths, \"\\\\\\\\\")\n\n[1] │ data&lt;\\&gt;pokemon&lt;\\&gt;pikachu.txt\n[2] │ stats&lt;\\&gt;charizard.csv\n\n# Pokémon nazivi s različitim interpunkcijskim znakovima\npokemon_punctuation &lt;- c(\"Ho-Oh\", \"Porygon-Z\", \"Type: Null\", \"Mr. Mime\", \"Nidoran♂\")\n\n# Tražimo dvotočku koristeći klasu znakova\nstr_view(pokemon_punctuation, \"[:]\")\n\n[3] │ Type&lt;:&gt; Null\n\n# Tražimo crticu\nstr_view(pokemon_punctuation, \"[-]\")\n\n[1] │ Ho&lt;-&gt;Oh\n[2] │ Porygon&lt;-&gt;Z\n\n\nAnchori\nPo defaultu, regularni izrazi će se poklopiti s bilo kojim dijelom niza. Ako se želite poklopiti na početku ili kraju, trebate usiditi regularni izraz koristeći ^ za poklapanje početka ili $ za poklapanje kraja, a da biste prisilili regularni izraz da se poklopi samo s cijelim nizom, usidriti ga s ^ i $.\n\npokemon_names &lt;- c(\"Pikachu\", \"Raichu\", \"Machamp\", \"Machoke\", \"Machop\")\n\n# Pokémoni koji počinju s \"Pika\"\nstr_view(pokemon_names, \"^Pika\")\n\n[1] │ &lt;Pika&gt;chu\n\n# Pokémoni koji završavaju s \"chu\"\nstr_view(pokemon_names, \"chu$\")\n\n[1] │ Pika&lt;chu&gt;\n[2] │ Rai&lt;chu&gt;\n\n# Točno \"Pikachu\", ne dio naziva\nstr_view(pokemon_names, \"^Pikachu$\")\n\n[1] │ &lt;Pikachu&gt;\n\n\nTakođer se možete poklopiti s granicom između riječi (tj. početak ili kraj riječi) s \\b. Ovo može biti posebno korisno pri korištenju alata za pronalaženje i zamjenu.\n\n# Evolucijska linija Machamp obitelji\nmachamp_family &lt;- c(\"Machop\", \"Machoke\", \"Machamp\", \"Supermachamp\")\n\n# Tražimo točno \"Mach\" na početku riječi\nstr_view(machamp_family, \"\\\\bMach\\\\b\")\n\n✖ Empty `string` provided.\n\n# Tražimo \"Machop\" kao potpunu riječ\nstr_view(machamp_family, \"\\\\bMachop\\\\b\")\n\n[1] │ &lt;Machop&gt;\n\n\nKlase znakova\nKlasa znakova, ili skup znakova, omogućava poklapanje bilo kojeg znaka u skupu. Možete konstruirati vlastite skupove s [] gdje [abc] poklapaju “a”, “b” ili “c” i [^abc] poklapaju bilo koji znak osim “a”, “b” ili “c”.\n\n# Pokémoni čiji nazivi počinju određenim slovima\npokemon_starters &lt;- c(\"Bulbasaur\", \"Charmander\", \"Squirtle\", \"Pikachu\", \"Eevee\")\n\n# Pokémoni koji počinju samoglasnicima\nstr_view(pokemon_starters, \"^[AEIOU]\")\n\n[5] │ &lt;E&gt;evee\n\n# Pokémoni koji ne počinju samoglasnicima\nstr_view(pokemon_starters, \"^[^AEIOU]\")\n\n[1] │ &lt;B&gt;ulbasaur\n[2] │ &lt;C&gt;harmander\n[3] │ &lt;S&gt;quirtle\n[4] │ &lt;P&gt;ikachu\n\n\nOsim ^ postoje dva druga znaka koja imaju posebno značenje unutar []:\n\n- koji definira raspon, npr., [a-z] poklapaju bilo koje malo slovo i [0-9] poklapaju bilo koji broj.\n\\ escapira posebne znakove, tako da [^-]] poklapaju ^, - ili ].\n\n\n# Pokémoni s brojevima u nazivu (Gen VII+)\npokemon_with_numbers &lt;- c(\"Type: Null\", \"Silvally\", \"UB-01\", \"UB-02\", \"Porygon-Z\")\n\n# Tražimo Pokémone s brojevima\nstr_view(pokemon_with_numbers, \"[0-9]\")\n\n[3] │ UB-&lt;0&gt;&lt;1&gt;\n[4] │ UB-&lt;0&gt;&lt;2&gt;\n\n# Pokémon nazivi s crticama\nstr_view(pokemon_with_numbers, \"[\\\\-]\")\n\n[3] │ UB&lt;-&gt;01\n[4] │ UB&lt;-&gt;02\n[5] │ Porygon&lt;-&gt;Z\n\n\nNeke klase znakova se koriste tako često da dobivaju vlastite prečace. Već ste vidjeli . koji poklapaju bilo koji znak osim newline. Postoje tri druga posebno korisna para:\n\n\\d poklapaju bilo koji broj i \\D poklapaju sve što nije broj.\n\\s poklapaju bilo koji whitespace i \\S poklapaju sve što nije whitespace.\n\\w poklapaju bilo koji “word” znak, tj. slova i brojevi i \\W poklapaju bilo koji “non-word” znak.\n\n\n# Pokémon podaci s miješanim formatom\npokemon_data_mixed &lt;- c(\"Pikachu Lv25\", \"Charizard HP78\", \"Mewtwo Lv100\", \"Mew HP200\")\n\n# Tražimo brojeve (leveli i HP)\nstr_view(pokemon_data_mixed, \"\\\\d+\")\n\n[1] │ Pikachu Lv&lt;25&gt;\n[2] │ Charizard HP&lt;78&gt;\n[3] │ Mewtwo Lv&lt;100&gt;\n[4] │ Mew HP&lt;200&gt;\n\n# Tražimo slova (nazivi Pokémona)\nstr_view(pokemon_data_mixed, \"\\\\w+\")\n\n[1] │ &lt;Pikachu&gt; &lt;Lv25&gt;\n[2] │ &lt;Charizard&gt; &lt;HP78&gt;\n[3] │ &lt;Mewtwo&gt; &lt;Lv100&gt;\n[4] │ &lt;Mew&gt; &lt;HP200&gt;\n\n\nKvantifikatori\nKvantifikatori kontroliraju koliko se puta uzorak poklapaju. U ranijim odjeljcima naučili ste o ? (0 ili 1 poklapanja), + (1 ili više poklapanja) i * (0 ili više poklapanja). Također možete precizno specificirati broj poklapanja s {}.\n\n# Pokémon nazivi različitih duljina\npokemon_lengths &lt;- c(\"Mew\", \"Alakazam\", \"Ho-Oh\", \"Articuno\", \"Zapdos\")\n\n# Točno 3 znaka\nstr_view(pokemon_lengths, \"^\\\\w{3}$\")\n\n[1] │ &lt;Mew&gt;\n\n# Između 5 i 7 znakova\nstr_view(pokemon_lengths, \"^\\\\w{5,7}$\")\n\n[5] │ &lt;Zapdos&gt;\n\n# 5 ili više znakova\nstr_view(pokemon_lengths, \"^\\\\w{5,}$\")\n\n[2] │ &lt;Alakazam&gt;\n[4] │ &lt;Articuno&gt;\n[5] │ &lt;Zapdos&gt;\n\n\nPrioritet operatora i zagrade\nŠto poklapaju ab+? Poklapaju li “a” praćen jednim ili više “b” ili poklapaju “ab” ponovljen bilo koji broj puta? Što poklapaju ^a|b$? Poklapaju li cijeli niz a ili cijeli niz b, ili poklapaju niz koji počinje s a ili niz koji završava s b? Kao i algebra, možete koristiti zagrade za prebrisavanje uobičajenog reda. Ali za razliku od algebre, vjerojatno nećete pamtiti pravila prioriteta za regexove, pa slobodno koristite zagrade liberalno.\n\n# Pokémon nazivi za testiranje prioriteta\npokemon_test &lt;- c(\"Pikachu\", \"Pikablu\", \"Raichu\", \"Raiblu\", \"Pika\", \"Rai\")\n\n# ab+ znači a(b+), ne (ab)+\nstr_view(pokemon_test, \"Pika+\")\n\n[1] │ &lt;Pika&gt;chu\n[2] │ &lt;Pika&gt;blu\n[5] │ &lt;Pika&gt;\n\n# Za (ab)+ trebate zagrade\npokemon_repeat &lt;- c(\"Pikapika\", \"Rairai\", \"Pikablu\")\nstr_view(pokemon_repeat, \"(Pika)+\")\n\n[1] │ &lt;Pika&gt;pika\n[3] │ &lt;Pika&gt;blu\n\n\nGrupiranje i hvatanje\nOsim prebrisavanja prioriteta operatora, zagrade imaju još jedan važan učinak - stvaraju grupe za hvatanje koje omogućavaju korištenje pod-komponenti poklapanja.\n\n# Pokémoni s ponavljajućim parovima slova\npokemon_pairs &lt;- c(\"Rattata\", \"Diglett\", \"Seel\", \"Koffing\")\n\n# Tražimo ponavljajuće parove slova koristeći backreference\nstr_view(pokemon_pairs, \"(..)\\\\1\")\n\n[1] │ Rat&lt;tata&gt;\n\n# Pokémoni koji počinju i završavaju istim parom\npokemon_palindrome &lt;- c(\"Rotom\", \"Girafarig\", \"Ho-Oh\")\nstr_view(pokemon_palindrome, \"^(..).*\\\\1$\")\n\n✖ Empty `string` provided.\n\n\nTakođer možete koristiti back reference u str_replace(). Na primjer, ovaj kod mijenja redoslijed drugog i trećeg riječi.\n\n# Pokémon evolucijske linije\nevolution_lines &lt;- c(\n  \"Bulbasaur evolves into Ivysaur\",\n  \"Charmander evolves into Charmeleon\",\n  \"Squirtle evolves into Wartortle\"\n)\n\n# Mijenjamo redoslijed riječi pomoću grupa\nstr_replace(evolution_lines, \"(\\\\w+) (\\\\w+) (\\\\w+)\", \"\\\\1 \\\\3 \\\\2\")\n\n[1] \"Bulbasaur into evolves Ivysaur\"     \"Charmander into evolves Charmeleon\"\n[3] \"Squirtle into evolves Wartortle\"   \n\n\n\n\n0.3 Kontrola uzoraka u regularnim izrazima\nMoguće je vršiti dodatnu kontrolu nad detaljima poklapanja korištenjem pattern objekta umjesto samo niza. Ovo omogućava kontrolu nad takozvanim regex flagovima i poklapanje različitih tipova fiksnih nizova.\nRegex flagovi\nPostoji nekoliko postavki koje se mogu koristiti za kontrolu detalja regexp-a. Ove postavke se često nazivaju flagovi u drugim programskim jezicima. U stringr-u ih možete koristiti tako da zavisate uzorak u poziv regex(). Najkorisniji flag je ignore_case = TRUE jer omogućava znakovima da se poklapaju s velikim ili malim slovima.\n\n# Pokémon nazivi s miješanim velikim/malim slovima\npokemon_mixed_case &lt;- c(\"PIKACHU\", \"pikachu\", \"Pikachu\", \"PiKaChU\", \"CHARIZARD\", \"charizard\", \"Charizard\")\n\n# Tražimo \"pikachu\" ignorirajući razlike u velikim/malim slovima\nstr_view(pokemon_mixed_case, regex(\"pikachu\", ignore_case = TRUE))\n\n[1] │ &lt;PIKACHU&gt;\n[2] │ &lt;pikachu&gt;\n[3] │ &lt;Pikachu&gt;\n[4] │ &lt;PiKaChU&gt;\n\n# Brojimo koliko Pokémona sadrži \"char\" bez obzira na velika/mala slova\nstr_count(pokemon_mixed_case, regex(\"char\", ignore_case = TRUE))\n\n[1] 0 0 0 0 1 1 1\n\n\nAko radite mnogo s višelinijskim nizovima (tj. nizovi koji sadrže \\n), dotall i multiline mogu također biti korisni, dotall = TRUE omogućava . da se poklapa s sve, uključujući \\n, a multiline = TRUE čini ^ i $ da se poklapaju s početkom i krajem svake linije umjesto početka i kraja cijelog niza.\n\n# Pokémon opis s više linija\npokemon_description &lt;- \"Pikachu is an Electric-type Pokémon.\\nIt evolves from Pichu.\\nIt can evolve into Raichu.\"\n\n# Bez dotall flag - točka ne poklapa newline\nstr_extract(pokemon_description, \"Electric.*Pichu\")\n\n[1] NA\n\n# S dotall flag - točka poklapa sve uključujući newline\nstr_extract(pokemon_description, regex(\"Electric.*Pichu\", dotall = TRUE))\n\n[1] \"Electric-type Pokémon.\\nIt evolves from Pichu\"\n\n# Višelinijski Pokémon popis\npokemon_list &lt;- \"Generation 1:\\nPikachu\\nCharizard\\nGeneration 2:\\nLugia\\nHo-Oh\"\n\n# Bez multiline - ^ i $ se odnose na cijeli string\nstr_extract_all(pokemon_list, \"^Generation.*\")\n\n[[1]]\n[1] \"Generation 1:\"\n\n# S multiline - ^ i $ za svaku liniju\nstr_extract_all(pokemon_list, regex(\"^Generation.*\", multiline = TRUE))\n\n[[1]]\n[1] \"Generation 1:\" \"Generation 2:\"\n\n\nKonačno, ako pišete komplicirani regularni izraz i zabrinuti ste da ga možda nećete razumjeti u budućnosti, možete pokušati comments = TRUE. To mijenja jezik uzorka da ignorira razmake i nove linije, kao i sve nakon #. Ovo omogućava korištenje komentara i razmaka da učinite složene regularne izraze razumljivijima.\n\n# Složeni uzorak za parsiranje Pokémon statistika s komentarima\npokemon_stats_pattern &lt;- regex(\n  r\"(\n    (\\w+)\n    \\s+\n    HP:(\\d+)\n    \\s+\n    ATK:(\\d+)\n    \\s+\n    DEF:(\\d+)\n  )\",\n  comments = TRUE\n)\n\npokemon_battle_data &lt;- c(\n  \"Pikachu HP:35 ATK:55 DEF:40\",\n  \"Charizard HP:78 ATK:84 DEF:78\"\n)\n\nstr_match(pokemon_battle_data, pokemon_stats_pattern)\n\n     [,1]                            [,2]        [,3] [,4] [,5]\n[1,] \"Pikachu HP:35 ATK:55 DEF:40\"   \"Pikachu\"   \"35\" \"55\" \"40\"\n[2,] \"Charizard HP:78 ATK:84 DEF:78\" \"Charizard\" \"78\" \"84\" \"78\"\n\n\nFiksna poklapanja\nMožete se odlučiti za izlaz iz pravila regularnih izraza korištenjem fixed(). Ona također daje mogućnost ignoriranja velikih/malih slova.\n\n# Pokémon nazivi s posebnim znakovima\npokemon_special &lt;- c(\"Type: Null\", \"Mr. Mime\", \"Farfetch'd\", \"Ho-Oh\", \"Porygon-Z\")\n\n# Tražimo literalni \":\"  koristeći fixed()\nstr_view(pokemon_special, fixed(\":\"))\n\n[1] │ Type&lt;:&gt; Null\n\n# Tražimo literalni \"-\" koristeći fixed()\nstr_view(pokemon_special, fixed(\"-\"))\n\n[4] │ Ho&lt;-&gt;Oh\n[5] │ Porygon&lt;-&gt;Z\n\n# Poredba s regex pristupom (trebalo bi escapiranje)\nstr_view(pokemon_special, \":\")\n\n[1] │ Type&lt;:&gt; Null\n\n# Pokémoni s različitim kombinacijama velikih/malih slova\npokemon_cases &lt;- c(\"PIKACHU\", \"pikachu\", \"Pikachu\", \"Mr. MIME\", \"mr. mime\")\n\n# Tražimo \"mr. mime\" ignorirajući velika/mala slova\nstr_detect(pokemon_cases, fixed(\"mr. mime\", ignore_case = TRUE))\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n\n\n# Kombiniranje različitih flagova za složenije pretraživanje\npokemon_complex_data &lt;- \"Generation I (1996):\\nPikachu - Electric Type\\nCharizard - Fire/Flying Type\\n\\nGeneration II (1999):\\nLugia - Psychic/Flying Type\"\n\n# Ekstraktiranje svih generacija s njihovim godinama\ngeneration_pattern &lt;- regex(\n  r\"(\n    Generation\\s+\n    ([IVX]+)\n    \\s*\\(\n    (\\d{4})\n    \\)\n  )\",\n  comments = TRUE,\n  ignore_case = TRUE\n)\n\nstr_extract_all(pokemon_complex_data, generation_pattern)\n\n[[1]]\n[1] \"Generation I (1996)\"  \"Generation II (1999)\"\n\n# Ekstraktiranje Pokémon naziva s tipovima\npokemon_type_pattern &lt;- regex(\n  r\"(\n    ^([A-Za-z]+)\n    \\s+-\\s+\n    (.+)\\s+Type\n  )\",\n  comments = TRUE,\n  multiline = TRUE\n)\n\nstr_match_all(pokemon_complex_data, pokemon_type_pattern)\n\n[[1]]\n     [,1]                           [,2]        [,3]            \n[1,] \"Pikachu - Electric Type\"      \"Pikachu\"   \"Electric\"      \n[2,] \"Charizard - Fire/Flying Type\" \"Charizard\" \"Fire/Flying\"   \n[3,] \"Lugia - Psychic/Flying Type\"  \"Lugia\"     \"Psychic/Flying\"\n\n# Veliki skup Pokémon naziva za testiranje performansi\nlarge_pokemon_dataset &lt;- rep(c(\"Pikachu\", \"Charizard\", \"Blastoise\", \"Venusaur\"), 1000)\n\n# Fiksno pretraživanje je brže za jednostavne nizove\nsystem.time({\n  fixed_results &lt;- str_detect(large_pokemon_dataset, fixed(\"Pikachu\"))\n})\n\n   user  system elapsed \n  0.001   0.000   0.000 \n\n# Regex pretraživanje za istu stvar\nsystem.time({\n  regex_results &lt;- str_detect(large_pokemon_dataset, \"Pikachu\")\n})\n\n   user  system elapsed \n  0.001   0.000   0.001 \n\n# Za jednostavna poklapanja, fixed() može biti značajno brži\nidentical(fixed_results, regex_results)\n\n[1] TRUE",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Regularni izrazi</span>"
    ]
  },
  {
    "objectID": "03_09_datum_i_vrijeme.html",
    "href": "03_09_datum_i_vrijeme.html",
    "title": "12  Datum i vrijeme",
    "section": "",
    "text": "Rad s datumima i vremenima predstavlja jednu od ključnih vještina u analizi podataka, no istovremeno je i jedan od najsloženijih aspekata obrade podataka u R-u. Na prvi pogled datumi i vremena izgledaju jednostavno jer ih koristimo svakodnevno u običnom životu i ne čine se problem, no što dublje ulazimo u problematiku, to postaju složeniji. Datumi i vremena su teški jer moraju pomiriti dva fizička fenomena (rotaciju Zemlje i njezinu orbitu oko Sunca) s cijelim nizom geopolitičkih fenomena uključujući mjesece, vremenske zone i ljetno računanje vremena. Za rad s datumima i vremenima u R-u potrebno je razumjeti da postoje različiti tipovi podataka koji se odnose na trenutak u vremenu. Postoje tri tipa datum/ vrijeme podataka koji se odnose na trenutak u vremenu: datum, vrijeme unutar dana i datum-vrijeme koji je kombinacija datuma i vremena.\nPristup rada s datumima i vremenima usmjeren na lubridate paket koji olakšava rad s datumima i vremenima u R-u. Paket lubridate je R paket koji olakšava rad s datumima i vremenima te ima konzistentnu i lako pamtljivu sintaksu koja čini rad s datumima jednostavnim. Ovaj rad predstavlja lubridate paket za R koji olakšava rad s datumima i vremenima jer datum-vremena stvaraju različite tehničke probleme za analitičara podataka. Paket je dizajniran s ciljem rješavanja uobičajenih problema s kojima se analitičari susreću prilikom rada s vremenskim podacima.\nJedan od najvećih izazova u radu s datumima je natjerati R da se složi da podaci sadrže datume i vremena za koje mislite da ih sadrže može biti trikovno. lubridate rješava ovaj problem pružanjem intuitivnih funkcija za parsiranje različitih formata datuma i vremena te omogućava elementarne operacije poput izdvajanja komponenti datuma, aritmetike s datumima i rada s vremenskim zonama.\n\n0.1 Kreiranje datuma i vremena u R-u\nPostoje tri tipa datum/vrijeme podataka koji se odnose na trenutak u vremenu:\n\ndatum (&lt;date&gt;),\nvrijeme unutar dana (&lt;time&gt;) i\ndatum-vrijeme koji je kombinacija datuma i vremena i jedinstveno identificira trenutak u vremenu (&lt;dttm&gt;).\n\nU ovom je poglavlju fokus na datume i datum-vremena jer R nema osnovnu klasu za pohranu vremena, a ako trebamo raditi samo s vremenom, onda možemo koristiti paket hms. Uvijek je najbolje koristiti najjednostavniji mogući tip podataka koji odgovara trenutnim potrebama - to znači da ako možemo koristiti datum umjesto datum-vremena, to je ono što je najbolje koristiti. Datum-vremena su znatno složeniji zbog potrebe za rukovanje vremenskim zonama.\nZa dobivanje trenutnog datuma ili datum-vremena mogu se koristiti funkcije today() ili now().\n\n# Današnji datum\ntoday()\n\n[1] \"2026-02-07\"\n\n# Trenutno datum-vrijeme\nnow()\n\n[1] \"2026-02-07 14:28:38 CET\"\n\n\nAko CSV sadrži oznaku ISO8601 datum ili datum-vrijeme, ne morate ništa raditi - readr će ga automatski prepoznati. ISO8601 je međunarodni standard za pisanje datuma gdje su komponente datuma organizirane od najveće prema najmanjoj razdvojene crticama.\n\n# Primjer CSV-a s Pokemon podacima\ncsv_pokemon &lt;- \"\nname,caught_date,caught_datetime\nPikachu,2023-05-15,2023-05-15 14:30\nCharizard,2023-06-02,2023-06-02 09:15\nBlastoise,2023-07-20,2023-07-20 18:45\n\"\n\npokemon_data &lt;- read_csv(csv_pokemon)\n\nWarning: The `file` argument of `vroom()` must use `I()` for literal data as of vroom\n1.5.0.\n  \n  # Bad:\n  vroom(\"X,Y\\n1.5,2.3\\n\")\n  \n  # Good:\n  vroom(I(\"X,Y\\n1.5,2.3\\n\"))\nℹ The deprecated feature was likely used in the readr package.\n  Please report the issue at &lt;https://github.com/tidyverse/readr/issues&gt;.\n\n\nRows: 3 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (1): name\ndttm (1): caught_datetime\ndate (1): caught_date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\npokemon_data\n\n# A tibble: 3 × 3\n  name      caught_date caught_datetime    \n  &lt;chr&gt;     &lt;date&gt;      &lt;dttm&gt;             \n1 Pikachu   2023-05-15  2023-05-15 14:30:00\n2 Charizard 2023-06-02  2023-06-02 09:15:00\n3 Blastoise 2023-07-20  2023-07-20 18:45:00\n\n\nZa druge formate datum-vremena potrebno je koristiti col_types a col_date() ili col_datetime() zajedno s formatom datum-vremena. Format koristi % praćen jednim znakom za opisivanje komponente datuma.\n\n# CSV s različitim formatima datuma\ncsv_pokemon_formats &lt;- \"\nname,caught_date\nPikachu,15/05/23\nCharizard,05-15-2023\nVenusaur,2023 May 15\n\"\n\n# Parsiranje različitih formata\nread_csv(\n  csv_pokemon_formats,\n  col_types = cols(caught_date = col_date(\"%d/%m/%y\"))\n)\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)\n\n\n# A tibble: 3 × 2\n  name      caught_date\n  &lt;chr&gt;     &lt;date&gt;     \n1 Pikachu   2023-05-15 \n2 Charizard NA         \n3 Venusaur  NA         \n\nread_csv(\n  csv_pokemon_formats,\n  col_types = cols(caught_date = col_date(\"%m-%d-%Y\"))\n)\n\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat &lt;- vroom(...)\n  problems(dat)\n\n\n# A tibble: 3 × 2\n  name      caught_date\n  &lt;chr&gt;     &lt;date&gt;     \n1 Pikachu   NA         \n2 Charizard 2023-05-15 \n3 Venusaur  NA         \n\n\nAlternativni pristup je korištenje lubridate pomoćnih funkcija koje automatski pokušavaju odrediti format kada specificirate redoslijed komponenti. Da biste ih koristili, identificirajte redoslijed u kojem se godina, mjesec i dan pojavljuju u vašim datumima, a zatim poredajte “y”, “m” i “d” u istom redoslijed.\n\n# Različiti formati datuma\nymd(\"2023-05-15\")\n\n[1] \"2023-05-15\"\n\nmdy(\"May 15, 2023\")\n\n[1] \"2023-05-15\"\n\ndmy(\"15-May-2023\")\n\n[1] \"2023-05-15\"\n\n# Datumi Pokemon turnira u različitim formatima\npokemon_tournament_dates &lt;- c(\n  \"2023-07-15\",\n  \"August 20, 2023\",\n  \"25-Sep-2023\"\n)\n\n# Parsiranje različitih formata\nymd(pokemon_tournament_dates[1])\n\n[1] \"2023-07-15\"\n\nmdy(pokemon_tournament_dates[2])\n\n[1] \"2023-08-20\"\n\ndmy(pokemon_tournament_dates[3])\n\n[1] \"2023-09-25\"\n\n\nymd() i slične funkcije stvaraju datume. Za stvaranje datum-vremena, dodajte podvlaku i jedan ili više znakova “h”, “m” i “s” na naziv funkcije za parsiranje.\n\n# Datum-vrijeme kada je Pokemon uhvaćen\nymd_hms(\"2023-05-15 14:30:59\")\n\n[1] \"2023-05-15 14:30:59 UTC\"\n\nymd_hm(\"2023-05-15 14:30\")\n\n[1] \"2023-05-15 14:30:00 UTC\"\n\n\nPonekad ćete imati individualne komponente datum-vremena razmještene u više stupaca. U takvim slučajevima koristite make_date() za datume ili make_datetime() za datum-vremena.\n\n# Simuliramo podatke o uhvaćenim Pokemonima\npokemon_catches &lt;- data.frame(\n  name = c(\"Pikachu\", \"Charizard\", \"Blastoise\", \"Venusaur\"),\n  year = c(2023, 2023, 2023, 2023),\n  month = c(5, 6, 7, 8),\n  day = c(15, 2, 20, 10),\n  hour = c(14, 9, 18, 11),\n  minute = c(30, 15, 45, 20)\n)\n\n# Stvaranje datuma\npokemon_catches$catch_date &lt;- make_date(\n  pokemon_catches$year,\n  pokemon_catches$month,\n  pokemon_catches$day\n)\n\n# Stvaranje datum-vremena\npokemon_catches$catch_datetime &lt;- make_datetime(\n  pokemon_catches$year,\n  pokemon_catches$month,\n  pokemon_catches$day,\n  pokemon_catches$hour,\n  pokemon_catches$minute\n)\n\npokemon_catches\n\n       name year month day hour minute catch_date      catch_datetime\n1   Pikachu 2023     5  15   14     30 2023-05-15 2023-05-15 14:30:00\n2 Charizard 2023     6   2    9     15 2023-06-02 2023-06-02 09:15:00\n3 Blastoise 2023     7  20   18     45 2023-07-20 2023-07-20 18:45:00\n4  Venusaur 2023     8  10   11     20 2023-08-10 2023-08-10 11:20:00\n\n\nMožda ćete htjeti prebacivati između datum-vremena i datuma. To je posao funkcija as_date() i as_datetime().\n\n# Pretvorba datum-vremena u datum\npokemon_datetime &lt;- ymd_hms(\"2023-05-15 14:30:59\")\nas_date(pokemon_datetime)\n\n[1] \"2023-05-15\"\n\n# Pretvorba datuma u datum-vrijeme\npokemon_date &lt;- ymd(\"2023-05-15\")\nas_datetime(pokemon_date)\n\n[1] \"2023-05-15 UTC\"\n\n\nPonekad ćete dobiti datum/vremena kao numeričke pomake od “Unix Epoch”, 1970-01-01. Ako je pomak u sekundama, koristite as_datetime(), a ako je u danima, koristite as_date().\n\n# Simuliramo da su Pokemon podaci pohranjeni kao Unix timestamp\npikachu_timestamp &lt;- 1684159859\ncharizard_days &lt;- 19510\n\n# Pretvorba u čitljive formate\nas_datetime(pikachu_timestamp)\n\n[1] \"2023-05-15 14:10:59 UTC\"\n\nas_date(charizard_days)\n\n[1] \"2023-06-02\"\n\n\n\n# Kompletniji primjer s Pokemon lovom kroz različite regije\npokemon_log &lt;- data.frame(\n  trainer = c(\"Ash\", \"Misty\", \"Brock\", \"Ash\", \"Gary\"),\n  pokemon = c(\"Pikachu\", \"Staryu\", \"Onix\", \"Charizard\", \"Blastoise\"),\n  region = c(\"Kanto\", \"Cerulean\", \"Pewter\", \"Charicific Valley\", \"Pallet\"),\n  caught_string = c(\"2023-04-01 08:30\", \"2023-04-15 16:45\", \"2023-05-02 12:15\", \"2023-06-20 19:30\", \"2023-07-10 14:20\"),\n  stringsAsFactors = FALSE\n)\n\n# Parsiranje datum-vremena\npokemon_log$caught_datetime &lt;- ymd_hm(pokemon_log$caught_string)\n\n# Dodavanje datuma bez vremena\npokemon_log$caught_date &lt;- as_date(pokemon_log$caught_datetime)\n\n# Pregled rezultata\npokemon_log\n\n  trainer   pokemon            region    caught_string     caught_datetime\n1     Ash   Pikachu             Kanto 2023-04-01 08:30 2023-04-01 08:30:00\n2   Misty    Staryu          Cerulean 2023-04-15 16:45 2023-04-15 16:45:00\n3   Brock      Onix            Pewter 2023-05-02 12:15 2023-05-02 12:15:00\n4     Ash Charizard Charicific Valley 2023-06-20 19:30 2023-06-20 19:30:00\n5    Gary Blastoise            Pallet 2023-07-10 14:20 2023-07-10 14:20:00\n  caught_date\n1  2023-04-01\n2  2023-04-15\n3  2023-05-02\n4  2023-06-20\n5  2023-07-10\n\n\n\n\n0.2 Komponente datum-vremena\nMožete izdvojiti pojedine dijelove datuma pomoću pristupnih funkcija year(), month(), mday() (dan u mjesecu), yday() (dan u godini), wday() (dan u tjednu), hour(), minute() i second(). Ove su funkcije jednostavne za dobivanje i postavljanje komponenti datum-vremena.\n\n# Stvaramo datum-vrijeme kada je Pikachu uhvaćen\npikachu_datetime &lt;- ymd_hms(\"2023-05-15 14:30:45\")\n\n# Izdvajanje komponenti\nyear(pikachu_datetime)\n\n[1] 2023\n\nmonth(pikachu_datetime)\n\n[1] 5\n\nmday(pikachu_datetime)\n\n[1] 15\n\nyday(pikachu_datetime)\n\n[1] 135\n\nwday(pikachu_datetime)\n\n[1] 2\n\nhour(pikachu_datetime)\n\n[1] 14\n\nminute(pikachu_datetime)\n\n[1] 30\n\nsecond(pikachu_datetime)\n\n[1] 45\n\n\nZa month() i wday() možete postaviti label = TRUE da vratite skraćeni naziv mjeseca ili dana u tjednu. Postavite abbr = FALSE da vratite puni naziv.\n\n# Datumi Pokemon turnira\npokemon_tournaments &lt;- data.frame(\n  tournament = c(\"Indigo Plateau\", \"Silver Conference\", \"Ever Grande\", \"Lily of the Valley\", \"Vertress Conference\"),\n  date = ymd(c(\"2023-03-15\", \"2023-06-20\", \"2023-09-10\", \"2023-11-05\", \"2023-12-18\")),\n  stringsAsFactors = FALSE\n)\n\n# Dodavanje informacija o mjesecu\npokemon_tournaments$month_num &lt;- month(pokemon_tournaments$date)\npokemon_tournaments$month_name &lt;- month(pokemon_tournaments$date, label = TRUE)\npokemon_tournaments$month_full &lt;- month(pokemon_tournaments$date, label = TRUE, abbr = FALSE)\n\n# Dodavanje informacija o danu u tjednu\npokemon_tournaments$weekday &lt;- wday(pokemon_tournaments$date, label = TRUE)\npokemon_tournaments$weekday_full &lt;- wday(pokemon_tournaments$date, label = TRUE, abbr = FALSE)\n\npokemon_tournaments\n\n           tournament       date month_num month_name month_full weekday\n1      Indigo Plateau 2023-03-15         3        Mar      March     Wed\n2   Silver Conference 2023-06-20         6        Jun       June     Tue\n3         Ever Grande 2023-09-10         9        Sep  September     Sun\n4  Lily of the Valley 2023-11-05        11        Nov   November     Sun\n5 Vertress Conference 2023-12-18        12        Dec   December     Mon\n  weekday_full\n1    Wednesday\n2      Tuesday\n3       Sunday\n4       Sunday\n5       Monday\n\n\n\n# Simuliramo podatke o uhvaćenim Pokemonima\nset.seed(42)\npokemon_catches &lt;- data.frame(\n  pokemon = sample(c(\"Pikachu\", \"Charizard\", \"Blastoise\", \"Venusaur\", \"Butterfree\", \"Pidgeot\", \"Alakazam\", \"Machamp\"),  100, replace = TRUE),\n  caught_datetime = ymd(\"2023-01-01\") + days(sample(0:364, 100, replace = TRUE)) + hours(sample(0:23, 100, replace = TRUE)) + minutes(sample(0:59, 100, replace = TRUE)),\n  stringsAsFactors = FALSE\n)\n\n# Analiza po danima u tjednu\npokemon_catches$weekday &lt;- wday(pokemon_catches$caught_datetime, label = TRUE, abbr = FALSE)\n\npokemon_by_weekday &lt;- pokemon_catches |&gt;\n  group_by(weekday) |&gt;\n  summarise(\n    count = n(),\n    .groups = \"drop\"\n  ) |&gt;\n  arrange(weekday)\n\npokemon_by_weekday\n\n# A tibble: 7 × 2\n  weekday   count\n  &lt;ord&gt;     &lt;int&gt;\n1 Sunday       13\n2 Monday       13\n3 Tuesday      14\n4 Wednesday    14\n5 Thursday     18\n6 Friday       10\n7 Saturday     18\n\n\n\n# Simuliramo podatke o Pokemon borbama\npokemon_battles &lt;- data.frame(\n  battle_id = 1:500,\n  battle_time = ymd_hms(\"2023-06-01 00:00:00\") + hours(sample(0:23, 500, replace = TRUE)) + minutes(sample(0:59, 500, replace = TRUE)),\n  winner = sample(c(\"Ash\", \"Gary\", \"Misty\", \"Brock\"), 500, replace = TRUE),\n  stringsAsFactors = FALSE\n)\n\n# Izdvajanje sata\npokemon_battles$battle_hour &lt;- hour(pokemon_battles$battle_time)\n\n# Analiza aktivnosti po satima\nbattles_per_hour &lt;- pokemon_battles |&gt;\n  group_by(battle_hour) |&gt;\n  summarise(\n    battle_count = n(),\n    .groups = \"drop\"\n  )\n\nbattles_per_hour\n\n# A tibble: 24 × 2\n   battle_hour battle_count\n         &lt;int&gt;        &lt;int&gt;\n 1           0           23\n 2           1           20\n 3           2           26\n 4           3           16\n 5           4           19\n 6           5           20\n 7           6           22\n 8           7           21\n 9           8           22\n10           9           29\n# ℹ 14 more rows\n\nggplot(battles_per_hour, aes(x = battle_hour, y = battle_count)) +\n  geom_col(fill = \"steelblue\") +\n  labs(\n    title = \"Pokemon Battle Activity by Hour of Day\",\n    x = \"Hour of Day\",\n    y = \"Number of Battles\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n# Simuliramo podatke o Pokemon Gym borbama\ngym_battles &lt;- data.frame(\n  gym = sample(c(\"Pewter\", \"Cerulean\", \"Vermilion\", \"Celadon\", \"Fuchsia\", \"Saffron\", \"Cinnabar\", \"Viridian\"), 1000, replace = TRUE),\n  scheduled_time = ymd_hms(\"2023-01-01 00:00:00\") + days(sample(0:364, 1000, replace = TRUE)) + hours(sample(8:20, 1000, replace = TRUE)),\n  actual_delay = sample(-10:60, 1000, replace = TRUE),\n  stringsAsFactors = FALSE\n)\n\n# Dodavanje dana u tjednu\ngym_battles$weekday &lt;- wday(gym_battles$scheduled_time, label = TRUE)\n\n# Analiza prosječnog kašnjenja po danima\ndelay_by_weekday &lt;- gym_battles |&gt;\n  group_by(weekday) |&gt;\n  summarise(\n    avg_delay = mean(actual_delay),\n    n_battles = n(),\n    .groups = \"drop\"\n  )\n\ndelay_by_weekday\n\n# A tibble: 7 × 3\n  weekday avg_delay n_battles\n  &lt;ord&gt;       &lt;dbl&gt;     &lt;int&gt;\n1 Sun          23.8       135\n2 Mon          24.9       130\n3 Tue          26.6       156\n4 Wed          25.4       154\n5 Thu          24.9       134\n6 Fri          22.1       148\n7 Sat          22.9       143\n\n\nMožemo također pogledati prosječno vrijeme po minuti unutar sata. Postoji zanimljiv uzorak: Pokemon posjeti koji se događaju u minutama 20-30 i 50-60 imaju mnogo niža kašnjenja od ostatka sata.\n\n# Simuliramo podatke o posjetima Pokemon Centru\npokemon_center_visits &lt;- data.frame(\n  trainer = sample(c(\"Ash\", \"Misty\", \"Brock\", \"Gary\", \"May\"), 2000, replace = TRUE),\n  scheduled_time = ymd_hms(\"2023-06-01 08:00:00\") + hours(rep(0:11, each = 167))[1:2000] + minutes(sample(0:59, 2000, replace = TRUE)),\n  actual_time = ymd_hms(\"2023-06-01 08:00:00\") + hours(rep(0:11, each = 167))[1:2000] + minutes(sample(0:59, 2000, replace = TRUE)) + minutes(sample(-5:30, 2000, replace = TRUE)),\n  stringsAsFactors = FALSE\n)\n\n# Izračunavanje kašnjenja\npokemon_center_visits$delay &lt;- as.numeric(\n  difftime(pokemon_center_visits$actual_time, pokemon_center_visits$scheduled_time, units = \"mins\")\n)\n\n# Analiza po minutama\npokemon_center_visits$minute &lt;- minute(pokemon_center_visits$scheduled_time)\n\ndelay_by_minute &lt;- pokemon_center_visits |&gt;\n  group_by(minute) |&gt;\n  summarise(\n    avg_delay = mean(delay),\n    n = n(),\n    .groups = \"drop\"\n  )\n\ndelay_by_minute\n\n# A tibble: 60 × 3\n   minute avg_delay     n\n    &lt;int&gt;     &lt;dbl&gt; &lt;int&gt;\n 1      0      47.7    29\n 2      1      45.8    29\n 3      2      48.0    25\n 4      3      38.1    26\n 5      4      33.1    35\n 6      5      39.5    34\n 7      6      40.6    29\n 8      7      37.5    30\n 9      8      35.4    49\n10      9      33.5    37\n# ℹ 50 more rows\n\n# Vizualizacija\nggplot(delay_by_minute, aes(x = minute, y = avg_delay)) +\n  geom_line(color = \"red\", size = 1) +\n  geom_point(color = \"darkred\") +\n  labs(\n    title = \"Average Pokemon Center Visit Delay by Minute\",\n    x = \"Minute of Hour\",\n    y = \"Average Delay (minutes)\"\n  ) +\n  theme_minimal()\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n# Simuliramo podatke o posjetima Pokemon Centru\npokemon_center_visits &lt;- data.frame(\n  trainer = sample(c(\"Ash\", \"Misty\", \"Brock\", \"Gary\", \"May\"), 2000, replace = TRUE),\n  scheduled_time = ymd_hms(\"2023-06-01 08:00:00\") + hours(rep(0:11, each = 167))[1:2000] + minutes(sample(0:59, 2000, replace = TRUE)),\n  actual_time = ymd_hms(\"2023-06-01 08:00:00\") + hours(rep(0:11, each = 167))[1:2000] + minutes(sample(0:59, 2000, replace = TRUE)) + minutes(sample(-5:30, 2000, replace = TRUE)),\n  stringsAsFactors = FALSE\n)\n\n# Izračunavanje kašnjenja\npokemon_center_visits$delay &lt;- as.numeric(\n  difftime(pokemon_center_visits$actual_time, pokemon_center_visits$scheduled_time, units = \"mins\")\n)\n\n# Analiza po minutama\npokemon_center_visits$minute &lt;- minute(pokemon_center_visits$scheduled_time)\n\ndelay_by_minute &lt;- pokemon_center_visits |&gt;\n  group_by(minute) |&gt;\n  summarise(\n    avg_delay = mean(delay),\n    n = n(),\n    .groups = \"drop\"\n  )\n\ndelay_by_minute\n\n# A tibble: 60 × 3\n   minute avg_delay     n\n    &lt;int&gt;     &lt;dbl&gt; &lt;int&gt;\n 1      0      41.2    31\n 2      1      42.3    28\n 3      2      36.0    33\n 4      3      36.3    40\n 5      4      36.8    34\n 6      5      38.3    35\n 7      6      33.9    31\n 8      7      28.4    36\n 9      8      37.4    36\n10      9      35.1    34\n# ℹ 50 more rows\n\n# Vizualizacija\nggplot(delay_by_minute, aes(x = minute, y = avg_delay)) +\n  geom_line(color = \"red\", size = 1) +\n  geom_point(color = \"darkred\") +\n  labs(\n    title = \"Average Pokemon Center Visit Delay by Minute\",\n    x = \"Minute of Hour\",\n    y = \"Average Delay (minutes)\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\nZaokruživanje\nAlternativni pristup crtanju individualnih komponenti je zaokruživanje datuma na obližnju vremensku jedinicu pomoću floor_date(), round_date() i ceiling_date(). Svaka funkcija prima vektor datuma za prilagodbu i zatim naziv jedinice za zaokruživanje prema dolje, prema gore ili najbližoj vrijednosti.\n\n# Stvaramo podatke o uhvaćenim Pokemonima kroz godinu\npokemon_yearly &lt;- data.frame(\n  pokemon = sample(c(\"Pikachu\", \"Charizard\", \"Blastoise\", \"Venusaur\", \"Gengar\", \"Dragonite\", \"Mewtwo\", \"Mew\"), 365, replace = TRUE),\n  caught_date = ymd(\"2023-01-01\") + days(0:364),\n  stringsAsFactors = FALSE\n)\n\n# Zaokruživanje na tjedne\npokemon_weekly &lt;- pokemon_yearly |&gt;\n  mutate(week = floor_date(caught_date, \"week\")) |&gt;\n  count(week, name = \"pokemon_count\")\n\npokemon_weekly\n\n         week pokemon_count\n1  2023-01-01             7\n2  2023-01-08             7\n3  2023-01-15             7\n4  2023-01-22             7\n5  2023-01-29             7\n6  2023-02-05             7\n7  2023-02-12             7\n8  2023-02-19             7\n9  2023-02-26             7\n10 2023-03-05             7\n11 2023-03-12             7\n12 2023-03-19             7\n13 2023-03-26             7\n14 2023-04-02             7\n15 2023-04-09             7\n16 2023-04-16             7\n17 2023-04-23             7\n18 2023-04-30             7\n19 2023-05-07             7\n20 2023-05-14             7\n21 2023-05-21             7\n22 2023-05-28             7\n23 2023-06-04             7\n24 2023-06-11             7\n25 2023-06-18             7\n26 2023-06-25             7\n27 2023-07-02             7\n28 2023-07-09             7\n29 2023-07-16             7\n30 2023-07-23             7\n31 2023-07-30             7\n32 2023-08-06             7\n33 2023-08-13             7\n34 2023-08-20             7\n35 2023-08-27             7\n36 2023-09-03             7\n37 2023-09-10             7\n38 2023-09-17             7\n39 2023-09-24             7\n40 2023-10-01             7\n41 2023-10-08             7\n42 2023-10-15             7\n43 2023-10-22             7\n44 2023-10-29             7\n45 2023-11-05             7\n46 2023-11-12             7\n47 2023-11-19             7\n48 2023-11-26             7\n49 2023-12-03             7\n50 2023-12-10             7\n51 2023-12-17             7\n52 2023-12-24             7\n53 2023-12-31             1\n\n# Vizualizacija\nggplot(pokemon_weekly, aes(x = week, y = pokemon_count)) +\n  geom_line(color = \"blue\") +\n  geom_point(color = \"darkblue\") +\n  labs(\n    title = \"Pokemon Caught per Week in 2023\",\n    x = \"Week\",\n    y = \"Number of Pokemon Caught\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n# Zaokruživanje na mjesece\npokemon_monthly &lt;- pokemon_yearly |&gt;\n  mutate(month = floor_date(caught_date, \"month\")) |&gt;\n  count(month, name = \"pokemon_count\")\n\n# Pregled\npokemon_monthly\n\n        month pokemon_count\n1  2023-01-01            31\n2  2023-02-01            28\n3  2023-03-01            31\n4  2023-04-01            30\n5  2023-05-01            31\n6  2023-06-01            30\n7  2023-07-01            31\n8  2023-08-01            31\n9  2023-09-01            30\n10 2023-10-01            31\n11 2023-11-01            30\n12 2023-12-01            31\n\n\nMožete koristiti zaokruživanje da pokažete distribuciju aktivnosti tijekom dana izračunavanjem razlike između vremena i najranijeg trenutka tog dana.\n\n# Analiza Pokemon borbi tijekom dana\ndaily_battles &lt;- pokemon_battles |&gt;\n  mutate(battle_time_from_midnight = battle_time - floor_date(battle_time, \"day\"))\n\n# Ova razlika daje difftime objekt\nhead(daily_battles$battle_time_from_midnight)\n\nTime differences in secs\n[1] 24120     0 48180 70320 76620 64920\n\ndaily_battles &lt;- daily_battles |&gt;\n  mutate(battle_hour_hms = as_hms(battle_time - floor_date(battle_time, \"day\")))\n\n# Vizualizacija\nggplot(daily_battles, aes(x = battle_hour_hms)) +\n  geom_freqpoly(binwidth = 60 * 30, color = \"red\", size = 1) +\n  labs(\n    title = \"Distribution of Pokemon Battles Throughout the Day\",\n    x = \"Time of Day\",\n    y = \"Number of Battles\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\nModificiranje komponenti\nTakođer možete koristiti svaku pristupnu funkciju za modificiranje komponenti datum-vremena. Ovo se često koristi pri čišćenju podataka koji imaju očito netočne datume.\n\n# Podaci s greškom u godini\npokemon_data_error &lt;- data.frame(\n  pokemon = c(\"Pikachu\", \"Charizard\", \"Blastoise\"),\n  caught_date = ymd(c(\"2023-05-15\", \"2023-06-20\", \"2022-07-10\")),\n  stringsAsFactors = FALSE\n)\n\n# Ispravljamo grešku - Blastoise je uhvaćen 2023, ne 2022\nyear(pokemon_data_error$caught_date[3]) &lt;- 2023\n\npokemon_data_error\n\n    pokemon caught_date\n1   Pikachu  2023-05-15\n2 Charizard  2023-06-20\n3 Blastoise  2023-07-10\n\n\nAlternativno, umjesto modificiranja postojeće varijable, možete stvoriti novi datum-vrijeme pomoću update(). Ovo također omogućava postavljanje više vrijednosti u jednom koraku.\n\n# Korištenje update() funkcije\npokemon_datetime &lt;- ymd_hms(\"2023-05-15 14:30:45\")\n\n# Ažuriranje samo sata\nupdate(pokemon_datetime, hour = 10)\n\n[1] \"2023-05-15 10:30:45 UTC\"\n\n# Ažuriranje više komponenti odjednom\nupdate(pokemon_datetime, year = 2024, month = 1, day = 1, hour = 0)\n\n[1] \"2024-01-01 00:30:45 UTC\"\n\n\n\n# Turniri iz različitih godina\ntournaments &lt;- data.frame(\n  name = c(\"Indigo Plateau\", \"Silver Conference\", \"Ever Grande\"),\n  date = ymd(c(\"2021-03-15\", \"2022-06-20\", \"2023-09-10\")),\n  stringsAsFactors = FALSE\n)\n\n# Normaliziramo sve na 2023. godinu za usporedbu\ntournaments$normalized_date &lt;- update(tournaments$date, year = 2023)\n\ntournaments\n\n               name       date normalized_date\n1    Indigo Plateau 2021-03-15      2023-03-15\n2 Silver Conference 2022-06-20      2023-06-20\n3       Ever Grande 2023-09-10      2023-09-10\n\n\nAko su vrijednosti prevelike, one će se prebaciti.\n\n# Primjer prebacivanja\nupdate(ymd(\"2023-01-31\"), month = 2)\n\n[1] \"2023-03-03\"\n\nupdate(ymd(\"2023-01-31\"), hour = 400)\n\n[1] \"2023-02-16 16:00:00 UTC\"\n\n\n\n# Praćenje Pokemon evolucija\npokemon_evolutions &lt;- data.frame(\n  pokemon = c(\"Charmander\", \"Charmeleon\", \"Charizard\"),\n  evolution_time = ymd_hms(c(\"2023-03-01 08:30:00\", \"2023-03-01 08:30:00\", \"2023-03-01 08:30:00\")),\n  level = c(1, 16, 36),\n  stringsAsFactors = FALSE\n)\n\n# Ažuriramo vremena evolucije na osnovu razine\npokemon_evolutions$evolution_time[2] &lt;- pokemon_evolutions$evolution_time[1] + days(15)\n\npokemon_evolutions$evolution_time[3] &lt;- pokemon_evolutions$evolution_time[2] + days(20)\n\npokemon_evolutions\n\n     pokemon      evolution_time level\n1 Charmander 2023-03-01 08:30:00     1\n2 Charmeleon 2023-03-16 08:30:00    16\n3  Charizard 2023-04-05 08:30:00    36\n\n\nVremenski raspon\nIdući dio bavljenja s datumima i vremenima je funkcioniranje aritmetika s datumima, uključujući oduzimanje, zbrajanje i dijeljenje. Ključan segment toga su vremenski rasponi: trajanja (durations) koja predstavljaju točan broj sekundi, periodi (periods) koji predstavljaju ljudske jedinice poput tjedana i mjeseci i intervali (intervals) koji predstavljaju početnu i završnu točku. Kao i uvijek najbolje je odabrati najjednostavniju strukturu podataka koja rješava problem. Ako vas zanima samo fizičko vrijeme, koristite trajanje; ako trebate dodati ljudsko vrijeme, koristite period; ako trebate saznati koliko dugo traje raspon u ljudskim jedinicama, koristite interval\nU R-u, kada oduzmete dva datuma, dobivate difftime objekt koja bilježi vremenski raspon u sekundama, minutama, satima, danima ili tjednima. Ova dvosmislenost može učiniti difftime objekte pomalo bolnim za rad, stoga lubridate pruža alternativu koja uvijek koristi sekunde - trajanje koja mogu doći s gomilom praktičnih konstruktora.\n\n# Koliko je vremena prošlo od kada je Ash dobio Pikachu-a?\nash_got_pikachu &lt;- ymd(\"2023-04-01\")\ntoday_date &lt;- ymd(\"2023-09-29\")\n\npikachu_age &lt;- today_date - ash_got_pikachu\npikachu_age\n\nTime difference of 181 days\n\n# Pretvorba u duration\nas.duration(pikachu_age)\n\n[1] \"15638400s (~25.86 weeks)\"\n\n# Konstruktori za trajanja\ndseconds(15)\n\n[1] \"15s\"\n\ndminutes(10)\n\n[1] \"600s (~10 minutes)\"\n\ndhours(c(12, 24))\n\n[1] \"43200s (~12 hours)\" \"86400s (~1 days)\"  \n\nddays(0:5)\n\n[1] \"0s\"                \"86400s (~1 days)\"  \"172800s (~2 days)\"\n[4] \"259200s (~3 days)\" \"345600s (~4 days)\" \"432000s (~5 days)\"\n\ndweeks(3)\n\n[1] \"1814400s (~3 weeks)\"\n\ndyears(1)\n\n[1] \"31557600s (~1 years)\"\n\n\nTrajanja uvijek bilježe vremenski raspon u sekundama. Veće jedinice nastaju pretvaranjem minuta, sati, dana, tjedana i godina u sekunde: 60 sekundi u minuti, 60 minuta u satu, 24 sata u danu i 7 dana u tjednu. Veće vremenske jedinice su problematičnije. Godina koristi “prosječan” broj dana u godini, tj. 365.25.\nAritmetika s trajanjima:\n\n# Možete zbrajati i množiti trajanja\n2 * dyears(1)\n\n[1] \"63115200s (~2 years)\"\n\ndyears(1) + dweeks(12) + dhours(15)\n\n[1] \"38869200s (~1.23 years)\"\n\n\n\n# Pokemon trening raspored\npokemon_training_schedule &lt;- data.frame(\n  pokemon = c(\"Pikachu\", \"Charizard\", \"Blastoise\", \"Venusaur\"),\n  daily_training = c(dhours(2), dhours(3), dhours(2.5), dhours(2)),\n  days_trained = c(30, 25, 28, 32),\n  stringsAsFactors = FALSE\n)\n\n# Izračunavanje ukupnog vremena treninga\npokemon_training_schedule$total_training &lt;- pokemon_training_schedule$daily_training * pokemon_training_schedule$days_trained\n\npokemon_training_schedule\n\n    pokemon     daily_training days_trained       total_training\n1   Pikachu   7200s (~2 hours)           30  216000s (~2.5 days)\n2 Charizard  10800s (~3 hours)           25 270000s (~3.12 days)\n3 Blastoise 9000s (~2.5 hours)           28 252000s (~2.92 days)\n4  Venusaur   7200s (~2 hours)           32 230400s (~2.67 days)\n\n# Kada će Pokemon biti spreman za borbu?\nstart_training &lt;- ymd(\"2023-06-01\")\n\n# Dodavanje trajanja\nstart_training + ddays(30)\n\n[1] \"2023-07-01\"\n\nstart_training + dweeks(4)\n\n[1] \"2023-06-29\"\n\n\nMeđutim, budući da trajanja predstavljaju točan broj sekundi, ponekad možete dobiti neočekivani rezultat.\n\n# Problem s ljetnim računanjem vremena\none_am &lt;- ymd_hms(\"2023-03-12 01:00:00\", tz = \"America/New_York\")\none_am\n\n[1] \"2023-03-12 01:00:00 EST\"\n\none_am + ddays(1)\n\n[1] \"2023-03-13 02:00:00 EDT\"\n\n\nZašto je jedan dan nakon 1 ujutro 12. ožujka, 2 ujutro 13. ožujka? Ako pažljivo pogledate datum, možda ćete primijetiti i da su se vremenske zone promijenile. 12. ožujka ima samo 23 sata jer je to kada počinje ljetno računanje vremena, pa ako dodamo puni dani vrijednosti sekundi, završavamo s različitim vremenom.\n\n# Evolucija Pokemon na dan promjene na ljetno računanje vremena\nevolution_time &lt;- ymd_hms(\"2023-03-12 01:00:00\", tz = \"America/New_York\")\n\n# Dodavanje 1 dana kao trajanje\nevolution_time + ddays(1)\n\n[1] \"2023-03-13 02:00:00 EDT\"\n\n# Dodavanje točno 24 sata\nevolution_time + dhours(24)\n\n[1] \"2023-03-13 02:00:00 EDT\"\n\n\nDa bi se riješio ovaj problem, lubridate pruža periode. Periodi su vremenski rasponi, ali nemaju fiksnu duljinu u sekundama; umjesto toga rade s “ljudskim” vremenima, poput dana i mjeseci. To im omogućava rad na intuitivniji način.\n\none_am\n\n[1] \"2023-03-12 01:00:00 EST\"\n\none_am + days(1)\n\n[1] \"2023-03-13 01:00:00 EDT\"\n\n\nPoput trajanja, periodi se mogu stvoriti nizom korisnih funkcija konstruktora.\n\nseconds(15)\n\n[1] \"15S\"\n\nminutes(10)\n\n[1] \"10M 0S\"\n\nhours(c(12, 24))\n\n[1] \"12H 0M 0S\" \"24H 0M 0S\"\n\ndays(7)\n\n[1] \"7d 0H 0M 0S\"\n\nmonths(1:6)\n\n[1] \"1m 0d 0H 0M 0S\" \"2m 0d 0H 0M 0S\" \"3m 0d 0H 0M 0S\" \"4m 0d 0H 0M 0S\"\n[5] \"5m 0d 0H 0M 0S\" \"6m 0d 0H 0M 0S\"\n\nweeks(3)\n\n[1] \"21d 0H 0M 0S\"\n\nyears(1)\n\n[1] \"1y 0m 0d 0H 0M 0S\"\n\n\n\n# Evolucijska vremena različitih Pokemon\npokemon_evolutions &lt;- data.frame(\n  species = c(\"Bulbasaur\", \"Ivysaur\", \"Venusaur\", \"Charmander\", \"Charmeleon\", \"Charizard\", \"Squirtle\", \"Wartortle\", \"Blastoise\"),\n  evolution_stage = c(1, 2, 3, 1, 2, 3, 1, 2, 3),\n  time_to_evolve = c(months(0), months(2), months(3), months(0), months(2), months(4), months(0), months(2) + weeks(2), months(3) + weeks(2)),\n  stringsAsFactors = FALSE\n)\n\n# Izračunavanje ukupnog vremena od početka do finalne evolucije\npokemon_evolutions |&gt;\n  mutate(evolution_line = case_when(\n    grepl(\"Bulb|Ivy|Venu\", species) ~ \"Bulbasaur line\",\n    grepl(\"Char\", species) ~ \"Charmander line\",\n    grepl(\"Squir|Wart|Blast\", species) ~ \"Squirtle line\"\n  )) |&gt;\n  group_by(evolution_line) |&gt;\n  summarise(\n    final_form = last(species),\n    total_time = sum(time_to_evolve),\n    .groups = \"drop\"\n  )\n\n# A tibble: 3 × 3\n  evolution_line  final_form total_time\n  &lt;chr&gt;           &lt;chr&gt;           &lt;dbl&gt;\n1 Bulbasaur line  Venusaur            0\n2 Charmander line Charizard           0\n3 Squirtle line   Blastoise           0\n\n\nAritmetika s periodima:\n\n# Zbrajanje perioda\n10 * (months(6) + days(1))\n\n[1] \"60m 10d 0H 0M 0S\"\n\ndays(50) + hours(25) + minutes(2)\n\n[1] \"50d 25H 2M 0S\"\n\n\n\n# Planiranje sezone Pokemon turnira\ntournament_start &lt;- ymd(\"2024-01-15\")\n\n# Turniri svaka 2 mjeseca\ntournament_dates &lt;- tournament_start + months(0:5) * 2\n\ntournament_schedule &lt;- data.frame(\n  tournament_number = 1:6,\n  date = tournament_dates,\n  tournament_name = c(\"Pewter City\", \"Cerulean City\", \"Vermilion City\", \"Celadon City\", \"Fuchsia City\", \"Saffron City\")\n)\n\ntournament_schedule\n\n  tournament_number       date tournament_name\n1                 1 2024-01-15     Pewter City\n2                 2 2024-03-15   Cerulean City\n3                 3 2024-05-15  Vermilion City\n4                 4 2024-07-15    Celadon City\n5                 5 2024-09-15    Fuchsia City\n6                 6 2024-11-15    Saffron City\n\n\nU usporedbi s trajanjima, periodi će vjerojatnije učiniti ono što očekujete.\n\n# Usporedba perioda i trajanja\none_am\n\n[1] \"2023-03-12 01:00:00 EST\"\n\none_am + days(1)\n\n[1] \"2023-03-13 01:00:00 EDT\"\n\none_am + ddays(1)\n\n[1] \"2023-03-13 02:00:00 EDT\"\n\n\n\n# Simuliramo Pokemon putovanja između regija\npokemon_travels &lt;- data.frame(\n  pokemon = c(\"Pidgeot\", \"Charizard\", \"Dragonite\", \"Aerodactyl\"),\n  departure = ymd_hms(c(\"2023-06-15 22:30:00\", \"2023-06-15 23:45:00\", \"2023-06-15 21:15:00\", \"2023-06-15 23:00:00\")),\n  arrival = ymd_hms(c(\"2023-06-15 02:30:00\", \"2023-06-15 01:20:00\", \"2023-06-15 03:45:00\", \"2023-06-15 00:30:00\")),\n  stringsAsFactors = FALSE\n)\n\n# Ovi Pokemon su letjeli preko noći!\npokemon_travels |&gt;\n  filter(arrival &lt; departure)\n\n     pokemon           departure             arrival\n1    Pidgeot 2023-06-15 22:30:00 2023-06-15 02:30:00\n2  Charizard 2023-06-15 23:45:00 2023-06-15 01:20:00\n3  Dragonite 2023-06-15 21:15:00 2023-06-15 03:45:00\n4 Aerodactyl 2023-06-15 23:00:00 2023-06-15 00:30:00\n\n\nTo su noćni letovi. Koristili smo iste informacije o datumu za vrijeme odlaska i dolaska, ali ovi Pokemon su stigli sljedećeg dana. Možemo to popraviti dodavanjem days(1) vremenu dolaska svaki noćni let.\n\n# Ispravljanje noćnih letova\npokemon_travels &lt;- pokemon_travels |&gt;\n  mutate(\n    overnight = arrival &lt; departure,\n    arrival_fixed = if_else(overnight, arrival + days(1), arrival)\n  )\n\npokemon_travels\n\n     pokemon           departure             arrival overnight\n1    Pidgeot 2023-06-15 22:30:00 2023-06-15 02:30:00      TRUE\n2  Charizard 2023-06-15 23:45:00 2023-06-15 01:20:00      TRUE\n3  Dragonite 2023-06-15 21:15:00 2023-06-15 03:45:00      TRUE\n4 Aerodactyl 2023-06-15 23:00:00 2023-06-15 00:30:00      TRUE\n        arrival_fixed\n1 2023-06-16 02:30:00\n2 2023-06-16 01:20:00\n3 2023-06-16 03:45:00\n4 2023-06-16 00:30:00\n\n# Sada svi letovi poštuju zakone fizike\npokemon_travels |&gt;\n  filter(arrival_fixed &lt; departure)\n\n[1] pokemon       departure     arrival       overnight     arrival_fixed\n&lt;0 rows&gt; (or 0-length row.names)\n\n\nŠto vraća dyears(1) / ddays(365)? Nije baš jedan, jer dyears() je definiran kao broj sekundi po prosječnoj godini, što je 365.25 dana.\n\ndyears(1) / ddays(365)\n\n[1] 1.000685\n\n\nŠto vraća years(1) / days(1)? Pa, ako je godina bila 2015, trebalo bi vratiti 365, ali ako je bila 2016, trebalo bi vratiti 366! Nema dovoljno informacija da lubridate da jasan odgovor. Umjesto toga daje procjenu.\n\nyears(1) / days(1)\n\n[1] 365.25\n\n\nAko želite točnije mjerenje, morat ćete koristiti interval. Interval je par datuma početka i kraja, ili ga možete zamisliti kao trajanje s početnom točkom\n\n# Stvaranje intervala pomoću %--% operatora\npikachu_training_start &lt;- ymd(\"2023-01-01\")\npikachu_training_end &lt;- ymd(\"2023-12-31\")\n\npikachu_training_interval &lt;- pikachu_training_start %--% pikachu_training_end\npikachu_training_interval\n\n[1] 2023-01-01 UTC--2023-12-31 UTC\n\n\nZatim ga možete podijeliti s days() da saznate koliko dana stane u godinu.\n\npikachu_training_interval / days(1)\n\n[1] 364\n\n\n\n# Različiti Pokemon i njihova razdoblja treninga\npokemon_training_periods &lt;- data.frame(\n  pokemon = c(\"Pikachu\", \"Charizard\", \"Blastoise\", \"Venusaur\"),\n  start_date = ymd(c(\"2023-01-01\", \"2023-02-15\", \"2023-03-01\", \"2023-01-15\")),\n  end_date = ymd(c(\"2023-06-30\", \"2023-08-20\", \"2023-09-15\", \"2023-12-31\")),\n  stringsAsFactors = FALSE\n)\n\n# Stvaranje intervala\npokemon_training_periods$interval &lt;- pokemon_training_periods$start_date %--% pokemon_training_periods$end_date\n\n# Izračunavanje broja dana\npokemon_training_periods$days_trained &lt;- pokemon_training_periods$interval / days(1)\n\n# Izračunavanje broja tjedana\npokemon_training_periods$weeks_trained &lt;- pokemon_training_periods$interval / weeks(1)\n\n# Izračunavanje broja mjeseci (približno)\npokemon_training_periods$months_trained &lt;- pokemon_training_periods$interval / months(1)\n\npokemon_training_periods\n\n    pokemon start_date   end_date                       interval days_trained\n1   Pikachu 2023-01-01 2023-06-30 2023-01-01 UTC--2023-06-30 UTC          180\n2 Charizard 2023-02-15 2023-08-20 2023-02-15 UTC--2023-08-20 UTC          186\n3 Blastoise 2023-03-01 2023-09-15 2023-03-01 UTC--2023-09-15 UTC          198\n4  Venusaur 2023-01-15 2023-12-31 2023-01-15 UTC--2023-12-31 UTC          350\n  weeks_trained months_trained\n1      25.71429       5.966667\n2      26.57143       6.161290\n3      28.28571       6.466667\n4      50.00000      11.516129\n\n\n\n# Pokemon koji se razvijaju na različitim razinama\npokemon_evolution_data &lt;- data.frame(\n  pokemon = c(\"Charmander\", \"Charmeleon\", \"Bulbasaur\", \"Ivysaur\", \"Squirtle\", \"Wartortle\"),\n  birth_date = ymd(c(\"2023-01-01\", \"2023-01-01\", \"2023-02-01\", \"2023-02-01\", \"2023-03-01\", \"2023-03-01\")),\n  evolution_date = ymd(c(\"2023-03-15\", \"2023-06-20\", \"2023-04-10\", \"2023-07-01\", \"2023-05-15\", \"2023-08-30\")),\n  stringsAsFactors = FALSE\n)\n\n# Stvaranje intervala i izračunavanje trajanja\npokemon_evolution_data &lt;- pokemon_evolution_data |&gt;\n  mutate(\n    growth_interval = birth_date %--% evolution_date,\n    days_to_evolve = growth_interval / days(1),\n    weeks_to_evolve = growth_interval / weeks(1),\n    approx_months = growth_interval / months(1)\n  )\n\npokemon_evolution_data\n\n     pokemon birth_date evolution_date                growth_interval\n1 Charmander 2023-01-01     2023-03-15 2023-01-01 UTC--2023-03-15 UTC\n2 Charmeleon 2023-01-01     2023-06-20 2023-01-01 UTC--2023-06-20 UTC\n3  Bulbasaur 2023-02-01     2023-04-10 2023-02-01 UTC--2023-04-10 UTC\n4    Ivysaur 2023-02-01     2023-07-01 2023-02-01 UTC--2023-07-01 UTC\n5   Squirtle 2023-03-01     2023-05-15 2023-03-01 UTC--2023-05-15 UTC\n6  Wartortle 2023-03-01     2023-08-30 2023-03-01 UTC--2023-08-30 UTC\n  days_to_evolve weeks_to_evolve approx_months\n1             73       10.428571      2.451613\n2            170       24.285714      5.633333\n3             68        9.714286      2.300000\n4            150       21.428571      5.000000\n5             75       10.714286      2.451613\n6            182       26.000000      5.935484\n\n\n\n# Stvaranje intervala za Pokemon turnire\npokemon_tournaments &lt;- data.frame(\n  tournament_name = c(\"Indigo Plateau\", \"Silver Conference\", \"Ever Grande\", \"Lily of the Valley\"),\n  start_date = ymd(c(\"2023-06-01\", \"2023-06-10\", \"2023-07-01\", \"2023-07-15\")),\n  end_date = ymd(c(\"2023-06-15\", \"2023-06-25\", \"2023-07-10\", \"2023-07-30\")),\n  stringsAsFactors = FALSE\n)\n\n# Stvaranje intervala\npokemon_tournaments$interval &lt;- pokemon_tournaments$start_date %--% pokemon_tournaments$end_date\n\n# Duljina turnira u danima - ISPRAVNO\npokemon_tournaments$duration_days &lt;- pokemon_tournaments$interval / days(1)\n\n# Duljina u tjednima\npokemon_tournaments$duration_weeks &lt;- pokemon_tournaments$interval / weeks(1)\n\npokemon_tournaments\n\n     tournament_name start_date   end_date                       interval\n1     Indigo Plateau 2023-06-01 2023-06-15 2023-06-01 UTC--2023-06-15 UTC\n2  Silver Conference 2023-06-10 2023-06-25 2023-06-10 UTC--2023-06-25 UTC\n3        Ever Grande 2023-07-01 2023-07-10 2023-07-01 UTC--2023-07-10 UTC\n4 Lily of the Valley 2023-07-15 2023-07-30 2023-07-15 UTC--2023-07-30 UTC\n  duration_days duration_weeks\n1            14       2.000000\n2            15       2.142857\n3             9       1.285714\n4            15       2.142857\n\n# Provjera preklapanja turnira\nint_overlaps(pokemon_tournaments$interval[1], pokemon_tournaments$interval[2])\n\n[1] TRUE\n\nint_overlaps(pokemon_tournaments$interval[2], pokemon_tournaments$interval[3])\n\n[1] FALSE\n\n# Provjera da li jedan interval sadrži drugi\nint_overlaps(pokemon_tournaments$interval[1], pokemon_tournaments$interval[3])\n\n[1] FALSE\n\n# Početak i kraj intervala\nint_start(pokemon_tournaments$interval[1])\n\n[1] \"2023-06-01 UTC\"\n\nint_end(pokemon_tournaments$interval[1])\n\n[1] \"2023-06-15 UTC\"\n\n# Pomicanje intervala za 5 dana\nshifted_interval &lt;- (int_start(pokemon_tournaments$interval[1]) + days(5)) %--% (int_end(pokemon_tournaments$interval[1]) + days(5))\nshifted_interval\n\n[1] 2023-06-06 UTC--2023-06-20 UTC\n\n\nKako odabrati između trajanja, perioda i intervala? Kao i uvijek, odaberite najjednostavniju strukturu podataka koja rješava vaš problem. Ako vas zanima samo fizičko vrijeme, koristite trajanje; ako trebate dodati ljudsko vrijeme, koristite period; ako trebate saznati koliko dugo traje raspon u ljudskim jedinicama, koristite interval.\nRazumijevanje ovih triju klasa ključno je za točno rukovanje vremenskim rasponima u analizi podataka. Trajanja su pouzdana za precizna mjerenja, periodi su intuitivni za ljudsko razumijevanje vremena, a intervali su najbolji kada trebate znati točno trajanje između dvije specifične točke u vremenu.",
    "crumbs": [
      "Transformacija podataka",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Datum i vrijeme</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  }
]